(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["libraryname"] = factory();
	else
		root["libraryname"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.widgetInsertMenu = exports.TextArea = exports.TextField = exports.Select = exports.RadioButton = exports.CheckBox = exports.Website = exports.SpreadSheet = exports.InlineMath = exports.Image = exports.CarryForward = exports.BlockMath = exports.Selection = exports.ShortAnswer = exports.Essay = exports.Scale = exports.ScaleDisplay = exports.Choice = exports.MultipleChoice = exports.CheckItem = exports.CheckList = exports.TextBox = exports.Input = undefined;

	var _questions = __webpack_require__(1);

	Object.defineProperty(exports, "Input", {
		enumerable: true,
		get: function get() {
			return _questions.Input;
		}
	});
	Object.defineProperty(exports, "TextBox", {
		enumerable: true,
		get: function get() {
			return _questions.TextBox;
		}
	});
	Object.defineProperty(exports, "CheckList", {
		enumerable: true,
		get: function get() {
			return _questions.CheckList;
		}
	});
	Object.defineProperty(exports, "CheckItem", {
		enumerable: true,
		get: function get() {
			return _questions.CheckItem;
		}
	});
	Object.defineProperty(exports, "MultipleChoice", {
		enumerable: true,
		get: function get() {
			return _questions.MultipleChoice;
		}
	});
	Object.defineProperty(exports, "Choice", {
		enumerable: true,
		get: function get() {
			return _questions.Choice;
		}
	});
	Object.defineProperty(exports, "ScaleDisplay", {
		enumerable: true,
		get: function get() {
			return _questions.ScaleDisplay;
		}
	});
	Object.defineProperty(exports, "Scale", {
		enumerable: true,
		get: function get() {
			return _questions.Scale;
		}
	});
	Object.defineProperty(exports, "Essay", {
		enumerable: true,
		get: function get() {
			return _questions.Essay;
		}
	});
	Object.defineProperty(exports, "ShortAnswer", {
		enumerable: true,
		get: function get() {
			return _questions.ShortAnswer;
		}
	});
	Object.defineProperty(exports, "Selection", {
		enumerable: true,
		get: function get() {
			return _questions.Selection;
		}
	});

	var _content = __webpack_require__(67);

	Object.defineProperty(exports, "BlockMath", {
		enumerable: true,
		get: function get() {
			return _content.BlockMath;
		}
	});
	Object.defineProperty(exports, "CarryForward", {
		enumerable: true,
		get: function get() {
			return _content.CarryForward;
		}
	});
	Object.defineProperty(exports, "Image", {
		enumerable: true,
		get: function get() {
			return _content.Image;
		}
	});
	Object.defineProperty(exports, "InlineMath", {
		enumerable: true,
		get: function get() {
			return _content.InlineMath;
		}
	});
	Object.defineProperty(exports, "SpreadSheet", {
		enumerable: true,
		get: function get() {
			return _content.SpreadSheet;
		}
	});
	Object.defineProperty(exports, "Website", {
		enumerable: true,
		get: function get() {
			return _content.Website;
		}
	});

	var _input = __webpack_require__(55);

	Object.defineProperty(exports, "Input", {
		enumerable: true,
		get: function get() {
			return _input.Input;
		}
	});
	Object.defineProperty(exports, "CheckBox", {
		enumerable: true,
		get: function get() {
			return _input.CheckBox;
		}
	});
	Object.defineProperty(exports, "RadioButton", {
		enumerable: true,
		get: function get() {
			return _input.RadioButton;
		}
	});
	Object.defineProperty(exports, "Select", {
		enumerable: true,
		get: function get() {
			return _input.Select;
		}
	});
	Object.defineProperty(exports, "TextField", {
		enumerable: true,
		get: function get() {
			return _input.TextField;
		}
	});
	Object.defineProperty(exports, "TextArea", {
		enumerable: true,
		get: function get() {
			return _input.TextArea;
		}
	});

	var _dom = __webpack_require__(14);

	var _menu = __webpack_require__(80);

	var contentInsertMenu = new _menu.DropdownSubmenu({ label: "Content" }, [new _menu.MenuCommandGroup("content")]);
	var questionInsertMenu = new _menu.DropdownSubmenu({ label: "Question" }, [new _menu.MenuCommandGroup("question")]);

	var widgetInsertMenu = exports.widgetInsertMenu = new _menu.Dropdown({ label: "Insert..", displayActive: true, class: "ProseMirror-widgetinsert-dropdown" }, [contentInsertMenu, questionInsertMenu]);

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-edit:hover {\n\tbackground-image: url('icons/settings.png');\n\tbackground-repeat: no-repeat;\n\tbackground-position: top left;\n\tcursor: pointer;\n }\n\n.ProseMirror-menu-dropdown-item {\n\twhite-space: nowrap;\n}\n\n.ProseMirror-menu-dropdown-menu {\n\tborder-radius: 6px;\n}\n\n.ProseMirror-menu-submenu {\n\tborder-radius: 6px;\n}\n\n");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _textbox = __webpack_require__(2);

	Object.defineProperty(exports, "TextBox", {
	  enumerable: true,
	  get: function get() {
	    return _textbox.TextBox;
	  }
	});

	var _shortanswer = __webpack_require__(54);

	Object.defineProperty(exports, "ShortAnswer", {
	  enumerable: true,
	  get: function get() {
	    return _shortanswer.ShortAnswer;
	  }
	});

	var _essay = __webpack_require__(62);

	Object.defineProperty(exports, "Essay", {
	  enumerable: true,
	  get: function get() {
	    return _essay.Essay;
	  }
	});

	var _multiplechoice = __webpack_require__(63);

	Object.defineProperty(exports, "MultipleChoice", {
	  enumerable: true,
	  get: function get() {
	    return _multiplechoice.MultipleChoice;
	  }
	});
	Object.defineProperty(exports, "Choice", {
	  enumerable: true,
	  get: function get() {
	    return _multiplechoice.Choice;
	  }
	});

	var _checklist = __webpack_require__(64);

	Object.defineProperty(exports, "CheckList", {
	  enumerable: true,
	  get: function get() {
	    return _checklist.CheckList;
	  }
	});
	Object.defineProperty(exports, "CheckItem", {
	  enumerable: true,
	  get: function get() {
	    return _checklist.CheckItem;
	  }
	});

	var _scale = __webpack_require__(65);

	Object.defineProperty(exports, "Scale", {
	  enumerable: true,
	  get: function get() {
	    return _scale.Scale;
	  }
	});
	Object.defineProperty(exports, "ScaleDisplay", {
	  enumerable: true,
	  get: function get() {
	    return _scale.ScaleDisplay;
	  }
	});

	var _selection = __webpack_require__(66);

	Object.defineProperty(exports, "Selection", {
	  enumerable: true,
	  get: function get() {
	    return _selection.Selection;
	  }
	});

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.TextBox = undefined;

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var TextBox = exports.TextBox = function (_Textblock) {
		_inherits(TextBox, _Textblock);

		function TextBox() {
			_classCallCheck(this, TextBox);

			return _possibleConstructorReturn(this, _Textblock.apply(this, arguments));
		}

		return TextBox;
	}(_model.Textblock);

	(0, _utils.defParser)(TextBox, "div", "widgets-textbox");

	TextBox.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "div", { class: "widgets-textbox" });
	};

	(0, _dom.insertCSS)("\n\n.widgets-textbox {\n\tmargin-left: 1.2em;\n}\n\n");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	        value: true
	});

	var _node = __webpack_require__(4);

	Object.defineProperty(exports, "Node", {
	        enumerable: true,
	        get: function get() {
	                return _node.Node;
	        }
	});

	var _fragment = __webpack_require__(5);

	Object.defineProperty(exports, "Fragment", {
	        enumerable: true,
	        get: function get() {
	                return _fragment.Fragment;
	        }
	});
	Object.defineProperty(exports, "emptyFragment", {
	        enumerable: true,
	        get: function get() {
	                return _fragment.emptyFragment;
	        }
	});

	var _mark = __webpack_require__(8);

	Object.defineProperty(exports, "Mark", {
	        enumerable: true,
	        get: function get() {
	                return _mark.Mark;
	        }
	});

	var _schema = __webpack_require__(10);

	Object.defineProperty(exports, "SchemaSpec", {
	        enumerable: true,
	        get: function get() {
	                return _schema.SchemaSpec;
	        }
	});
	Object.defineProperty(exports, "Schema", {
	        enumerable: true,
	        get: function get() {
	                return _schema.Schema;
	        }
	});
	Object.defineProperty(exports, "SchemaError", {
	        enumerable: true,
	        get: function get() {
	                return _schema.SchemaError;
	        }
	});
	Object.defineProperty(exports, "NodeType", {
	        enumerable: true,
	        get: function get() {
	                return _schema.NodeType;
	        }
	});
	Object.defineProperty(exports, "Block", {
	        enumerable: true,
	        get: function get() {
	                return _schema.Block;
	        }
	});
	Object.defineProperty(exports, "Textblock", {
	        enumerable: true,
	        get: function get() {
	                return _schema.Textblock;
	        }
	});
	Object.defineProperty(exports, "Inline", {
	        enumerable: true,
	        get: function get() {
	                return _schema.Inline;
	        }
	});
	Object.defineProperty(exports, "Text", {
	        enumerable: true,
	        get: function get() {
	                return _schema.Text;
	        }
	});
	Object.defineProperty(exports, "MarkType", {
	        enumerable: true,
	        get: function get() {
	                return _schema.MarkType;
	        }
	});
	Object.defineProperty(exports, "Attribute", {
	        enumerable: true,
	        get: function get() {
	                return _schema.Attribute;
	        }
	});

	var _defaultschema = __webpack_require__(12);

	Object.defineProperty(exports, "defaultSchema", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.defaultSchema;
	        }
	});
	Object.defineProperty(exports, "Doc", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.Doc;
	        }
	});
	Object.defineProperty(exports, "BlockQuote", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.BlockQuote;
	        }
	});
	Object.defineProperty(exports, "OrderedList", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.OrderedList;
	        }
	});
	Object.defineProperty(exports, "BulletList", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.BulletList;
	        }
	});
	Object.defineProperty(exports, "ListItem", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.ListItem;
	        }
	});
	Object.defineProperty(exports, "HorizontalRule", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.HorizontalRule;
	        }
	});
	Object.defineProperty(exports, "Paragraph", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.Paragraph;
	        }
	});
	Object.defineProperty(exports, "Heading", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.Heading;
	        }
	});
	Object.defineProperty(exports, "CodeBlock", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.CodeBlock;
	        }
	});
	Object.defineProperty(exports, "Image", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.Image;
	        }
	});
	Object.defineProperty(exports, "HardBreak", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.HardBreak;
	        }
	});
	Object.defineProperty(exports, "CodeMark", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.CodeMark;
	        }
	});
	Object.defineProperty(exports, "EmMark", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.EmMark;
	        }
	});
	Object.defineProperty(exports, "StrongMark", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.StrongMark;
	        }
	});
	Object.defineProperty(exports, "LinkMark", {
	        enumerable: true,
	        get: function get() {
	                return _defaultschema.LinkMark;
	        }
	});

	var _pos = __webpack_require__(9);

	Object.defineProperty(exports, "Pos", {
	        enumerable: true,
	        get: function get() {
	                return _pos.Pos;
	        }
	});

	var _diff = __webpack_require__(13);

	Object.defineProperty(exports, "findDiffStart", {
	        enumerable: true,
	        get: function get() {
	                return _diff.findDiffStart;
	        }
	});
	Object.defineProperty(exports, "findDiffEnd", {
	        enumerable: true,
	        get: function get() {
	                return _diff.findDiffEnd;
	        }
	});

	var _error = __webpack_require__(6);

	Object.defineProperty(exports, "ModelError", {
	        enumerable: true,
	        get: function get() {
	                return _error.ModelError;
	        }
	});

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TextNode = exports.Node = undefined;

	var _fragment = __webpack_require__(5);

	var _mark = __webpack_require__(8);

	var _pos = __webpack_require__(9);

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var emptyArray = [],
	    emptyAttrs = Object.create(null);

	// ;; This class represents a node in the tree that makes up a
	// ProseMirror document. So a document is an instance of `Node`, with
	// children that are also instances of `Node`.
	//
	// Nodes are persistent data structures. Instead of changing them, you
	// create new ones with the content you want. Old ones keep pointing
	// at the old document shape. This is made cheaper by sharing
	// structure between the old and new data as much as possible, which a
	// tree shape like this (without back pointers) makes easy.
	//
	// **Never** directly mutate the properties of a `Node` object. See
	// [this guide](guide/doc.html) for more information.

	var Node = function () {
	  function Node(type, attrs, content, marks) {
	    _classCallCheck(this, Node);

	    // :: NodeType
	    // The type of node that this is.
	    this.type = type;

	    // :: Object
	    // An object mapping attribute names to string values. The kind of
	    // attributes allowed and required are determined by the node
	    // type.
	    this.attrs = attrs;

	    // :: Fragment
	    // The node's content.
	    this.content = content || _fragment.emptyFragment;

	    // :: [Mark]
	    // The marks (things like whether it is emphasized or part of a
	    // link) associated with this node.
	    this.marks = marks || emptyArray;
	  }

	  // :: number
	  // The size of the node's content, which is the maximum offset in
	  // the node. For nodes that don't contain text, this is also the
	  // number of child nodes that the node has.

	  _createClass(Node, [{
	    key: "child",

	    // :: (number) → Node
	    // Retrieve the child at the given offset. Note that this is **not**
	    // the appropriate way to loop over a node. `child`'s complexity may
	    // be non-constant for some nodes, and it will return the same node
	    // multiple times when calling it for different offsets within a
	    // text node.
	    value: function child(off) {
	      return this.content.child(off);
	    }

	    // :: (?number, ?number) → Iterator<Node>
	    // Create an iterator over this node's children, optionally starting
	    // and ending at a given offset.

	  }, {
	    key: "iter",
	    value: function iter(start, end) {
	      return this.content.iter(start, end);
	    }

	    // :: (?number, ?number) → Iterator<Node>
	    // Create a reverse iterator (iterating from the node's end towards
	    // its start) over this node's children, optionally starting and
	    // ending at a given offset. **Note**: if given, `start` should be
	    // greater than (or equal) to `end`.

	  }, {
	    key: "reverseIter",
	    value: function reverseIter(start, end) {
	      return this.content.reverseIter(start, end);
	    }

	    // :: (number) → {start: number, node: Node}
	    // Find the node that sits before a given offset. Can be used to
	    // find out which text node covers a given offset. The `start`
	    // property of the return value is the starting offset of the
	    // returned node. It is an error to call this with offset 0.

	  }, {
	    key: "chunkBefore",
	    value: function chunkBefore(off) {
	      return this.content.chunkBefore(off);
	    }

	    // :: (number) → {start: number, node: Node}
	    // Find the node that sits after a given offset. The `start`
	    // property of the return value is the starting offset of the
	    // returned node. It is an error to call this with offset
	    // corresponding to the end of the node.

	  }, {
	    key: "chunkAfter",
	    value: function chunkAfter(off) {
	      return this.content.chunkAfter(off);
	    }

	    // :: ((node: Node, start: number, end: number))
	    // Call the given function for each child node. The function will be
	    // given the node, as well as its start and end offsets, as
	    // arguments.

	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      this.content.forEach(f);
	    }

	    // :: string
	    // Concatenate all the text nodes found in this fragment and its
	    // children.

	  }, {
	    key: "sameMarkup",

	    // :: (Node) → bool
	    // Compare the markup (type, attributes, and marks) of this node to
	    // those of another. Returns `true` if both have the same markup.
	    value: function sameMarkup(other) {
	      return this.hasMarkup(other.type, other.attrs, other.marks);
	    }

	    // :: (NodeType, ?Object, ?[Mark]) → bool
	    // Check whether this node's markup correspond to the given type,
	    // attributes, and marks.

	  }, {
	    key: "hasMarkup",
	    value: function hasMarkup(type, attrs, marks) {
	      return this.type == type && Node.sameAttrs(this.attrs, attrs || emptyAttrs) && _mark.Mark.sameSet(this.marks, marks || emptyArray);
	    }
	  }, {
	    key: "copy",

	    // :: (?Fragment) → Node
	    // Create a new node with the same markup as this node, containing
	    // the given content (or empty, if no content is given).
	    value: function copy() {
	      var content = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

	      return new this.constructor(this.type, this.attrs, content, this.marks);
	    }

	    // :: ([Mark]) → Node
	    // Create a copy of this node, with the given set of marks instead
	    // of the node's own marks.

	  }, {
	    key: "mark",
	    value: function mark(marks) {
	      return new this.constructor(this.type, this.attrs, this.content, marks);
	    }

	    // :: (number, ?number) → Node
	    // Create a copy of this node with only the content between the
	    // given offsets. If `to` is not given, it defaults to the end of
	    // the node.

	  }, {
	    key: "slice",
	    value: function slice(from, to) {
	      return this.copy(this.content.slice(from, to));
	    }

	    // :: (number, number, Fragment) → Node
	    // Create a copy of this node with the content between the given
	    // offsets replaced by the given fragment.

	  }, {
	    key: "splice",
	    value: function splice(from, to, replace) {
	      return this.copy(this.content.slice(0, from).append(replace).append(this.content.slice(to)));
	    }

	    // :: (Fragment, ?number, ?number) → Node
	    // [Append](#Fragment.append) the given fragment to this node's
	    // content, and create a new node with the result.

	  }, {
	    key: "append",
	    value: function append(fragment) {
	      var joinLeft = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	      var joinRight = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	      return this.copy(this.content.append(fragment, joinLeft, joinRight));
	    }

	    // :: (number, Node) → Node
	    // Return a copy of this node with the child at the given offset
	    // replaced by the given node. **Note**: The offset should not fall
	    // within a text node.

	  }, {
	    key: "replace",
	    value: function replace(pos, node) {
	      return this.copy(this.content.replace(pos, node));
	    }

	    // :: ([number], Node) → Node
	    // Return a copy of this node with the descendant at `path` replaced
	    // by the given replacement node. This will copy as many sub-nodes as
	    // there are elements in `path`.

	  }, {
	    key: "replaceDeep",
	    value: function replaceDeep(path, node) {
	      var depth = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	      if (depth == path.length) return node;
	      var pos = path[depth];
	      return this.replace(pos, this.child(pos).replaceDeep(path, node, depth + 1));
	    }

	    // :: (number, string) → Node
	    // “Close” this node by making sure that, if it is empty, and is not
	    // allowed to be so, it has its default content inserted. When depth
	    // is greater than zero, sub-nodes at the given side (which can be
	    // `"start"` or `"end"`) are closed too. Returns itself if no work
	    // is necessary, or a closed copy if something did need to happen.

	  }, {
	    key: "close",
	    value: function close(depth, side) {
	      if (depth == 0 && this.size == 0 && !this.type.canBeEmpty) return this.copy(this.type.defaultContent());
	      var closedContent = undefined;
	      if (depth > 0 && (closedContent = this.content.close(depth - 1, side)) != this.content) return this.copy(closedContent);
	      return this;
	    }

	    // :: ([number]) → Node
	    // Get the descendant node at the given path, which is interpreted
	    // as a series of offsets into successively deeper nodes. For example,
	    // if a node contains a paragraph and a list with 3 items, the path
	    // to the first item in the list would be [1, 0].

	  }, {
	    key: "path",
	    value: function path(_path) {
	      for (var i = 0, node = this; i < _path.length; node = node.child(_path[i]), i++) {}
	      return node;
	    }

	    // :: (Pos) → ?Node
	    // Get the node after the given position, if any.

	  }, {
	    key: "nodeAfter",
	    value: function nodeAfter(pos) {
	      var parent = this.path(pos.path);
	      return pos.offset < parent.size ? parent.child(pos.offset) : null;
	    }
	  }, {
	    key: "pathNodes",
	    value: function pathNodes(path) {
	      var nodes = [];
	      for (var i = 0, node = this;; i++) {
	        nodes.push(node);
	        if (i == path.length) break;
	        node = node.child(path[i]);
	      }
	      return nodes;
	    }

	    // :: (Pos, Pos) → {from: Pos, to: Pos}
	    // Finds the narrowest sibling range (two positions that both point
	    // into the same node) that encloses the given positions.

	  }, {
	    key: "siblingRange",
	    value: function siblingRange(from, to) {
	      for (var i = 0, node = this;; i++) {
	        if (node.isTextblock) {
	          var path = from.path.slice(0, i - 1),
	              offset = from.path[i - 1];
	          return { from: new _pos.Pos(path, offset), to: new _pos.Pos(path, offset + 1) };
	        }
	        var fromEnd = i == from.path.length,
	            toEnd = i == to.path.length;
	        var left = fromEnd ? from.offset : from.path[i];
	        var right = toEnd ? to.offset : to.path[i];
	        if (fromEnd || toEnd || left != right) {
	          var path = from.path.slice(0, i);
	          return { from: new _pos.Pos(path, left), to: new _pos.Pos(path, right + (toEnd ? 0 : 1)) };
	        }
	        node = node.child(left);
	      }
	    }

	    // :: (?Pos, ?Pos, (node: Node, path: [number], parent: Node))
	    // Iterate over all nodes between the given two positions, calling
	    // the callback with the node, the path towards it, and its parent
	    // node, as arguments. `from` and `to` may be `null` to denote
	    // starting at the start of the node or ending at its end. Note that
	    // the path passed to the callback is mutated as iteration
	    // continues, so if you want to preserve it, make a copy.

	  }, {
	    key: "nodesBetween",
	    value: function nodesBetween(from, to, f) {
	      var path = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];
	      var parent = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];

	      if (f(this, path, parent) === false) return;
	      this.content.nodesBetween(from, to, f, path, this);
	    }

	    // :: (?Pos, ?Pos, (node: Node, path: [number], start: number, end: number, parent: Node))
	    // Calls the given function for each inline node between the two
	    // given positions. Pass null for `from` or `to` to start or end at
	    // the start or end of the node.

	  }, {
	    key: "inlineNodesBetween",
	    value: function inlineNodesBetween(from, to, f) {
	      this.nodesBetween(from, to, function (node, path, parent) {
	        if (node.isInline) {
	          var last = path.length - 1;
	          f(node, path.slice(0, last), path[last], path[last] + node.width, parent);
	        }
	      });
	    }

	    // :: (?Pos, ?Pos) → Node
	    // Returns a copy of this node containing only the content between
	    // `from` and `to`. You can pass `null` for either of them to start
	    // or end at the start or end of the node.

	  }, {
	    key: "sliceBetween",
	    value: function sliceBetween(from, to) {
	      var depth = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	      return this.copy(this.content.sliceBetween(from, to, depth));
	    }

	    // :: (Pos) → [Mark]
	    // Get the marks of the node before the given position or, if that
	    // position is at the start of a non-empty node, those of the node
	    // after it.

	  }, {
	    key: "marksAt",
	    value: function marksAt(pos) {
	      var parent = this.path(pos.path);
	      if (!parent.isTextblock || !parent.size) return emptyArray;
	      return parent.chunkBefore(pos.offset || 1).node.marks;
	    }

	    // :: (?Pos, ?Pos, MarkType) → bool
	    // Test whether a mark of the given type occurs in this document
	    // between the two given positions.

	  }, {
	    key: "rangeHasMark",
	    value: function rangeHasMark(from, to, type) {
	      var found = false;
	      this.nodesBetween(from, to, function (node) {
	        if (type.isInSet(node.marks)) found = true;
	      });
	      return found;
	    }

	    // :: bool
	    // True when this is a block (non-inline node)

	  }, {
	    key: "toString",

	    // :: () → string
	    // Return a string representation of this node for debugging
	    // purposes.
	    value: function toString() {
	      var name = this.type.name;
	      if (this.content.size) name += "(" + this.content.toString() + ")";
	      return wrapMarks(this.marks, name);
	    }

	    // :: () → Object
	    // Return a JSON-serializeable representation of this node.

	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var obj = { type: this.type.name };
	      for (var _ in this.attrs) {
	        obj.attrs = this.attrs;
	        break;
	      }
	      if (this.size) obj.content = this.content.toJSON();
	      if (this.marks.length) obj.marks = this.marks.map(function (n) {
	        return n.toJSON();
	      });
	      return obj;
	    }

	    // This is a hack to be able to treat a node object as an iterator result

	  }, {
	    key: "size",
	    get: function get() {
	      return this.content.size;
	    }

	    // :: number
	    // The width of this node. Always 1 for non-text nodes, and the
	    // length of the text for text nodes.

	  }, {
	    key: "width",
	    get: function get() {
	      return 1;
	    }
	  }, {
	    key: "textContent",
	    get: function get() {
	      return this.content.textContent;
	    }

	    // :: ?Node
	    // Returns this node's first child, or `null` if there are no
	    // children.

	  }, {
	    key: "firstChild",
	    get: function get() {
	      return this.content.firstChild;
	    }

	    // :: ?Node
	    // Returns this node's last child, or `null` if there are no
	    // children.

	  }, {
	    key: "lastChild",
	    get: function get() {
	      return this.content.lastChild;
	    }
	  }, {
	    key: "isBlock",
	    get: function get() {
	      return this.type.isBlock;
	    }

	    // :: bool
	    // True when this is a textblock node, a block node with inline
	    // content.

	  }, {
	    key: "isTextblock",
	    get: function get() {
	      return this.type.isTextblock;
	    }

	    // :: bool
	    // True when this is an inline node (a text node or a node that can
	    // appear among text).

	  }, {
	    key: "isInline",
	    get: function get() {
	      return this.type.isInline;
	    }

	    // :: bool
	    // True when this is a text node.

	  }, {
	    key: "isText",
	    get: function get() {
	      return this.type.isText;
	    }
	  }, {
	    key: "value",
	    get: function get() {
	      return this;
	    }

	    // :: (Schema, Object) → Node
	    // Deserialize a node from its JSON representation.

	  }], [{
	    key: "sameAttrs",
	    value: function sameAttrs(a, b) {
	      if (a == b) return true;
	      for (var prop in a) {
	        if (a[prop] !== b[prop]) return false;
	      }return true;
	    }
	  }, {
	    key: "fromJSON",
	    value: function fromJSON(schema, json) {
	      var type = schema.nodeType(json.type);
	      var content = json.text != null ? json.text : _fragment.Fragment.fromJSON(schema, json.content);
	      return type.create(json.attrs, content, json.marks && json.marks.map(schema.markFromJSON));
	    }
	  }]);

	  return Node;
	}();

	exports.Node = Node;

	if (typeof Symbol != "undefined") {
	  // :: () → Iterator<Node>
	  // A fragment is iterable, in the ES6 sense.
	  Node.prototype[Symbol.iterator] = function () {
	    return this.iter();
	  };
	}

	// ;; #forward=Node

	var TextNode = exports.TextNode = function (_Node) {
	  _inherits(TextNode, _Node);

	  function TextNode(type, attrs, content, marks) {
	    _classCallCheck(this, TextNode);

	    // :: ?string
	    // For text nodes, this contains the node's text content.

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TextNode).call(this, type, attrs, null, marks));

	    _this.text = content;
	    return _this;
	  }

	  _createClass(TextNode, [{
	    key: "toString",
	    value: function toString() {
	      return wrapMarks(this.marks, JSON.stringify(this.text));
	    }
	  }, {
	    key: "mark",
	    value: function mark(marks) {
	      return new TextNode(this.type, this.attrs, this.text, marks);
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var base = _get(Object.getPrototypeOf(TextNode.prototype), "toJSON", this).call(this);
	      base.text = this.text;
	      return base;
	    }
	  }, {
	    key: "textContent",
	    get: function get() {
	      return this.text;
	    }
	  }, {
	    key: "width",
	    get: function get() {
	      return this.text.length;
	    }
	  }]);

	  return TextNode;
	}(Node);

	function wrapMarks(marks, str) {
	  for (var i = marks.length - 1; i >= 0; i--) {
	    str = marks[i].type.name + "(" + str + ")";
	  }return str;
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.emptyFragment = exports.Fragment = undefined;

	var _error = __webpack_require__(6);

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; A fragment is an abstract type used to represent a node's
	// collection of child nodes. It tries to hide considerations about
	// the actual way in which the child nodes are stored, so that
	// different representations (nodes that only contain simple nodes
	// versus nodes that also contain text) can be approached using the
	// same API.
	//
	// Fragments are persistent data structures. That means you should
	// _not_ mutate them or their content, but create new instances
	// whenever needed. The API tries to make this easy.

	var Fragment = exports.Fragment = function () {
	  function Fragment() {
	    _classCallCheck(this, Fragment);
	  }

	  _createClass(Fragment, [{
	    key: "append",

	    // :: (Fragment, number, number) → Fragment
	    // Create a fragment that combines this one with another fragment.
	    // Takes care of merging adjacent text nodes and can also merge
	    // “open” nodes at the boundary. `joinLeft` and `joinRight` give the
	    // depth to which the left and right fragments are open. If open
	    // nodes with the same markup are found on both sides, they are
	    // joined. If not, the open nodes are [closed](#Node.close).
	    value: function append(other) {
	      var joinLeft = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	      var joinRight = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	      if (!this.size) return joinRight ? other.replace(0, other.firstChild.close(joinRight - 1, "start")) : other;
	      if (!other.size) return joinLeft ? this.replace(this.size - 1, this.lastChild.close(joinLeft - 1, "end")) : this;
	      return this.appendInner(other, joinLeft, joinRight);
	    }

	    // :: string
	    // Concatenate all the text nodes found in this fragment and its
	    // children.

	  }, {
	    key: "toString",

	    // :: () → string
	    // Return a debugging string that describes this fragment.
	    value: function toString() {
	      var str = "";
	      this.forEach(function (n) {
	        return str += (str ? ", " : "") + n.toString();
	      });
	      return str;
	    }

	    // :: (number, number, ?(Node) → Node) → [Node]
	    // Produce an array with the child nodes between the given
	    // boundaries, optionally mapping a function over them.

	  }, {
	    key: "toArray",
	    value: function toArray() {
	      var from = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	      var to = arguments.length <= 1 || arguments[1] === undefined ? this.size : arguments[1];
	      var f = arguments[2];

	      var result = [];
	      for (var iter = this.iter(from, to), n; n = iter.next().value;) {
	        result.push(f ? f(n) : n);
	      }return result;
	    }

	    // :: ((Node) → Node) → Fragment
	    // Produce a new Fragment by mapping all this fragment's children
	    // through a function.

	  }, {
	    key: "map",
	    value: function map(f) {
	      return Fragment.fromArray(this.toArray(undefined, undefined, f));
	    }

	    // :: ((Node) → bool) → bool
	    // Returns `true` if the given function returned `true` for any of
	    // the fragment's children.

	  }, {
	    key: "some",
	    value: function some(f) {
	      for (var iter = this.iter(), n; n = iter.next().value;) {
	        if (f(n)) return n;
	      }
	    }
	  }, {
	    key: "close",
	    value: function close(depth, side) {
	      var child = side == "start" ? this.firstChild : this.lastChild;
	      var closed = child.close(depth - 1, side);
	      if (closed == child) return this;
	      return this.replace(side == "start" ? 0 : this.size - 1, closed);
	    }
	  }, {
	    key: "nodesBetween",
	    value: function nodesBetween(from, to, f, path, parent) {
	      var moreFrom = from && from.depth > path.length,
	          moreTo = to && to.depth > path.length;
	      var start = moreFrom ? from.path[path.length] : from ? from.offset : 0;
	      var end = moreTo ? to.path[path.length] + 1 : to ? to.offset : this.size;
	      for (var iter = this.iter(start, end), node; node = iter.next().value;) {
	        var startOffset = iter.offset - node.width;
	        path.push(startOffset);
	        node.nodesBetween(moreFrom && startOffset == start ? from : null, moreTo && iter.offset == end ? to : null, f, path, parent);
	        path.pop();
	      }
	    }

	    // :: (?Pos, ?Pos) → Fragment
	    // Slice out the sub-fragment between the two given positions.
	    // `null` can be passed for either to indicate the slice should go
	    // all the way to the start or end of the fragment.

	  }, {
	    key: "sliceBetween",
	    value: function sliceBetween(from, to) {
	      var depth = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	      var moreFrom = from && from.depth > depth,
	          moreTo = to && to.depth > depth;
	      var start = moreFrom ? from.path[depth] : from ? from.offset : 0;
	      var end = moreTo ? to.path[depth] + 1 : to ? to.offset : this.size;
	      var nodes = [];
	      for (var iter = this.iter(start, end), node; node = iter.next().value;) {
	        var passFrom = moreFrom && iter.offset - node.width == start ? from : null;
	        var passTo = moreTo && iter.offset == end ? to : null;
	        if (passFrom || passTo) node = node.sliceBetween(passFrom, passTo, depth + 1);
	        nodes.push(node);
	      }
	      return new this.constructor(nodes);
	    }

	    // :: (Schema, Object) → Fragment
	    // Deserialize a fragment from its JSON representation.

	  }, {
	    key: "textContent",
	    get: function get() {
	      var text = "";
	      this.forEach(function (n) {
	        return text += n.textContent;
	      });
	      return text;
	    }
	  }], [{
	    key: "fromJSON",
	    value: function fromJSON(schema, value) {
	      return value ? this.fromArray(value.map(schema.nodeFromJSON)) : emptyFragment;
	    }

	    // :: ([Node]) → Fragment
	    // Build a fragment from an array of nodes.

	  }, {
	    key: "fromArray",
	    value: function fromArray(array) {
	      if (!array.length) return emptyFragment;
	      var hasText = false,
	          joined = undefined;
	      for (var i = 0; i < array.length; i++) {
	        var node = array[i];
	        if (node.isText) {
	          hasText = true;
	          if (i && array[i - 1].sameMarkup(node)) {
	            if (!joined) joined = array.slice(0, i);
	            joined[joined.length - 1] = node.copy(joined[joined.length - 1].text + node.text);
	            continue;
	          }
	        }
	        if (joined) joined.push(node);
	      }
	      return hasText ? new TextFragment(joined || array) : new FlatFragment(array);
	    }

	    // :: (?union<Fragment, Node, [Node]>) → Fragment
	    // Create a fragment from something that can be interpreted as a set
	    // of nodes. For `null`, it returns the empty fragment. For a
	    // fragment, the fragment itself. For a node or array of nodes, a
	    // fragment containing those nodes.

	  }, {
	    key: "from",
	    value: function from(nodes) {
	      if (!nodes) return emptyFragment;
	      if (nodes instanceof Fragment) return nodes;
	      return this.fromArray(Array.isArray(nodes) ? nodes : [nodes]);
	    }
	  }]);

	  return Fragment;
	}();

	var iterEnd = { done: true };

	var FlatIterator = function () {
	  function FlatIterator(array, pos, end) {
	    _classCallCheck(this, FlatIterator);

	    this.array = array;
	    this.pos = pos;
	    this.end = end;
	  }

	  _createClass(FlatIterator, [{
	    key: "copy",
	    value: function copy() {
	      return new this.constructor(this.array, this.pos, this.end);
	    }
	  }, {
	    key: "atEnd",
	    value: function atEnd() {
	      return this.pos == this.end;
	    }
	  }, {
	    key: "next",
	    value: function next() {
	      return this.pos == this.end ? iterEnd : this.array[this.pos++];
	    }
	  }, {
	    key: "offset",
	    get: function get() {
	      return this.pos;
	    }
	  }]);

	  return FlatIterator;
	}();

	var ReverseFlatIterator = function (_FlatIterator) {
	  _inherits(ReverseFlatIterator, _FlatIterator);

	  function ReverseFlatIterator() {
	    _classCallCheck(this, ReverseFlatIterator);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ReverseFlatIterator).apply(this, arguments));
	  }

	  _createClass(ReverseFlatIterator, [{
	    key: "next",
	    value: function next() {
	      return this.pos == this.end ? iterEnd : this.array[--this.pos];
	    }
	  }]);

	  return ReverseFlatIterator;
	}(FlatIterator);

	// ;; #forward=Fragment

	var FlatFragment = function (_Fragment) {
	  _inherits(FlatFragment, _Fragment);

	  function FlatFragment(content) {
	    _classCallCheck(this, FlatFragment);

	    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(FlatFragment).call(this));

	    _this2.content = content;
	    return _this2;
	  }

	  // :: (?number, ?number) → Iterator<Node>
	  // Create a forward iterator over the content of the fragment. An
	  // explicit start and end offset can be given to have the iterator
	  // go over only part of the content. If an iteration bound falls
	  // within a text node, only the part that is within the bounds is
	  // yielded.

	  _createClass(FlatFragment, [{
	    key: "iter",
	    value: function iter() {
	      var start = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	      var end = arguments.length <= 1 || arguments[1] === undefined ? this.size : arguments[1];

	      return new FlatIterator(this.content, start, end);
	    }

	    // :: (?number, ?number) → Iterator<Node>
	    // Create a reverse iterator over the content of the fragment. An
	    // explicit start and end offset can be given to have the iterator
	    // go over only part of the content. **Note**: `start` should be
	    // greater than `end`, when passed.

	  }, {
	    key: "reverseIter",
	    value: function reverseIter() {
	      var start = arguments.length <= 0 || arguments[0] === undefined ? this.size : arguments[0];
	      var end = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	      return new ReverseFlatIterator(this.content, start, end);
	    }

	    // :: number
	    // The maximum offset in this fragment.

	  }, {
	    key: "child",

	    // :: (number) → Node
	    // Get the child at the given offset. Might return a text node that
	    // stretches before and/or after the offset.
	    value: function child(off) {
	      if (off < 0 || off >= this.content.length) _error.ModelError.raise("Offset " + off + " out of range");
	      return this.content[off];
	    }

	    // :: ((node: Node, start: number, end: number))
	    // Call the given function for each node in the fragment, passing it
	    // the node, its start offset, and its end offset.

	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      for (var i = 0; i < this.content.length; i++) {
	        f(this.content[i], i, i + 1);
	      }
	    }

	    // :: (number) → {start: number, node: Node}
	    // Find the node before the given offset. Returns an object
	    // containing the node as well as its start index. Offset should be
	    // greater than zero.

	  }, {
	    key: "chunkBefore",
	    value: function chunkBefore(off) {
	      return { node: this.child(off - 1), start: off - 1 };
	    }

	    // :: (number) → {start: number, node: Node}
	    // Find the node after the given offset. Returns an object
	    // containing the node as well as its start index. Offset should be
	    // less than the fragment's size.

	  }, {
	    key: "chunkAfter",
	    value: function chunkAfter(off) {
	      return { node: this.child(off), start: off };
	    }

	    // :: (number, ?number) → Fragment
	    // Return a fragment with only the nodes between the given offsets.
	    // When `to` is not given, the slice will go to the end of the
	    // fragment.

	  }, {
	    key: "slice",
	    value: function slice(from) {
	      var to = arguments.length <= 1 || arguments[1] === undefined ? this.size : arguments[1];

	      if (from == to) return emptyFragment;
	      return new FlatFragment(this.content.slice(from, to));
	    }

	    // :: (number, Node) → Fragment
	    // Return a fragment in which the node at the given offset is
	    // replaced by the given node. The node, as well as the one it
	    // replaces, should not be text nodes.

	  }, {
	    key: "replace",
	    value: function replace(offset, node) {
	      if (node.isText) _error.ModelError.raise("Argument to replace should be a non-text node");
	      var copy = this.content.slice();
	      copy[offset] = node;
	      return new FlatFragment(copy);
	    }
	  }, {
	    key: "appendInner",
	    value: function appendInner(other, joinLeft, joinRight) {
	      var last = this.content.length - 1,
	          content = this.content.slice(0, last);
	      var before = this.content[last],
	          after = other.firstChild;
	      if (joinLeft > 0 && joinRight > 0 && before.sameMarkup(after)) content.push(before.append(after.content, joinLeft - 1, joinRight - 1));else content.push(before.close(joinLeft - 1, "end"), after.close(joinRight - 1, "start"));
	      return Fragment.fromArray(content.concat(other.toArray(after.width)));
	    }

	    // :: () → Object
	    // Create a JSON-serializeable representation of this fragment.

	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      return this.content.map(function (n) {
	        return n.toJSON();
	      });
	    }
	  }, {
	    key: "size",
	    get: function get() {
	      return this.content.length;
	    }

	    // :: ?Node
	    // The first child of the fragment, or `null` if it is empty.

	  }, {
	    key: "firstChild",
	    get: function get() {
	      return this.content.length ? this.content[0] : null;
	    }

	    // :: ?Node
	    // The last child of the fragment, or `null` if it is empty.

	  }, {
	    key: "lastChild",
	    get: function get() {
	      return this.content.length ? this.content[this.content.length - 1] : null;
	    }
	  }]);

	  return FlatFragment;
	}(Fragment);

	// :: Fragment
	// An empty fragment. Intended to be reused whenever a node doesn't
	// contain anything (rather than allocating a new empty fragment for
	// each leaf node).

	var emptyFragment = exports.emptyFragment = new FlatFragment([]);

	var TextIterator = function () {
	  function TextIterator(fragment, startOffset, endOffset) {
	    var pos = arguments.length <= 3 || arguments[3] === undefined ? -1 : arguments[3];

	    _classCallCheck(this, TextIterator);

	    this.frag = fragment;
	    this.offset = startOffset;
	    this.pos = pos;
	    this.endOffset = endOffset;
	  }

	  _createClass(TextIterator, [{
	    key: "copy",
	    value: function copy() {
	      return new this.constructor(this.frag, this.offset, this.endOffset, this.pos);
	    }
	  }, {
	    key: "atEnd",
	    value: function atEnd() {
	      return this.offset == this.endOffset;
	    }
	  }, {
	    key: "next",
	    value: function next() {
	      if (this.pos == -1) {
	        var start = this.init();
	        if (start) return start;
	      }
	      return this.offset == this.endOffset ? iterEnd : this.advance();
	    }
	  }, {
	    key: "advance",
	    value: function advance() {
	      var node = this.frag.content[this.pos++],
	          end = this.offset + node.width;
	      if (end > this.endOffset) {
	        node = node.copy(node.text.slice(0, this.endOffset - this.offset));
	        this.offset = this.endOffset;
	        return node;
	      }
	      this.offset = end;
	      return node;
	    }
	  }, {
	    key: "init",
	    value: function init() {
	      this.pos = 0;
	      var offset = 0;
	      while (offset < this.offset) {
	        var node = this.frag.content[this.pos++],
	            end = offset + node.width;
	        if (end == this.offset) break;
	        if (end > this.offset) {
	          var sliceEnd = node.width;
	          if (end > this.endOffset) {
	            sliceEnd = this.endOffset - offset;
	            end = this.endOffset;
	          }
	          node = node.copy(node.text.slice(this.offset - offset, sliceEnd));
	          this.offset = end;
	          return node;
	        }
	        offset = end;
	      }
	    }
	  }]);

	  return TextIterator;
	}();

	var ReverseTextIterator = function (_TextIterator) {
	  _inherits(ReverseTextIterator, _TextIterator);

	  function ReverseTextIterator() {
	    _classCallCheck(this, ReverseTextIterator);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ReverseTextIterator).apply(this, arguments));
	  }

	  _createClass(ReverseTextIterator, [{
	    key: "advance",
	    value: function advance() {
	      var node = this.frag.content[--this.pos],
	          end = this.offset - node.width;
	      if (end < this.endOffset) {
	        node = node.copy(node.text.slice(this.endOffset - end));
	        this.offset = this.endOffset;
	        return node;
	      }
	      this.offset = end;
	      return node;
	    }
	  }, {
	    key: "init",
	    value: function init() {
	      this.pos = this.frag.content.length;
	      var offset = this.frag.size;
	      while (offset > this.offset) {
	        var node = this.frag.content[--this.pos],
	            end = offset - node.width;
	        if (end == this.offset) break;
	        if (end < this.offset) {
	          if (end < this.endOffset) {
	            node = node.copy(node.text.slice(this.endOffset - end, this.offset - end));
	            end = this.endOffset;
	          } else {
	            node = node.copy(node.text.slice(0, this.offset - end));
	          }
	          this.offset = end;
	          return node;
	        }
	        offset = end;
	      }
	    }
	  }]);

	  return ReverseTextIterator;
	}(TextIterator);

	var TextFragment = function (_Fragment2) {
	  _inherits(TextFragment, _Fragment2);

	  function TextFragment(content, size) {
	    _classCallCheck(this, TextFragment);

	    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(TextFragment).call(this));

	    _this4.content = content;
	    _this4.size = size || 0;
	    if (size == null) for (var i = 0; i < content.length; i++) {
	      _this4.size += content[i].width;
	    }return _this4;
	  }

	  _createClass(TextFragment, [{
	    key: "iter",
	    value: function iter() {
	      var from = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	      var to = arguments.length <= 1 || arguments[1] === undefined ? this.size : arguments[1];

	      return new TextIterator(this, from, to);
	    }
	  }, {
	    key: "reverseIter",
	    value: function reverseIter() {
	      var from = arguments.length <= 0 || arguments[0] === undefined ? this.size : arguments[0];
	      var to = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	      return new ReverseTextIterator(this, from, to);
	    }
	  }, {
	    key: "child",
	    value: function child(off) {
	      if (off < 0 || off >= this.size) _error.ModelError.raise("Offset " + off + " out of range");
	      for (var i = 0, curOff = 0; i < this.content.length; i++) {
	        var child = this.content[i];
	        curOff += child.width;
	        if (curOff > off) return child;
	      }
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      for (var i = 0, off = 0; i < this.content.length; i++) {
	        var child = this.content[i];
	        f(child, off, off += child.width);
	      }
	    }
	  }, {
	    key: "chunkBefore",
	    value: function chunkBefore(off) {
	      if (!off) _error.ModelError.raise("No chunk before start of node");
	      for (var i = 0, curOff = 0; i < this.content.length; i++) {
	        var child = this.content[i],
	            end = curOff + child.width;
	        if (end >= off) return { node: child, start: curOff };
	        curOff = end;
	      }
	    }
	  }, {
	    key: "chunkAfter",
	    value: function chunkAfter(off) {
	      if (off == this.size) _error.ModelError.raise("No chunk after end of node");
	      for (var i = 0, curOff = 0; i < this.content.length; i++) {
	        var child = this.content[i],
	            end = curOff + child.width;
	        if (end > off) return { node: child, start: curOff };
	        curOff = end;
	      }
	    }
	  }, {
	    key: "slice",
	    value: function slice() {
	      var from = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	      var to = arguments.length <= 1 || arguments[1] === undefined ? this.size : arguments[1];

	      if (from == to) return emptyFragment;
	      return new TextFragment(this.toArray(from, to));
	    }
	  }, {
	    key: "replace",
	    value: function replace(off, node) {
	      if (node.isText) _error.ModelError.raise("Argument to replace should be a non-text node");
	      var curNode = undefined,
	          index = undefined;
	      for (var curOff = 0; curOff < off; index++) {
	        curNode = this.content[index];
	        curOff += curNode.width;
	      }
	      if (curNode.isText) _error.ModelError.raise("Can not replace text content with replace method");
	      var copy = this.content.slice();
	      copy[index] = node;
	      return new TextFragment(copy);
	    }
	  }, {
	    key: "appendInner",
	    value: function appendInner(other, joinLeft, joinRight) {
	      var last = this.content.length - 1,
	          content = this.content.slice(0, last);
	      var before = this.content[last],
	          after = other.firstChild;
	      var same = before.sameMarkup(after);
	      if (same && before.isText) content.push(before.copy(before.text + after.text));else if (same && joinLeft > 0 && joinRight > 0) content.push(before.append(after.content, joinLeft - 1, joinRight - 1));else content.push(before.close(joinLeft - 1, "end"), after.close(joinRight - 1, "start"));
	      return Fragment.fromArray(content.concat(other.toArray(after.width)));
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      return this.content.map(function (n) {
	        return n.toJSON();
	      });
	    }
	  }, {
	    key: "firstChild",
	    get: function get() {
	      return this.size ? this.content[0] : null;
	    }
	  }, {
	    key: "lastChild",
	    get: function get() {
	      return this.size ? this.content[this.content.length - 1] : null;
	    }
	  }]);

	  return TextFragment;
	}(Fragment);

	if (typeof Symbol != "undefined") {
	  // :: () → Iterator<Node>
	  // A fragment is iterable, in the ES6 sense.
	  Fragment.prototype[Symbol.iterator] = function () {
	    return this.iter();
	  };
	  FlatIterator.prototype[Symbol.iterator] = TextIterator.prototype[Symbol.iterator] = function () {
	    return this;
	  };
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ModelError = undefined;

	var _error = __webpack_require__(7);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// ;; Class used to signal model-related errors.

	var ModelError = exports.ModelError = function (_ProseMirrorError) {
	  _inherits(ModelError, _ProseMirrorError);

	  function ModelError() {
	    _classCallCheck(this, ModelError);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ModelError).apply(this, arguments));
	  }

	  return ModelError;
	}(_error.ProseMirrorError);

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// ;; Superclass for ProseMirror-related errors. Does some magic to
	// make it safely subclassable even on ES5 runtimes.

	var ProseMirrorError = exports.ProseMirrorError = function (_Error) {
	  _inherits(ProseMirrorError, _Error);

	  // :: (string)
	  // Create an instance of this error type, capturing the current
	  // stack.

	  function ProseMirrorError(message) {
	    _classCallCheck(this, ProseMirrorError);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ProseMirrorError).call(this, message));

	    if (_this.message != message) {
	      _this.message = message;
	      if (Error.captureStackTrace) Error.captureStackTrace(_this, _this.name);else _this.stack = new Error(message).stack;
	    }
	    return _this;
	  }

	  _createClass(ProseMirrorError, [{
	    key: "name",
	    get: function get() {
	      return this.constructor.name || functionName(this.constructor) || "ProseMirrorError";
	    }

	    // :: (string)
	    // Raise an exception of this type, with the given message.
	    // (Somewhat shorter than `throw new ...`, and can appear in
	    // expression position.)

	  }], [{
	    key: "raise",
	    value: function raise(message) {
	      throw new this(message);
	    }
	  }]);

	  return ProseMirrorError;
	}(Error);

	// ;; Error type used to signal miscellaneous invariant violations.

	var AssertionError = exports.AssertionError = function (_ProseMirrorError) {
	  _inherits(AssertionError, _ProseMirrorError);

	  function AssertionError() {
	    _classCallCheck(this, AssertionError);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(AssertionError).apply(this, arguments));
	  }

	  return AssertionError;
	}(ProseMirrorError);

	// ;; Error type used to report name clashes or other violations in
	// namespacing.

	var NamespaceError = exports.NamespaceError = function (_ProseMirrorError2) {
	  _inherits(NamespaceError, _ProseMirrorError2);

	  function NamespaceError() {
	    _classCallCheck(this, NamespaceError);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(NamespaceError).apply(this, arguments));
	  }

	  return NamespaceError;
	}(ProseMirrorError);

	function functionName(f) {
	  var match = /^function (\w+)/.exec(f.toString());
	  return match && match[1];
	}

/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; A mark is a piece of information that can be attached to a node,
	// such as it being emphasized, in code font, or a link. It has a type
	// and optionally a set of attributes that provide further information
	// (such as the target of the link). Marks are created through a
	// `Schema`, which controls which types exist and which
	// attributes they have.

	var Mark = exports.Mark = function () {
	  function Mark(type, attrs) {
	    _classCallCheck(this, Mark);

	    // :: MarkType
	    // The type of this mark.
	    this.type = type;
	    // :: Object
	    // The attributes associated with this mark.
	    this.attrs = attrs;
	  }

	  // :: () → Object
	  // Convert this mark to a JSON-serializeable representation.

	  _createClass(Mark, [{
	    key: "toJSON",
	    value: function toJSON() {
	      var obj = { _: this.type.name };
	      for (var attr in this.attrs) {
	        obj[attr] = this.attrs[attr];
	      }return obj;
	    }

	    // :: ([Mark]) → [Mark]
	    // Given a set of marks, create a new set which contains this one as
	    // well, in the right position. If this mark or another of its type
	    // is already in the set, the set itself is returned.

	  }, {
	    key: "addToSet",
	    value: function addToSet(set) {
	      for (var i = 0; i < set.length; i++) {
	        var other = set[i];
	        if (other.type == this.type) {
	          if (this.eq(other)) return set;else return set.slice(0, i).concat(this).concat(set.slice(i + 1));
	        }
	        if (other.type.rank > this.type.rank) return set.slice(0, i).concat(this).concat(set.slice(i));
	      }
	      return set.concat(this);
	    }

	    // :: ([Mark]) → [Mark]
	    // Remove this mark from the given set, returning a new set. If this
	    // mark is not in the set, the set itself is returned.

	  }, {
	    key: "removeFromSet",
	    value: function removeFromSet(set) {
	      for (var i = 0; i < set.length; i++) {
	        if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));
	      }return set;
	    }

	    // :: ([Mark]) → bool
	    // Test whether this mark is in the given set of marks.

	  }, {
	    key: "isInSet",
	    value: function isInSet(set) {
	      for (var i = 0; i < set.length; i++) {
	        if (this.eq(set[i])) return true;
	      }return false;
	    }

	    // :: (Mark) → bool
	    // Test whether this mark has the same type and attributes as
	    // another mark.

	  }, {
	    key: "eq",
	    value: function eq(other) {
	      if (this == other) return true;
	      if (this.type != other.type) return false;
	      for (var attr in this.attrs) {
	        if (other.attrs[attr] != this.attrs[attr]) return false;
	      }return true;
	    }

	    // :: ([Mark], [Mark]) → bool
	    // Test whether two sets of marks are identical.

	  }], [{
	    key: "sameSet",
	    value: function sameSet(a, b) {
	      if (a == b) return true;
	      if (a.length != b.length) return false;
	      for (var i = 0; i < a.length; i++) {
	        if (!a[i].eq(b[i])) return false;
	      }return true;
	    }

	    // :: (?union<Mark, [Mark]>) → [Mark]
	    // Create a properly sorted mark set from null, a single mark, or an
	    // unsorted array of marks.

	  }, {
	    key: "setFrom",
	    value: function setFrom(marks) {
	      if (!marks || marks.length == 0) return empty;
	      if (marks instanceof Mark) return [marks];
	      var copy = marks.slice();
	      copy.sort(function (a, b) {
	        return a.type.rank - b.type.rank;
	      });
	      return copy;
	    }
	  }]);

	  return Mark;
	}();

	var empty = [];

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Pos = undefined;

	var _error = __webpack_require__(6);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; Instances of the `Pos` class represent positions in a document.
	// A position is an array of integers that describe a path to the target
	// node (see `Node.path`) and an integer offset into that target node.

	var Pos = exports.Pos = function () {
	  // :: (path: [number], number)

	  function Pos(path, offset) {
	    _classCallCheck(this, Pos);

	    // :: [number] The path to the target node.
	    this.path = path;
	    // :: number The offset into the target node.
	    this.offset = offset;
	  }

	  // ;; Return a string representation of the path of the form
	  // `"0/2:10"`, where the numbers before the colon are the path, and
	  // the number after it is the offset.

	  _createClass(Pos, [{
	    key: "toString",
	    value: function toString() {
	      return this.path.join("/") + ":" + this.offset;
	    }

	    // :: number
	    // The length of the position's path.

	  }, {
	    key: "max",

	    // :: (Pos) → Pos
	    // Return the greater of two positions.
	    value: function max(other) {
	      return this.cmp(other) > 0 ? this : other;
	    }

	    // :: (Pos) → Pos
	    // Return the lesser of two positions.

	  }, {
	    key: "min",
	    value: function min(other) {
	      return this.cmp(other) < 0 ? this : other;
	    }

	    // :: ([number], [number]) → bool
	    // Compares two paths and returns true when they are the same.

	  }, {
	    key: "cmp",

	    // :: (Pos) → number
	    // Compares this position to another position, and returns a number.
	    // Of this result number, only the sign is significant. It is
	    // negative if this position is less than the other one, zero if
	    // they are the same, and positive if this position is greater.
	    value: function cmp(other) {
	      if (other == this) return 0;
	      return Pos.cmp(this.path, this.offset, other.path, other.offset);
	    }
	  }, {
	    key: "shorten",

	    // :: (?number, ?number) → Pos
	    // Create a position pointing into a parent of this position's
	    // target. When `to` is given, it determines the new length of the
	    // path. By default, the path becomes one shorter. The `offset`
	    // parameter can be used to determine where in this parent the
	    // position points. By default, it points before the old target. You
	    // can pass a negative or positive integer to move it backward or
	    // forward (**note**: this method performs no bounds checking).
	    value: function shorten() {
	      var to = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	      if (to >= this.depth) return this;
	      return Pos.shorten(this.path, to, offset);
	    }

	    // :: (number) → Pos
	    // Create a position with an offset moved relative to this
	    // position's offset. For example moving `0/1:10` by `-2` yields
	    // `0/1:8`.

	  }, {
	    key: "move",
	    value: function move(by) {
	      return new Pos(this.path, this.offset + by);
	    }

	    // :: (?number) → [number]
	    // Convert this position to an array of numbers (including its
	    // offset). Optionally pass an argument to adjust the value of the
	    // offset.

	  }, {
	    key: "toPath",
	    value: function toPath() {
	      var move = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

	      return this.path.concat(this.offset + move);
	    }
	  }, {
	    key: "extend",
	    value: function extend(pos) {
	      var path = this.path.slice(),
	          add = this.offset;
	      for (var i = 0; i < pos.path.length; i++) {
	        path.push(pos.path[i] + add);
	        add = 0;
	      }
	      return new Pos(path, pos.offset + add);
	    }

	    // :: (Node, ?bool) → bool
	    // Checks whether this position is valid in the given document. When
	    // `requireTextblock` is true, only positions inside textblocks are
	    // considered valid.

	  }, {
	    key: "isValid",
	    value: function isValid(doc, requireTextblock) {
	      for (var i = 0, node = doc;; i++) {
	        if (i == this.path.length) {
	          if (requireTextblock && !node.isTextblock) return false;
	          return this.offset <= node.size;
	        } else {
	          var n = this.path[i];
	          if (n >= node.size) return false;
	          node = node.child(n);
	        }
	      }
	    }

	    // :: () → Object
	    // Convert the position to a JSON-safe representation.

	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      return this;
	    }

	    // :: ([number], ?number) → Pos
	    // Build a position from an array of numbers (as in
	    // [`toPath`](#Pos.toPath)), taking the last element of the array as
	    // offset and optionally moving it by `move`.

	  }, {
	    key: "depth",
	    get: function get() {
	      return this.path.length;
	    }
	  }], [{
	    key: "cmp",
	    value: function cmp(pathA, offsetA, pathB, offsetB) {
	      var lenA = pathA.length,
	          lenB = pathB.length;
	      for (var i = 0, end = Math.min(lenA, lenB); i < end; i++) {
	        var diff = pathA[i] - pathB[i];
	        if (diff != 0) return diff;
	      }
	      if (lenA > lenB) return offsetB <= pathA[i] ? 1 : -1;else if (lenB > lenA) return offsetA <= pathB[i] ? -1 : 1;else return offsetA - offsetB;
	    }
	  }, {
	    key: "samePath",
	    value: function samePath(pathA, pathB) {
	      if (pathA.length != pathB.length) return false;
	      for (var i = 0; i < pathA.length; i++) {
	        if (pathA[i] !== pathB[i]) return false;
	      }return true;
	    }
	  }, {
	    key: "shorten",
	    value: function shorten(path) {
	      var to = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	      var offset = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	      if (to == null) to = path.length - 1;
	      return new Pos(path.slice(0, to), path[to] + offset);
	    }
	  }, {
	    key: "from",
	    value: function from(array) {
	      var move = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	      if (!array.length) _error.ModelError.raise("Can't create a pos from an empty array");
	      return new Pos(array.slice(0, array.length - 1), array[array.length - 1] + move);
	    }

	    // :: (Object) → Pos
	    // Create a position from a JSON representation.

	  }, {
	    key: "fromJSON",
	    value: function fromJSON(json) {
	      return new Pos(json.path, json.offset);
	    }
	  }]);

	  return Pos;
	}();

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Schema = exports.SchemaSpec = exports.MarkType = exports.Attribute = exports.Text = exports.Inline = exports.Textblock = exports.Block = exports.NodeType = exports.SchemaError = undefined;

	var _node = __webpack_require__(4);

	var _fragment = __webpack_require__(5);

	var _mark = __webpack_require__(8);

	var _obj = __webpack_require__(11);

	var _error = __webpack_require__(7);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// ;; The exception type used to signal schema-related
	// errors.

	var SchemaError = exports.SchemaError = function (_ProseMirrorError) {
	  _inherits(SchemaError, _ProseMirrorError);

	  function SchemaError() {
	    _classCallCheck(this, SchemaError);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(SchemaError).apply(this, arguments));
	  }

	  return SchemaError;
	}(_error.ProseMirrorError);

	// ;; The [node](#NodeType) and [mark](#MarkType) types
	// that make up a schema have several things in common—they support
	// attributes, and you can [register](#SchemaItem.register) values
	// with them. This class implements this functionality, and acts as a
	// superclass to those `NodeType` and `MarkType`.

	var SchemaItem = function () {
	  function SchemaItem() {
	    _classCallCheck(this, SchemaItem);
	  }

	  _createClass(SchemaItem, [{
	    key: "getDefaultAttrs",

	    // For node types where all attrs have a default value (or which don't
	    // have any attributes), build up a single reusable default attribute
	    // object, and use it for all nodes that don't specify specific
	    // attributes.
	    value: function getDefaultAttrs() {
	      var defaults = Object.create(null);
	      for (var attrName in this.attrs) {
	        var attr = this.attrs[attrName];
	        if (attr.default == null) return null;
	        defaults[attrName] = attr.default;
	      }
	      return defaults;
	    }
	  }, {
	    key: "computeAttrs",
	    value: function computeAttrs(attrs, arg) {
	      var built = Object.create(null);
	      for (var name in this.attrs) {
	        var value = attrs && attrs[name];
	        if (value == null) {
	          var attr = this.attrs[name];
	          if (attr.default != null) value = attr.default;else if (attr.compute) value = attr.compute(this, arg);else SchemaError.raise("No value supplied for attribute " + name);
	        }
	        built[name] = value;
	      }
	      return built;
	    }
	  }, {
	    key: "freezeAttrs",
	    value: function freezeAttrs() {
	      var frozen = Object.create(null);
	      for (var name in this.attrs) {
	        frozen[name] = this.attrs[name];
	      }Object.defineProperty(this, "attrs", { value: frozen });
	    }
	  }, {
	    key: "attrs",

	    // :: Object<Attribute>
	    // The set of attributes to associate with each node or mark of this
	    // type.
	    get: function get() {
	      return {};
	    }

	    // :: (Object<?Attribute>)
	    // Add or remove attributes from this type. Expects an object
	    // mapping names to either attributes (to add) or null (to remove
	    // the attribute by that name).

	  }], [{
	    key: "updateAttrs",
	    value: function updateAttrs(attrs) {
	      Object.defineProperty(this.prototype, "attrs", { value: overlayObj(this.prototype.attrs, attrs) });
	    }
	  }, {
	    key: "getRegistry",
	    value: function getRegistry() {
	      if (this == SchemaItem) return null;
	      if (!this.prototype.hasOwnProperty("registry")) this.prototype.registry = Object.create(Object.getPrototypeOf(this).getRegistry());
	      return this.prototype.registry;
	    }
	  }, {
	    key: "getNamespace",
	    value: function getNamespace(name) {
	      if (this == SchemaItem) return null;
	      var reg = this.getRegistry();
	      if (!Object.prototype.hasOwnProperty.call(reg, name)) reg[name] = Object.create(Object.getPrototypeOf(this).getNamespace(name));
	      return reg[name];
	    }

	    // :: (string, string, *)
	    // Register a value in this type's registry. Various components use
	    // `Schema.registry` to query values from the marks and nodes that
	    // make up the schema. The `namespace`, for example
	    // [`"command"`](#commands), determines which component will see
	    // this value. `name` is a name specific to this value. Its meaning
	    // differs per namespace.
	    //
	    // Subtypes inherit the registered values from their supertypes.
	    // They can override individual values by calling this method to
	    // overwrite them with a new value, or with `null` to disable them.

	  }, {
	    key: "register",
	    value: function register(namespace, name, value) {
	      this.getNamespace(namespace)[name] = function () {
	        return value;
	      };
	    }

	    // :: (string, string, (SchemaItem) → *)
	    // Register a value in this types's registry, like
	    // [`register`](#SchemaItem.register), but providing a function that
	    // will be called with the actual node or mark type, whose return
	    // value will be treated as the effective value (or will be ignored,
	    // if `null`).

	  }, {
	    key: "registerComputed",
	    value: function registerComputed(namespace, name, f) {
	      this.getNamespace(namespace)[name] = f;
	    }

	    // :: (string)
	    // By default, schema items inherit the
	    // [registered](#SchemaItem.register) items from their superclasses.
	    // Call this to disable that behavior for the given namespace.

	  }, {
	    key: "cleanNamespace",
	    value: function cleanNamespace(namespace) {
	      this.getNamespace(namespace).__proto__ = null;
	    }
	  }]);

	  return SchemaItem;
	}();

	// ;; Node types are objects allocated once per `Schema`
	// and used to tag `Node` instances with a type. They are
	// instances of sub-types of this class, and contain information about
	// the node type (its name, its allowed attributes, methods for
	// serializing it to various formats, information to guide
	// deserialization, and so on).

	var NodeType = exports.NodeType = function (_SchemaItem) {
	  _inherits(NodeType, _SchemaItem);

	  function NodeType(name, kind, schema) {
	    _classCallCheck(this, NodeType);

	    // :: string
	    // The name the node type has in this schema.

	    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(NodeType).call(this));

	    _this2.name = name;
	    _this2.kind = kind;
	    // Freeze the attributes, to avoid calling a potentially expensive
	    // getter all the time.
	    _this2.freezeAttrs();
	    _this2.defaultAttrs = _this2.getDefaultAttrs();
	    // :: Schema
	    // A link back to the `Schema` the node type belongs to.
	    _this2.schema = schema;
	    return _this2;
	  }

	  // :: bool
	  // True if this is a block type.

	  _createClass(NodeType, [{
	    key: "canContainFragment",

	    // :: (Fragment) → bool
	    // Test whether the content of the given fragment could be contained
	    // in this node type.
	    value: function canContainFragment(fragment) {
	      var _this3 = this;

	      var ok = true;
	      fragment.forEach(function (n) {
	        if (!_this3.canContain(n)) ok = false;
	      });
	      return ok;
	    }

	    // :: (Node) → bool
	    // Test whether the given node could be contained in this node type.

	  }, {
	    key: "canContain",
	    value: function canContain(node) {
	      if (!this.canContainType(node.type)) return false;
	      for (var i = 0; i < node.marks.length; i++) {
	        if (!this.canContainMark(node.marks[i])) return false;
	      }return true;
	    }

	    // :: (MarkType) → bool
	    // Test whether this node type can contain children with the given
	    // mark type.

	  }, {
	    key: "canContainMark",
	    value: function canContainMark(mark) {
	      var contains = this.containsMarks;
	      if (contains === true) return true;
	      if (contains) for (var i = 0; i < contains.length; i++) {
	        if (contains[i] == mark.name) return true;
	      }return false;
	    }

	    // :: (NodeType) → bool
	    // Test whether this node type can contain nodes of the given node
	    // type.

	  }, {
	    key: "canContainType",
	    value: function canContainType(type) {
	      return this.schema.subKind(type.kind, this.contains);
	    }

	    // :: (NodeType) → bool
	    // Test whether the nodes that can be contained in the given node
	    // type are a sub-type of the nodes that can be contained in this
	    // type.

	  }, {
	    key: "canContainContent",
	    value: function canContainContent(type) {
	      return this.schema.subKind(type.contains, this.contains);
	    }

	    // :: (NodeType) → ?[NodeType]
	    // Find a set of intermediate node types, possibly empty, that have
	    // to be inserted between this type and `other` to put a node of
	    // type `other` into this type.

	  }, {
	    key: "findConnection",
	    value: function findConnection(other) {
	      if (this.canContainType(other)) return [];

	      var seen = Object.create(null);
	      var active = [{ from: this, via: [] }];
	      while (active.length) {
	        var current = active.shift();
	        for (var name in this.schema.nodes) {
	          var type = this.schema.nodes[name];
	          if (type.defaultAttrs && !(type.contains in seen) && current.from.canContainType(type)) {
	            var via = current.via.concat(type);
	            if (type.canContainType(other)) return via;
	            active.push({ from: type, via: via });
	            seen[type.contains] = true;
	          }
	        }
	      }
	    }
	  }, {
	    key: "computeAttrs",
	    value: function computeAttrs(attrs, content) {
	      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _get(Object.getPrototypeOf(NodeType.prototype), "computeAttrs", this).call(this, attrs, content);
	    }

	    // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
	    // Create a `Node` of this type. The given attributes are
	    // checked and defaulted (you can pass `null` to use the type's
	    // defaults entirely, if no required attributes exist). `content`
	    // may be a `Fragment`, a node, an array of nodes, or
	    // `null`. Similarly `marks` may be `null` to default to the empty
	    // set of marks.

	  }, {
	    key: "create",
	    value: function create(attrs, content, marks) {
	      return new _node.Node(this, this.computeAttrs(attrs, content), _fragment.Fragment.from(content), _mark.Mark.setFrom(marks));
	    }
	  }, {
	    key: "createAutoFill",
	    value: function createAutoFill(attrs, content, marks) {
	      if ((!content || content.length == 0) && !this.canBeEmpty) content = this.defaultContent();
	      return this.create(attrs, content, marks);
	    }

	    // :: bool
	    // Controls whether this node is allowed to be empty.

	  }, {
	    key: "isBlock",
	    get: function get() {
	      return false;
	    }

	    // :: bool
	    // True if this is a textblock type, a block that contains inline
	    // content.

	  }, {
	    key: "isTextblock",
	    get: function get() {
	      return false;
	    }

	    // :: bool
	    // True if this is an inline type.

	  }, {
	    key: "isInline",
	    get: function get() {
	      return false;
	    }

	    // :: bool
	    // True if this is the text node type.

	  }, {
	    key: "isText",
	    get: function get() {
	      return false;
	    }

	    // :: bool
	    // Controls whether nodes of this type can be selected (as a user
	    // node selection).

	  }, {
	    key: "selectable",
	    get: function get() {
	      return true;
	    }

	    // :: bool
	    // Determines whether nodes of this type can be dragged. Enabling it
	    // causes ProseMirror to set a `draggable` attribute on its DOM
	    // representation, and to put its HTML serialization into the drag
	    // event's [data
	    // transfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer)
	    // when dragged.

	  }, {
	    key: "draggable",
	    get: function get() {
	      return false;
	    }

	    // :: bool
	    // Controls whether this node type is locked.

	  }, {
	    key: "locked",
	    get: function get() {
	      return false;
	    }

	    // :: ?string
	    // The kind of nodes this node may contain. `null` means it's a
	    // leaf node.

	  }, {
	    key: "contains",
	    get: function get() {
	      return null;
	    }

	    // :: string
	    // Controls the _kind_ of the node, which is used to determine valid
	    // parent/child [relations](#NodeType.contains). Should be a single
	    // name or space-separated string of kind names, where later names
	    // are considered to be sub-kinds of former ones (for example
	    // `"textblock paragraph"`). When you want to extend the superclass'
	    // set of kinds, you can do something like
	    //
	    //     static get kinds() { return super.kind + " mykind" }

	  }, {
	    key: "canBeEmpty",
	    get: function get() {
	      return true;
	    }
	  }, {
	    key: "containsMarks",

	    // :: union<bool, [string]>
	    // The mark types that child nodes of this node may have. `false`
	    // means no marks, `true` means any mark, and an array of strings
	    // can be used to explicitly list the allowed mark types.
	    get: function get() {
	      return false;
	    }
	  }], [{
	    key: "compile",
	    value: function compile(types, schema) {
	      var result = Object.create(null);
	      for (var name in types) {
	        var type = types[name];
	        var kinds = type.kinds.split(" ");
	        for (var i = 0; i < kinds.length; i++) {
	          schema.registerKind(kinds[i], i ? kinds[i - 1] : null);
	        }result[name] = new type(name, kinds[kinds.length - 1], schema);
	      }
	      for (var name in result) {
	        var contains = result[name].contains;
	        if (contains && !(contains in schema.kinds)) SchemaError.raise("Node type " + name + " is specified to contain non-existing kind " + contains);
	      }
	      if (!result.doc) SchemaError.raise("Every schema needs a 'doc' type");
	      if (!result.text) SchemaError.raise("Every schema needs a 'text' type");

	      return result;
	    }
	  }, {
	    key: "kinds",
	    get: function get() {
	      return "node";
	    }
	  }]);

	  return NodeType;
	}(SchemaItem);

	// ;; Base type for block nodetypes.

	var Block = exports.Block = function (_NodeType) {
	  _inherits(Block, _NodeType);

	  function Block() {
	    _classCallCheck(this, Block);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Block).apply(this, arguments));
	  }

	  _createClass(Block, [{
	    key: "defaultContent",
	    value: function defaultContent() {
	      var inner = this.schema.defaultTextblockType().create();
	      var conn = this.findConnection(inner.type);
	      if (!conn) SchemaError.raise("Can't create default content for " + this.name);
	      for (var i = conn.length - 1; i >= 0; i--) {
	        inner = conn[i].create(null, inner);
	      }return _fragment.Fragment.from(inner);
	    }
	  }, {
	    key: "contains",
	    get: function get() {
	      return "block";
	    }
	  }, {
	    key: "isBlock",
	    get: function get() {
	      return true;
	    }
	  }, {
	    key: "canBeEmpty",
	    get: function get() {
	      return this.contains == null;
	    }
	  }], [{
	    key: "kinds",
	    get: function get() {
	      return "block";
	    }
	  }]);

	  return Block;
	}(NodeType);

	// ;; Base type for textblock node types.

	var Textblock = exports.Textblock = function (_Block) {
	  _inherits(Textblock, _Block);

	  function Textblock() {
	    _classCallCheck(this, Textblock);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Textblock).apply(this, arguments));
	  }

	  _createClass(Textblock, [{
	    key: "contains",
	    get: function get() {
	      return "inline";
	    }
	  }, {
	    key: "containsMarks",
	    get: function get() {
	      return true;
	    }
	  }, {
	    key: "isTextblock",
	    get: function get() {
	      return true;
	    }
	  }, {
	    key: "canBeEmpty",
	    get: function get() {
	      return true;
	    }
	  }]);

	  return Textblock;
	}(Block);

	// ;; Base type for inline node types.

	var Inline = exports.Inline = function (_NodeType2) {
	  _inherits(Inline, _NodeType2);

	  function Inline() {
	    _classCallCheck(this, Inline);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Inline).apply(this, arguments));
	  }

	  _createClass(Inline, [{
	    key: "isInline",
	    get: function get() {
	      return true;
	    }
	  }], [{
	    key: "kinds",
	    get: function get() {
	      return "inline";
	    }
	  }]);

	  return Inline;
	}(NodeType);

	// ;; The text node type.

	var Text = exports.Text = function (_Inline) {
	  _inherits(Text, _Inline);

	  function Text() {
	    _classCallCheck(this, Text);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Text).apply(this, arguments));
	  }

	  _createClass(Text, [{
	    key: "create",
	    value: function create(attrs, content, marks) {
	      return new _node.TextNode(this, this.computeAttrs(attrs, content), content, marks);
	    }
	  }, {
	    key: "selectable",
	    get: function get() {
	      return false;
	    }
	  }, {
	    key: "isText",
	    get: function get() {
	      return true;
	    }
	  }], [{
	    key: "kinds",
	    get: function get() {
	      return _get(Object.getPrototypeOf(Text), "kinds", this) + " text";
	    }
	  }]);

	  return Text;
	}(Inline);

	// Attribute descriptors

	// ;; Attributes are named strings associated with nodes and marks.
	// Each node type or mark type has a fixed set of attributes, which
	// instances of this class are used to control.

	var Attribute =
	// :: (Object)
	// Create an attribute. `options` is an object containing the
	// settings for the attributes. The following settings are
	// supported:
	//
	// **`default`**`: ?string`
	//   : The default value for this attribute, to choose when no
	//     explicit value is provided.
	//
	// **`compute`**`: ?(Fragment) → string`
	//   : A function that computes a default value for the attribute from
	//     the node's content.
	//
	// **`label`**`: ?string`
	//   : A user-readable text label associated with the attribute.
	//
	// Attributes that have no default or compute property must be
	// provided whenever a node or mark of a type that has them is
	// created.
	exports.Attribute = function Attribute() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	  _classCallCheck(this, Attribute);

	  this.default = options.default;
	  this.compute = options.compute;
	  this.label = options.label;
	};

	// Marks

	// ;; Like nodes, marks (which are associated with nodes to signify
	// things like emphasis or being part of a link) are tagged with type
	// objects, which are instantiated once per `Schema`.

	var MarkType = exports.MarkType = function (_SchemaItem2) {
	  _inherits(MarkType, _SchemaItem2);

	  function MarkType(name, rank, schema) {
	    _classCallCheck(this, MarkType);

	    // :: string
	    // The name of the mark type.

	    var _this8 = _possibleConstructorReturn(this, Object.getPrototypeOf(MarkType).call(this));

	    _this8.name = name;
	    _this8.freezeAttrs();
	    _this8.rank = rank;
	    // :: Schema
	    // The schema that this mark type instance is part of.
	    _this8.schema = schema;
	    var defaults = _this8.getDefaultAttrs();
	    _this8.instance = defaults && new _mark.Mark(_this8, defaults);
	    return _this8;
	  }

	  // :: number
	  // Mark type ranks are used to determine the order in which mark
	  // arrays are sorted. (If multiple mark types end up with the same
	  // rank, they still get a fixed order in the schema, but there's no
	  // guarantee what it will be.)

	  _createClass(MarkType, [{
	    key: "create",

	    // :: (Object) → Mark
	    // Create a mark of this type. `attrs` may be `null` or an object
	    // containing only some of the mark's attributes. The others, if
	    // they have defaults, will be added.
	    value: function create(attrs) {
	      if (!attrs && this.instance) return this.instance;
	      return new _mark.Mark(this, this.computeAttrs(attrs));
	    }
	  }, {
	    key: "removeFromSet",

	    // :: ([Mark]) → [Mark]
	    // When there is a mark of this type in the given set, a new set
	    // without it is returned. Otherwise, the input set is returned.
	    value: function removeFromSet(set) {
	      for (var i = 0; i < set.length; i++) {
	        if (set[i].type == this) return set.slice(0, i).concat(set.slice(i + 1));
	      }return set;
	    }

	    // :: ([Mark]) → ?Mark
	    // Tests whether there is a mark of this type in the given set.

	  }, {
	    key: "isInSet",
	    value: function isInSet(set) {
	      for (var i = 0; i < set.length; i++) {
	        if (set[i].type == this) return set[i];
	      }
	    }
	  }], [{
	    key: "getOrder",
	    value: function getOrder(marks) {
	      var sorted = [];
	      for (var name in marks) {
	        sorted.push({ name: name, rank: marks[name].rank });
	      }sorted.sort(function (a, b) {
	        return a.rank - b.rank;
	      });
	      var ranks = Object.create(null);
	      for (var i = 0; i < sorted.length; i++) {
	        ranks[sorted[i].name] = i;
	      }return ranks;
	    }
	  }, {
	    key: "compile",
	    value: function compile(marks, schema) {
	      var order = this.getOrder(marks);
	      var result = Object.create(null);
	      for (var name in marks) {
	        result[name] = new marks[name](name, order[name], schema);
	      }return result;
	    }
	  }, {
	    key: "rank",
	    get: function get() {
	      return 50;
	    }
	  }]);

	  return MarkType;
	}(SchemaItem);

	// Schema specifications are data structures that specify a schema --
	// a set of node types, their names, attributes, and nesting behavior.

	// ;; A schema specification is a blueprint for an actual
	// `Schema`. It maps names to node and mark types, along
	// with extra information, such as additional attributes and changes
	// to node kinds and relations.
	//
	// A specification consists of an object that associates node names
	// with node type constructors and another similar object associating
	// mark names with mark type constructors.

	var SchemaSpec = exports.SchemaSpec = function () {
	  // :: (?Object<NodeType>, ?Object<MarkType>)
	  // Create a schema specification from scratch. The arguments map
	  // node names to node type constructors and mark names to mark type
	  // constructors.

	  function SchemaSpec(nodes, marks) {
	    _classCallCheck(this, SchemaSpec);

	    this.nodes = nodes || {};
	    this.marks = marks || {};
	  }

	  // :: (?Object<?NodeType>, ?Object<?MarkType>) → SchemaSpec
	  // Base a new schema spec on this one by specifying nodes and marks
	  // to add or remove.
	  //
	  // When `nodes` is passed, it should be an object mapping type names
	  // to either `null`, to delete the type of that name, or to a
	  // `NodeType` subclass, to add or replace the node type of that
	  // name.
	  //
	  // Similarly, `marks` can be an object to add, change, or remove
	  // [mark types](#MarkType) in the schema.

	  _createClass(SchemaSpec, [{
	    key: "update",
	    value: function update(nodes, marks) {
	      return new SchemaSpec(nodes ? overlayObj(this.nodes, nodes) : this.nodes, marks ? overlayObj(this.marks, marks) : this.marks);
	    }
	  }]);

	  return SchemaSpec;
	}();

	function overlayObj(base, update) {
	  var copy = (0, _obj.copyObj)(base);
	  for (var name in update) {
	    var value = update[name];
	    if (value == null) delete copy[name];else copy[name] = value;
	  }
	  return copy;
	}

	// ;; Each document is based on a single schema, which provides the
	// node and mark types that it is made up of (which, in turn,
	// determine the structure it is allowed to have).

	var Schema = function () {
	  // :: (SchemaSpec)
	  // Construct a schema from a specification.

	  function Schema(spec) {
	    _classCallCheck(this, Schema);

	    // :: SchemaSpec
	    // The specification on which the schema is based.
	    this.spec = spec;
	    this.kinds = Object.create(null);

	    // :: Object<NodeType>
	    // An object mapping the schema's node names to node type objects.
	    this.nodes = NodeType.compile(spec.nodes, this);
	    // :: Object<MarkType>
	    // A map from mark names to mark type objects.
	    this.marks = MarkType.compile(spec.marks, this);
	    for (var prop in this.nodes) {
	      if (prop in this.marks) SchemaError.raise(prop + " can not be both a node and a mark");
	    } // :: Object
	    // An object for storing whatever values modules may want to
	    // compute and cache per schema. (If you want to store something
	    // in it, try to use property names unlikely to clash.)
	    this.cached = Object.create(null);

	    this.node = this.node.bind(this);
	    this.text = this.text.bind(this);
	    this.nodeFromJSON = this.nodeFromJSON.bind(this);
	    this.markFromJSON = this.markFromJSON.bind(this);
	  }

	  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
	  // Create a node in this schema. The `type` may be a string or a
	  // `NodeType` instance. Attributes will be extended
	  // with defaults, `content` may be a `Fragment`,
	  // `null`, a `Node`, or an array of nodes.
	  //
	  // When creating a text node, `content` should be a string and is
	  // interpreted as the node's text.
	  //
	  // This method is bound to the Schema, meaning you don't have to
	  // call it as a method, but can pass it to higher-order functions
	  // and such.

	  _createClass(Schema, [{
	    key: "node",
	    value: function node(type, attrs, content, marks) {
	      if (typeof type == "string") type = this.nodeType(type);else if (!(type instanceof NodeType)) SchemaError.raise("Invalid node type: " + type);else if (type.schema != this) SchemaError.raise("Node type from different schema used (" + type.name + ")");

	      return type.create(attrs, content, marks);
	    }

	    // :: (string, ?[Mark]) → Node
	    // Create a text node in the schema. This method is bound to the Schema.

	  }, {
	    key: "text",
	    value: function text(_text, marks) {
	      return this.nodes.text.create(null, _text, _mark.Mark.setFrom(marks));
	    }

	    // :: () → ?NodeType
	    // Return the default textblock type for this schema, or `null` if
	    // it does not contain a node type with a `defaultTextblock`
	    // property.

	  }, {
	    key: "defaultTextblockType",
	    value: function defaultTextblockType() {
	      var cached = this.cached.defaultTextblockType;
	      if (cached !== undefined) return cached;
	      for (var name in this.nodes) {
	        if (this.nodes[name].defaultTextblock) return this.cached.defaultTextblockType = this.nodes[name];
	      }
	      return this.cached.defaultTextblockType = null;
	    }

	    // :: (string, ?Object) → Mark
	    // Create a mark with the named type

	  }, {
	    key: "mark",
	    value: function mark(name, attrs) {
	      var spec = this.marks[name] || SchemaError.raise("No mark named " + name);
	      return spec.create(attrs);
	    }

	    // :: (Object) → Node
	    // Deserialize a node from its JSON representation. This method is
	    // bound.

	  }, {
	    key: "nodeFromJSON",
	    value: function nodeFromJSON(json) {
	      return _node.Node.fromJSON(this, json);
	    }

	    // :: (Object) → Mark
	    // Deserialize a mark from its JSON representation. This method is
	    // bound.

	  }, {
	    key: "markFromJSON",
	    value: function markFromJSON(json) {
	      var type = this.marks[json._];
	      var attrs = null;
	      for (var prop in json) {
	        if (prop != "_") {
	          if (!attrs) attrs = Object.create(null);
	          attrs[prop] = json[prop];
	        }
	      }return attrs ? type.create(attrs) : type.instance;
	    }

	    // :: (string) → NodeType
	    // Get the `NodeType` associated with the given name in
	    // this schema, or raise an error if it does not exist.

	  }, {
	    key: "nodeType",
	    value: function nodeType(name) {
	      return this.nodes[name] || SchemaError.raise("Unknown node type: " + name);
	    }
	  }, {
	    key: "registerKind",
	    value: function registerKind(kind, sup) {
	      if (kind in this.kinds) {
	        if (this.kinds[kind] == sup) return;
	        SchemaError.raise("Inconsistent superkinds for kind " + kind + ": " + sup + " and " + this.kinds[kind]);
	      }
	      if (this.subKind(kind, sup)) SchemaError.raise("Conflicting kind hierarchy through " + kind + " and " + sup);
	      this.kinds[kind] = sup;
	    }

	    // :: (string, string) → bool
	    // Test whether a node kind is a sub-kind of another kind.

	  }, {
	    key: "subKind",
	    value: function subKind(sub, sup) {
	      for (;;) {
	        if (sub == sup) return true;
	        sub = this.kinds[sub];
	        if (!sub) return false;
	      }
	    }

	    // :: (string, (name: string, value: *, source: union<NodeType, MarkType>, name: string))
	    // Retrieve all registered items under the given name from this
	    // schema. The given function will be called with the name, each item, the
	    // element—node type or mark type—that it was associated with, and
	    // that element's name in the schema.

	  }, {
	    key: "registry",
	    value: function registry(namespace, f) {
	      for (var i = 0; i < 2; i++) {
	        var obj = i ? this.marks : this.nodes;
	        for (var tname in obj) {
	          var type = obj[tname],
	              registry = type.registry,
	              ns = registry && registry[namespace];
	          if (ns) for (var prop in ns) {
	            var value = ns[prop](type);
	            if (value != null) f(prop, value, type, tname);
	          }
	        }
	      }
	    }
	  }]);

	  return Schema;
	}();

	exports.Schema = Schema;

/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.copyObj = copyObj;
	function copyObj(obj, base) {
	  var copy = base || Object.create(null);
	  for (var prop in obj) {
	    copy[prop] = obj[prop];
	  }return copy;
	}

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.defaultSchema = exports.CodeMark = exports.LinkMark = exports.StrongMark = exports.EmMark = exports.HardBreak = exports.Image = exports.Paragraph = exports.CodeBlock = exports.Heading = exports.HorizontalRule = exports.ListItem = exports.BulletList = exports.OrderedList = exports.BlockQuote = exports.Doc = undefined;

	var _schema = __webpack_require__(10);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// ;; The default top-level document node type.

	var Doc = exports.Doc = function (_Block) {
	  _inherits(Doc, _Block);

	  function Doc() {
	    _classCallCheck(this, Doc);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Doc).apply(this, arguments));
	  }

	  _createClass(Doc, null, [{
	    key: "kinds",
	    get: function get() {
	      return "doc";
	    }
	  }]);

	  return Doc;
	}(_schema.Block);

	// ;; The default blockquote node type.

	var BlockQuote = exports.BlockQuote = function (_Block2) {
	  _inherits(BlockQuote, _Block2);

	  function BlockQuote() {
	    _classCallCheck(this, BlockQuote);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(BlockQuote).apply(this, arguments));
	  }

	  return BlockQuote;
	}(_schema.Block);

	// ;; The default ordered list node type. Has a single attribute,
	// `order`, which determines the number at which the list starts
	// counting, and defaults to 1.

	var OrderedList = exports.OrderedList = function (_Block3) {
	  _inherits(OrderedList, _Block3);

	  function OrderedList() {
	    _classCallCheck(this, OrderedList);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(OrderedList).apply(this, arguments));
	  }

	  _createClass(OrderedList, [{
	    key: "contains",
	    get: function get() {
	      return "list_item";
	    }
	  }, {
	    key: "attrs",
	    get: function get() {
	      return { order: new _schema.Attribute({ default: "1" }) };
	    }
	  }]);

	  return OrderedList;
	}(_schema.Block);

	// ;; The default bullet list node type.

	var BulletList = exports.BulletList = function (_Block4) {
	  _inherits(BulletList, _Block4);

	  function BulletList() {
	    _classCallCheck(this, BulletList);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(BulletList).apply(this, arguments));
	  }

	  _createClass(BulletList, [{
	    key: "contains",
	    get: function get() {
	      return "list_item";
	    }
	  }]);

	  return BulletList;
	}(_schema.Block);

	// ;; The default list item node type.

	var ListItem = exports.ListItem = function (_Block5) {
	  _inherits(ListItem, _Block5);

	  function ListItem() {
	    _classCallCheck(this, ListItem);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ListItem).apply(this, arguments));
	  }

	  _createClass(ListItem, null, [{
	    key: "kinds",
	    get: function get() {
	      return "list_item";
	    }
	  }]);

	  return ListItem;
	}(_schema.Block);

	// ;; The default horizontal rule node type.

	var HorizontalRule = exports.HorizontalRule = function (_Block6) {
	  _inherits(HorizontalRule, _Block6);

	  function HorizontalRule() {
	    _classCallCheck(this, HorizontalRule);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(HorizontalRule).apply(this, arguments));
	  }

	  _createClass(HorizontalRule, [{
	    key: "contains",
	    get: function get() {
	      return null;
	    }
	  }]);

	  return HorizontalRule;
	}(_schema.Block);

	// ;; The default heading node type. Has a single attribute
	// `level`, which indicates the heading level, and defaults to 1.

	var Heading = exports.Heading = function (_Textblock) {
	  _inherits(Heading, _Textblock);

	  function Heading() {
	    _classCallCheck(this, Heading);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Heading).apply(this, arguments));
	  }

	  _createClass(Heading, [{
	    key: "attrs",
	    get: function get() {
	      return { level: new _schema.Attribute({ default: "1" }) };
	    }
	    // :: number
	    // Controls the maximum heading level. Has the value 6 in the
	    // `Heading` class, but you can override it in a subclass.

	  }, {
	    key: "maxLevel",
	    get: function get() {
	      return 6;
	    }
	  }]);

	  return Heading;
	}(_schema.Textblock);

	// ;; The default code block / listing node type. Only
	// allows unmarked text nodes inside of it.

	var CodeBlock = exports.CodeBlock = function (_Textblock2) {
	  _inherits(CodeBlock, _Textblock2);

	  function CodeBlock() {
	    _classCallCheck(this, CodeBlock);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(CodeBlock).apply(this, arguments));
	  }

	  _createClass(CodeBlock, [{
	    key: "contains",
	    get: function get() {
	      return "text";
	    }
	  }, {
	    key: "containsMarks",
	    get: function get() {
	      return false;
	    }
	  }, {
	    key: "isCode",
	    get: function get() {
	      return true;
	    }
	  }]);

	  return CodeBlock;
	}(_schema.Textblock);

	// ;; The default paragraph node type.

	var Paragraph = exports.Paragraph = function (_Textblock3) {
	  _inherits(Paragraph, _Textblock3);

	  function Paragraph() {
	    _classCallCheck(this, Paragraph);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Paragraph).apply(this, arguments));
	  }

	  _createClass(Paragraph, [{
	    key: "defaultTextblock",
	    get: function get() {
	      return true;
	    }
	  }]);

	  return Paragraph;
	}(_schema.Textblock);

	// ;; The default inline image node type. Has these
	// attributes:
	//
	// - **`src`** (required): The URL of the image.
	// - **`alt`**: The alt text.
	// - **`title`**: The title of the image.

	var Image = exports.Image = function (_Inline) {
	  _inherits(Image, _Inline);

	  function Image() {
	    _classCallCheck(this, Image);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Image).apply(this, arguments));
	  }

	  _createClass(Image, [{
	    key: "attrs",
	    get: function get() {
	      return {
	        src: new _schema.Attribute(),
	        alt: new _schema.Attribute({ default: "" }),
	        title: new _schema.Attribute({ default: "" })
	      };
	    }
	  }, {
	    key: "draggable",
	    get: function get() {
	      return true;
	    }
	  }]);

	  return Image;
	}(_schema.Inline);

	// ;; The default hard break node type.

	var HardBreak = exports.HardBreak = function (_Inline2) {
	  _inherits(HardBreak, _Inline2);

	  function HardBreak() {
	    _classCallCheck(this, HardBreak);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(HardBreak).apply(this, arguments));
	  }

	  _createClass(HardBreak, [{
	    key: "selectable",
	    get: function get() {
	      return false;
	    }
	  }, {
	    key: "isBR",
	    get: function get() {
	      return true;
	    }
	  }]);

	  return HardBreak;
	}(_schema.Inline);

	// ;; The default emphasis mark type.

	var EmMark = exports.EmMark = function (_MarkType) {
	  _inherits(EmMark, _MarkType);

	  function EmMark() {
	    _classCallCheck(this, EmMark);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(EmMark).apply(this, arguments));
	  }

	  _createClass(EmMark, null, [{
	    key: "rank",
	    get: function get() {
	      return 51;
	    }
	  }]);

	  return EmMark;
	}(_schema.MarkType);

	// ;; The default strong mark type.

	var StrongMark = exports.StrongMark = function (_MarkType2) {
	  _inherits(StrongMark, _MarkType2);

	  function StrongMark() {
	    _classCallCheck(this, StrongMark);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(StrongMark).apply(this, arguments));
	  }

	  _createClass(StrongMark, null, [{
	    key: "rank",
	    get: function get() {
	      return 52;
	    }
	  }]);

	  return StrongMark;
	}(_schema.MarkType);

	// ;; The default link mark type. Has these attributes:
	//
	// - **`href`** (required): The link target.
	// - **`title`**: The link's title.

	var LinkMark = exports.LinkMark = function (_MarkType3) {
	  _inherits(LinkMark, _MarkType3);

	  function LinkMark() {
	    _classCallCheck(this, LinkMark);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(LinkMark).apply(this, arguments));
	  }

	  _createClass(LinkMark, [{
	    key: "attrs",
	    get: function get() {
	      return {
	        href: new _schema.Attribute(),
	        title: new _schema.Attribute({ default: "" })
	      };
	    }
	  }], [{
	    key: "rank",
	    get: function get() {
	      return 25;
	    }
	  }]);

	  return LinkMark;
	}(_schema.MarkType);

	// ;; The default code font mark type.

	var CodeMark = exports.CodeMark = function (_MarkType4) {
	  _inherits(CodeMark, _MarkType4);

	  function CodeMark() {
	    _classCallCheck(this, CodeMark);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(CodeMark).apply(this, arguments));
	  }

	  _createClass(CodeMark, [{
	    key: "isCode",
	    get: function get() {
	      return true;
	    }
	  }], [{
	    key: "rank",
	    get: function get() {
	      return 101;
	    }
	  }]);

	  return CodeMark;
	}(_schema.MarkType);

	// :: SchemaSpec
	// The specification for the default schema.

	var defaultSpec = new _schema.SchemaSpec({
	  doc: Doc,
	  blockquote: BlockQuote,
	  ordered_list: OrderedList,
	  bullet_list: BulletList,
	  list_item: ListItem,
	  horizontal_rule: HorizontalRule,

	  paragraph: Paragraph,
	  heading: Heading,
	  code_block: CodeBlock,

	  text: _schema.Text,
	  image: Image,
	  hard_break: HardBreak
	}, {
	  em: EmMark,
	  strong: StrongMark,
	  link: LinkMark,
	  code: CodeMark
	});

	// :: Schema
	// ProseMirror's default document schema.
	var defaultSchema = exports.defaultSchema = new _schema.Schema(defaultSpec);

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.findDiffStart = findDiffStart;
	exports.findDiffEnd = findDiffEnd;

	var _pos = __webpack_require__(9);

	// :: (Node, Node) → ?Pos
	// Find the first position at which nodes `a` and `b` differ, or
	// `null` if they are the same.
	function findDiffStart(a, b) {
	  var path = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

	  var iA = a.iter(),
	      iB = b.iter(),
	      offset = 0;
	  for (;;) {
	    if (iA.atEnd() || iB.atEnd()) {
	      if (a.size == b.size) return null;
	      break;
	    }

	    var childA = iA.next(),
	        childB = iB.next();
	    if (childA == childB) {
	      offset += childA.width;continue;
	    }

	    if (!childA.sameMarkup(childB)) break;

	    if (childA.isText && childA.text != childB.text) {
	      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
	        offset++;
	      }break;
	    }

	    if (childA.size || childB.size) {
	      path.push(offset);
	      var inner = findDiffStart(childA.content, childB.content, path);
	      if (inner) return inner;
	      path.pop();
	    }
	    offset += childA.width;
	  }
	  return new _pos.Pos(path, offset);
	}

	// :: (Node, Node) → ?{a: Pos, b: Pos}
	// Find the first position, searching from the end, at which nodes `a`
	// and `b` differ, or `null` if they are the same. Since this position
	// will not be the same in both nodes, an object with two separate
	// positions is returned.
	function findDiffEnd(a, b) {
	  var pathA = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
	  var pathB = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];

	  var iA = a.reverseIter(),
	      iB = b.reverseIter();
	  var offA = a.size,
	      offB = b.size;

	  for (;;) {
	    if (iA.atEnd() || iB.atEnd()) {
	      if (a.size == b.size) return null;
	      break;
	    }
	    var childA = iA.next(),
	        childB = iB.next();
	    if (childA == childB) {
	      offA -= childA.width;offB -= childB.width;
	      continue;
	    }

	    if (!childA.sameMarkup(childB)) break;

	    if (childA.isText && childA.text != childB.text) {
	      var same = 0,
	          minSize = Math.min(childA.text.length, childB.text.length);
	      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
	        same++;offA--;offB--;
	      }
	      break;
	    }
	    offA -= childA.width;offB -= childB.width;
	    if (childA.size || childB.size) {
	      pathA.push(offA);pathB.push(offB);
	      var inner = findDiffEnd(childA.content, childB.content, pathA, pathB);
	      if (inner) return inner;
	      pathA.pop();pathB.pop();
	    }
	  }
	  return { a: new _pos.Pos(pathA, offA), b: new _pos.Pos(pathB, offB) };
	}

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.elt = elt;
	exports.requestAnimationFrame = requestAnimationFrame;
	exports.rmClass = rmClass;
	exports.addClass = addClass;
	exports.contains = contains;
	exports.insertCSS = insertCSS;
	exports.ensureCSSAdded = ensureCSSAdded;
	function elt(tag, attrs) {
	  var result = document.createElement(tag);
	  if (attrs) for (var name in attrs) {
	    if (name == "style") result.style.cssText = attrs[name];else if (attrs[name] != null) result.setAttribute(name, attrs[name]);
	  }

	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }

	  for (var i = 0; i < args.length; i++) {
	    add(args[i], result);
	  }return result;
	}

	function add(value, target) {
	  if (typeof value == "string") value = document.createTextNode(value);

	  if (Array.isArray(value)) {
	    for (var i = 0; i < value.length; i++) {
	      add(value[i], target);
	    }
	  } else {
	    target.appendChild(value);
	  }
	}

	var reqFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

	function requestAnimationFrame(f) {
	  if (reqFrame) reqFrame(f);else setTimeout(f, 10);
	}

	var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
	var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

	var browser = exports.browser = {
	  mac: /Mac/.test(navigator.platform),
	  ie_upto10: ie_upto10,
	  ie_11up: ie_11up,
	  ie: ie_upto10 || ie_11up,
	  gecko: /gecko\/\d/i.test(navigator.userAgent)
	};

	function classTest(cls) {
	  return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
	}

	function rmClass(node, cls) {
	  var current = node.className;
	  var match = classTest(cls).exec(current);
	  if (match) {
	    var after = current.slice(match.index + match[0].length);
	    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	  }
	}

	function addClass(node, cls) {
	  var current = node.className;
	  if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
	}

	function contains(parent, child) {
	  // Android browser and IE will return false if child is a text node.
	  if (child.nodeType != 1) child = child.parentNode;
	  return child && parent.contains(child);
	}

	var accumulatedCSS = "",
	    cssNode = null;

	function insertCSS(css) {
	  if (cssNode) cssNode.textContent += css;else accumulatedCSS += css;
	}

	// This is called when a ProseMirror instance is created, to ensure
	// the CSS is in the DOM.
	function ensureCSSAdded() {
	  if (!cssNode) {
	    cssNode = document.createElement("style");
	    cssNode.textContent = "/* ProseMirror CSS */\n" + accumulatedCSS;
	    document.head.insertBefore(cssNode, document.head.firstChild);
	  }
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.selectedNodeAttr = exports.defParamsClick = exports.nameTitle = exports.namePattern = exports.defineFileHandler = exports.widgetParamHandler = undefined;

	var _params = __webpack_require__(16);

	Object.defineProperty(exports, "widgetParamHandler", {
		enumerable: true,
		get: function get() {
			return _params.widgetParamHandler;
		}
	});
	Object.defineProperty(exports, "defineFileHandler", {
		enumerable: true,
		get: function get() {
			return _params.defineFileHandler;
		}
	});
	Object.defineProperty(exports, "namePattern", {
		enumerable: true,
		get: function get() {
			return _params.namePattern;
		}
	});
	Object.defineProperty(exports, "nameTitle", {
		enumerable: true,
		get: function get() {
			return _params.nameTitle;
		}
	});
	Object.defineProperty(exports, "defParamsClick", {
		enumerable: true,
		get: function get() {
			return _params.defParamsClick;
		}
	});
	Object.defineProperty(exports, "selectedNodeAttr", {
		enumerable: true,
		get: function get() {
			return _params.selectedNodeAttr;
		}
	});
	exports.defParser = defParser;
	exports.getPosInParent = getPosInParent;

	var _model = __webpack_require__(3);

	var _selection = __webpack_require__(45);

	if (window.MathJax) MathJax.Hub.Queue(function () {
		MathJax.Hub.Config({
			tex2jax: {
				displayMath: [["\\[", "\\]"]],
				inlineMath: [["\\(", "\\)"]],
				processEscapes: true
			},
			displayAlign: "left"
		});
	});

	function defParser(type, tag, cls) {
		type.register("parseDOM", {
			tag: tag,
			rank: 25,
			parse: function parse(dom, context, type, attrs) {
				var contains = dom.classList.contains(cls);
				if (!contains) return false;
				context.insertFrom(dom, type, attrs);
			}
		});
	}

	function getPosInParent(pm, pos, child) {
		var i = 0,
		    parent = pm.doc.path(pos.path);
		parent.forEach(function (node, start) {
			i = node == child ? start : 0;
		});
		return new _model.Pos(pos.path, i);
	}

	/*import {InputRule} from "prosemirror/dist/inputrules"
	let urlex = /((https?:\/\/)?[\w-]+(\.[\w-]+)+\.?(:\d+)?(\/\S*)?)/
	LinkMark.register("autoInput","startLink", new InputRule(urlex," ",
		function(pm, match, pos) {
			let url = match[0]
			console.log(url)
			pm.setMark(this,pos,{href: url, title: ""})
		}
	))*/

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.nameTitle = exports.namePattern = undefined;
	exports.defineFileHandler = defineFileHandler;
	exports.getLastClicked = getLastClicked;
	exports.defParamsClick = defParamsClick;
	exports.selectedNodeAttr = selectedNodeAttr;

	var _dom = __webpack_require__(14);

	var _prompt = __webpack_require__(17);

	var _edit = __webpack_require__(18);

	var _dompos = __webpack_require__(46);

	var _error = __webpack_require__(7);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var fhandler = null,
	    lastClicked = null;

	var namePattern = exports.namePattern = "[A-Za-z0-9_-]{1,10}";
	var nameTitle = exports.nameTitle = "letters,digits, -, _ (max:10)";

	function defineFileHandler(handler) {
		fhandler = handler;
	}
	function getLastClicked() {
		return lastClicked;
	}

	var WidgetParamPrompt = function (_ParamPrompt) {
		_inherits(WidgetParamPrompt, _ParamPrompt);

		function WidgetParamPrompt() {
			_classCallCheck(this, WidgetParamPrompt);

			return _possibleConstructorReturn(this, _ParamPrompt.apply(this, arguments));
		}

		WidgetParamPrompt.prototype.prompt = function prompt() {
			var _this2 = this;

			return openWidgetPrompt(this, { onClose: function onClose() {
					return _this2.close();
				} });
		};

		return WidgetParamPrompt;
	}(_prompt.ParamPrompt);

	(0, _edit.defineOption)("commandParamPrompt", WidgetParamPrompt);

	function openWidgetPrompt(wpp, options) {
		var close = function close() {
			wpp.pm.off("interaction", close);
			if (dialog.parentNode) {
				dialog.parentNode.removeChild(dialog);
				if (options && options.onClose) options.onClose();
			}
		};
		var submit = function submit() {
			var params = wpp.values();
			if (params) {
				wpp.command.exec(wpp.pm, params);
				close();
			}
		};
		wpp.pm.on("interaction", close);
		var save = (0, _dom.elt)("input", { name: "save", type: "button", value: "Save" });
		save.addEventListener("mousedown", function (e) {
			submit();
		});
		var cancel = (0, _dom.elt)("input", { name: "cancel", type: "button", value: "Cancel" });
		cancel.addEventListener("mousedown", function (e) {
			e.preventDefault();e.stopPropagation();
			close();
		});
		var buttons = (0, _dom.elt)("div", { class: "widgetButtons" }, save, cancel);
		wpp.form = (0, _dom.elt)("form", { class: "widgetForm" }, (0, _dom.elt)("h4", null, wpp.command.label + " Settings"), wpp.fields.map(function (f) {
			return (0, _dom.elt)("div", null, f);
		}), buttons);
		// Submit if Enter pressed and all fields are valid
		wpp.form.addEventListener("keypress", function (e) {
			if (e.keyCode == 13) {
				e.preventDefault();e.stopPropagation();
				save.click();
			}
		});

		var dialog = (0, _dom.elt)("div", null, (0, _dom.elt)("div", { class: "widgetDialog" }), wpp.form);
		wpp.pm.wrapper.appendChild(dialog);
		return { close: close };
	}

	["text", "number", "range", "email", "url", "date"].map(function (type) {
		return _prompt.ParamPrompt.prototype.paramTypes[type] = {
			render: function render(param, value) {
				var field = (0, _dom.elt)("input", { type: type, placeholder: param.label, value: value, required: "required", autocomplete: "off" });
				var label = param.name ? param.name : param.label;
				field.setAttribute("name", label);
				var opt = param.options;
				if (opt) for (var prop in opt) {
					field.setAttribute(prop, opt[prop]);
				}var fieldLabel = (0, _dom.elt)("label", { for: label }, label);
				return (0, _dom.elt)("div", { class: "widgetField" }, fieldLabel, field);
			},
			validate: function validate(dom) {
				var input = dom.querySelector("input");
				return input.checkValidity() ? null : input.name + ": " + input.validationMessage;
			},
			read: function read(dom) {
				var input = dom.querySelector("input");
				return input ? input.value : input;
			}
		};
	});

	_prompt.ParamPrompt.prototype.paramTypes.file = {
		render: function render(param, value) {
			var field = (0, _dom.elt)("input", { type: "text", readonly: true, placeholder: param.label, value: value, required: "required", autocomplete: "off", required: true });
			var label = param.name ? param.name : param.label;
			field.setAttribute("name", label);
			var opt = param.options;
			if (opt) for (var prop in opt) {
				field.setAttribute(prop, opt[prop]);
			}var fieldLabel = (0, _dom.elt)("label", { for: label }, label);
			var uploadButton = (0, _dom.elt)("input", { name: "upload", type: "button", value: "Upload" });
			uploadButton.addEventListener("click", function (e) {
				buildUploadForm(pm, field);
			});
			return (0, _dom.elt)("div", { class: "widgetField" }, fieldLabel, field, uploadButton);
		},
		validate: function validate(dom) {
			var input = dom.querySelector("input");
			return input.checkValidity() ? null : input.name + ": " + input.validationMessage;
		},
		read: function read(dom) {
			var input = dom.querySelector("input");
			return input ? input.value : input;
		}
	};

	_prompt.ParamPrompt.prototype.paramTypes.select = {
		render: function render(param, value) {
			var options = param.options.call ? param.options(this) : param.options;
			var field = (0, _dom.elt)("select", null, options.map(function (o) {
				return (0, _dom.elt)("option", { value: o.value, selected: o.value == value ? "true" : null }, o.label);
			}));
			field.setAttribute("required", "required");
			var label = param.name ? param.name : param.label;
			field.setAttribute("name", label);
			var fieldLabel = (0, _dom.elt)("label", { for: name }, label);
			return (0, _dom.elt)("div", { class: "widgetField" }, fieldLabel, field);
		},
		validate: function validate(dom) {
			var select = dom.querySelector("select");
			return select.checkValidity() ? null : select.name + ": " + select.validationMessage;
		},
		read: function read(dom) {
			var select = dom.querySelector("select");
			return select ? select.value : select;
		}
	};

	function selectClickedNode(pm, e) {
		var pos = (0, _dompos.selectableNodeAbove)(pm, e.target, { left: e.clientX, top: e.clientY }, true);
		if (!pos) return pm.sel.fastPoll();

		var _pm$selection = pm.selection;
		var node = _pm$selection.node;
		var from = _pm$selection.from;

		if (node && pos.depth >= from.depth && pos.shorten(from.depth).cmp(from) == 0) {
			if (from.depth == 0) return pm.sel.fastPoll();
			pos = from.shorten();
		}

		pm.setNodeSelection(pos);
		pm.focus();
		e.preventDefault();
		lastClicked = e.target;
	}

	function defParamsClick(type, cmdname) {
		var spots = arguments.length <= 2 || arguments[2] === undefined ? ["topleft"] : arguments[2];

		type.prototype.handleClick = function (pm, e, path, node) {
			var spotClicked = false;
			spots.forEach(function check(loc) {
				var r = e.target.getBoundingClientRect();
				if (loc == "all") spotClicked = true;else if (loc == "topleft") spotClicked = spotClicked || e.clientX < r.left + 16 && e.clientY < r.top + 16;else if (loc == "bottomright") spotClicked = spotClicked || e.clientX > r.right - 32 && e.clientY > r.bottom - 32;
			});
			if (spotClicked) {
				var cmd = pm.commands[cmdname];
				if (cmd) {
					selectClickedNode(pm, e);
					cmd.exec(pm);
					return true;
				} else return false;
			}
		};
	}

	function selectedNodeAttr(pm, type, name) {
		var node = pm.selection.node;

		if (node && node.type == type) return node.attrs[name];
	}

	function FileDragHover(e) {
		e.stopPropagation();
		e.preventDefault();
		e.target.className = e.type == "dragover" ? "hover" : "";
	}

	function buildUploadForm(pm, field) {
		var legend = (0, _dom.elt)("h4", null, "File Upload");
		var inputHidden = (0, _dom.elt)("input", { type: "hidden", id: "MAX_FILE_SIZE", name: "MAX_FILE_SIZE", value: "300000" });
		var label = (0, _dom.elt)("label", { for: "fileselect" }, "File to upload:");
		var fileselect = (0, _dom.elt)("input", { id: "fileselect", type: "file", name: "fileselect[]", multiple: "multiple" });
		var filedrag = (0, _dom.elt)("div", { id: "filedrag" }, "or drop files here");
		var cancel = (0, _dom.elt)("input", { type: "button", value: "Cancel" });
		cancel.addEventListener("click", function (e) {
			e.preventDefault();e.stopPropagation();
			pm.wrapper.removeChild(form);
		});
		var saveFile = function saveFile(e) {
			e.preventDefault();e.stopPropagation();
			FileDragHover(e);
			var files = e.target.files || e.dataTransfer.files;
			if (files) field.value = files[0].name;
			if (fhandler) fhandler(files);
			pm.wrapper.removeChild(form);
		};
		fileselect.addEventListener("change", saveFile);
		var xhr = new XMLHttpRequest();
		if (xhr.upload) {
			filedrag.addEventListener("dragover", FileDragHover);
			filedrag.addEventListener("dragleave", FileDragHover);
			filedrag.addEventListener("drop", saveFile);
			filedrag.style.display = "block";
		}
		var form = (0, _dom.elt)("form", { id: "upload", enctype: "multipart/form-data" }, legend, (0, _dom.elt)("div", null, label, fileselect, filedrag), (0, _dom.elt)("div", null, cancel));
		pm.wrapper.appendChild(form);
	}

	(0, _dom.insertCSS)("\n\n.widgetDialog {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n\tbackground: #FFF;\n\tz-index: 8888;\n\topacity:0.7;\n\tfont-family: Helvetica, Arial, Sans-Serif;\n}\n\n.widgetForm {\n\tbackground: white;\n\tposition: absolute;\n\ttop: 10px;\n\tleft: 10px;\n\tz-index: 9999;\n\tdisplay: block;\n\tborder-radius: 6px;\n\tborder: 1px solid #AAA;\n\tpadding: 4px;\n}\n\n.widgetForm h4 {\n\tmargin: 0;\n}\n\n.widgetField {\n\tdisplay: block;\n\tpadding: 2px;\n}\n\n.widgetField label {\n\twidth: 80px;\n\tcolor: black;\n\tdisplay: inline-block;\n\tpadding: 2px;\n\tfloat: left;\n}\n\n.widgetField input {\n\tmargin: 2px;\n\tdisplay: inline;\n}\n\n.widgetField input[type = \"number\"] {\n\twidth: 60px;\n\tmargin: 2px;\n\tdisplay: inline;\n}\n\n.widgetField input[type = \"button\"] {\n\tmargin: 5px;\n}\n\n.widgetFieldName {\n\tcolor: black;\n\tdisplay: inline;\n\tpadding: 4px;\n}\n\n.widgetButtons {\n\ttext-align: center;\n\tdisplay: inline-block;\n\twhite-space: nowrap;\n}\n\n.widgetButtons input {\n\tmargin: 5px;\n}\n\n#upload {\n\tposition: absolute;\n\ttop: 40px;\n\tleft: 40px;\n\tpadding: 5px;\n\tborder: 1px solid #AAA;\n\tborder-radius: 6px;\n\tbackground: white;\n\tz-index: 10000;\n\tdisplay: block;\n}\n\n#upload input {\n\tmargin: 5px;\n}\n\n#upload h4 {\n\tmargin: 0;\n}\n\n#filedrag {\n\tdisplay: none;\n\tfont-weight: bold;\n\ttext-align: center;\n\tpadding: 1em 0;\n\tmargin: 1em 0;\n\tcolor: #555;\n\tborder: 2px dashed #555;\n\tborder-radius: 6px;\n\tcursor: default;\n}\n\n#filedrag:hover {\n\tcolor: #f00;\n\tborder-color: #f00;\n\tborder-style: solid;\n\tbox-shadow: inset 0 3px 4px #888;\n}\n\n.ProseMirror-invalid {\n\t  white-space: nowrap;\n\t  font-size: 80%;\n\t  background: white;\n\t  border: 1px solid red;\n\t  border-radius: 4px;\n\t  padding: 5px 10px;\n\t  position: absolute;\n\t  min-width: 10em;\n\t}\n\n");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ParamPrompt = undefined;
	exports.openPrompt = openPrompt;

	var _error = __webpack_require__(7);

	var _dom = __webpack_require__(14);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// !! The `ui/prompt` module implements functionality for prompting
	// the user for [command parameters](#CommandSpec.params).
	//
	// The default implementation gets the job done, roughly, but you'll
	// probably want to customize it in your own system (or submit patches
	// to improve this implementation).

	// ;; This class represents a dialog that prompts for [command
	// parameters](#CommandSpec.params). It is the default value of the
	// `commandParamPrompt` option. You can set this option to a subclass
	// (or a complete reimplementation) to customize the way in which
	// parameters are read.

	var ParamPrompt = exports.ParamPrompt = function () {
	  // :: (ProseMirror, Command)
	  // Construct a prompt. Note that this does not
	  // [open](#ParamPrompt.open) it yet.

	  function ParamPrompt(pm, command) {
	    var _this = this;

	    _classCallCheck(this, ParamPrompt);

	    // :: ProseMirror
	    this.pm = pm;
	    // :: Command
	    this.command = command;
	    this.doClose = null;
	    // :: [DOMNode]
	    // An array of fields, as created by `ParamTypeSpec.render`, for
	    // the command's parameters.
	    this.fields = command.params.map(function (param) {
	      if (!(param.type in _this.paramTypes)) _error.AssertionError.raise("Unsupported parameter type: " + param.type);
	      return _this.paramTypes[param.type].render.call(_this.pm, param, _this.defaultValue(param));
	    });
	    // :: DOMNode
	    // An HTML form wrapping the fields.
	    this.form = (0, _dom.elt)("form", null, this.fields.map(function (f) {
	      return (0, _dom.elt)("div", null, f);
	    }));
	  }

	  // :: ()
	  // Close the prompt.

	  _createClass(ParamPrompt, [{
	    key: "close",
	    value: function close() {
	      if (this.doClose) {
	        this.doClose();
	        this.doClose = null;
	      }
	    }

	    // :: ()
	    // Open the prompt's dialog.

	  }, {
	    key: "open",
	    value: function open() {
	      var _this2 = this;

	      this.close();
	      var prompt = this.prompt();
	      var hadFocus = this.pm.hasFocus();
	      this.doClose = function () {
	        prompt.close();
	        if (hadFocus) setTimeout(function () {
	          return _this2.pm.focus();
	        }, 50);
	      };

	      var submit = function submit() {
	        var params = _this2.values();
	        if (params) {
	          _this2.close();
	          _this2.command.exec(_this2.pm, params);
	        }
	      };

	      this.form.addEventListener("submit", function (e) {
	        e.preventDefault();
	        submit();
	      });

	      this.form.addEventListener("keydown", function (e) {
	        if (e.keyCode == 27) prompt.close();else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) submit();
	      });

	      var input = this.form.querySelector("input, textarea");
	      if (input) input.focus();
	    }

	    // :: () → ?[any]
	    // Read the values from the form's field. Validate them, and when
	    // one isn't valid (either has a validate function that produced an
	    // error message, or has no validate function, no value, and no
	    // default value), show the problem to the user and return `null`.

	  }, {
	    key: "values",
	    value: function values() {
	      var result = [];
	      for (var i = 0; i < this.command.params.length; i++) {
	        var param = this.command.params[i],
	            dom = this.fields[i];
	        var type = this.paramTypes[param.type],
	            value = type.read.call(this.pm, dom),
	            bad = undefined;
	        if (param.validate) bad = param.validate(value);else if (!value && param.default == null) bad = "No default value available";

	        if (bad) {
	          if (type.reportInvalid) type.reportInvalid.call(this.pm, dom, bad);else this.reportInvalid(dom, bad);
	          return null;
	        }
	        result.push(value);
	      }
	      return result;
	    }

	    // :: (CommandParam) → ?any
	    // Get a parameter's default value, if any.

	  }, {
	    key: "defaultValue",
	    value: function defaultValue(param) {
	      if (param.prefill) {
	        var prefill = param.prefill.call(this.command.self, this.pm);
	        if (prefill != null) return prefill;
	      }
	      return param.default;
	    }

	    // :: () → {close: ()}
	    // Open a prompt with the parameter form in it. The default
	    // implementation calls `openPrompt`.

	  }, {
	    key: "prompt",
	    value: function prompt() {
	      var _this3 = this;

	      return openPrompt(this.pm, this.form, { onClose: function onClose() {
	          return _this3.close();
	        } });
	    }

	    // :: (DOMNode, string)
	    // Report a field as invalid, showing the given message to the user.

	  }, {
	    key: "reportInvalid",
	    value: function reportInvalid(dom, message) {
	      // FIXME this is awful and needs a lot more work
	      var parent = dom.parentNode;
	      var style = "left: " + (dom.offsetLeft + dom.offsetWidth + 2) + "px; top: " + (dom.offsetTop - 5) + "px";
	      var msg = parent.appendChild((0, _dom.elt)("div", { class: "ProseMirror-invalid", style: style }, message));
	      setTimeout(function () {
	        return parent.removeChild(msg);
	      }, 1500);
	    }
	  }]);

	  return ParamPrompt;
	}();

	// ;; #path=ParamTypeSpec #kind=interface
	// By default, the prompting interface only knows how to prompt for
	// parameters of type `text` and `select`. You can change the way
	// those are prompted for, and define new types, by writing to
	// `ParamPrompt.paramTypes`. All methods on these specs will be called
	// with `this` bound to the relevant `ProseMirror` instance.

	// :: (param: CommandParam, value: ?any) → DOMNode #path=ParamTypeSpec.render
	// Create the DOM structure for a parameter field of this type, and
	// pre-fill it with `value`, if given.

	// :: (field: DOMNode) → any #path=ParamTypeSpec.read
	// Read the value from the DOM field created by
	// [`render`](#ParamTypeSpec.render).

	// :: (field: DOMNode, message: string) #path=ParamTypeSpec.reportInvalid
	// Report the value in the given field as invalid, showing the given
	// error message. This property is optional, and the prompt
	// implementation will fall back to its own method of showing the
	// message when it is not provided.

	// :: Object<ParamTypeSpec>
	// A collection of default renderers and readers for [parameter
	// types](#CommandParam.type), which [parameter
	// handlers](#commandParamHandler) can optionally use to prompt for
	// parameters. `render` should create a form field for the parameter,
	// and `read` should, given that field, return its value.

	ParamPrompt.prototype.paramTypes = Object.create(null);

	ParamPrompt.prototype.paramTypes.text = {
	  render: function render(param, value) {
	    return (0, _dom.elt)("input", { type: "text",
	      placeholder: param.label,
	      value: value,
	      autocomplete: "off" });
	  },
	  read: function read(dom) {
	    return dom.value;
	  }
	};

	ParamPrompt.prototype.paramTypes.select = {
	  render: function render(param, value) {
	    var options = param.options.call ? param.options(this) : param.options;
	    return (0, _dom.elt)("select", null, options.map(function (o) {
	      return (0, _dom.elt)("option", { value: o.value, selected: o.value == value ? "true" : null }, o.label);
	    }));
	  },
	  read: function read(dom) {
	    return dom.value;
	  }
	};

	// :: (ProseMirror, DOMNode, ?Object) → {close: ()}
	// Open a dialog box for the given editor, putting `content` inside of
	// it. The `close` method on the return value can be used to
	// explicitly close the dialog again. The following options are
	// supported:
	//
	// **`pos`**`: {left: number, top: number}`
	//   : Provide an explicit position for the element. By default, it'll
	//     be placed in the center of the editor.
	//
	// **`onClose`**`: fn()`
	//   : A function to be called when the dialog is closed.
	function openPrompt(pm, content, options) {
	  var button = (0, _dom.elt)("button", { class: "ProseMirror-prompt-close" });
	  var wrapper = (0, _dom.elt)("div", { class: "ProseMirror-prompt" }, content, button);
	  var outerBox = pm.wrapper.getBoundingClientRect();

	  pm.wrapper.appendChild(wrapper);
	  if (options && options.pos) {
	    wrapper.style.left = options.pos.left - outerBox.left + "px";
	    wrapper.style.pos = options.pos.top - outerBox.top + "px";
	  } else {
	    var blockBox = wrapper.getBoundingClientRect();
	    var cX = Math.max(0, outerBox.left) + Math.min(window.innerWidth, outerBox.right) - blockBox.width;
	    var cY = Math.max(0, outerBox.top) + Math.min(window.innerHeight, outerBox.bottom) - blockBox.height;
	    wrapper.style.left = cX / 2 - outerBox.left + "px";
	    wrapper.style.top = cY / 2 - outerBox.top + "px";
	  }

	  var close = function close() {
	    pm.off("interaction", close);
	    if (wrapper.parentNode) {
	      wrapper.parentNode.removeChild(wrapper);
	      if (options && options.onClose) options.onClose();
	    }
	  };
	  button.addEventListener("click", close);
	  pm.on("interaction", close);
	  return { close: close };
	}

	(0, _dom.insertCSS)("\n.ProseMirror-prompt {\n  background: white;\n  padding: 2px 6px 2px 15px;\n  border: 1px solid silver;\n  position: absolute;\n  border-radius: 3px;\n  z-index: 11;\n}\n\n.ProseMirror-prompt input[type=\"text\"],\n.ProseMirror-prompt textarea {\n  background: #eee;\n  border: none;\n  outline: none;\n}\n\n.ProseMirror-prompt input[type=\"text\"] {\n  padding: 0 4px;\n}\n\n.ProseMirror-prompt-close {\n  position: absolute;\n  left: 2px; top: 1px;\n  color: #666;\n  border: none; background: transparent; padding: 0;\n}\n\n.ProseMirror-prompt-close:after {\n  content: \"✕\";\n  font-size: 12px;\n}\n\n.ProseMirror-invalid {\n  background: #ffc;\n  border: 1px solid #cc7;\n  border-radius: 4px;\n  padding: 5px 10px;\n  position: absolute;\n  min-width: 10em;\n}\n");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Keymap = exports.baseCommands = exports.Command = exports.CommandSet = exports.MarkedRange = exports.SelectionError = exports.Range = exports.defineOption = exports.ProseMirror = undefined;

	var _main = __webpack_require__(19);

	Object.defineProperty(exports, "ProseMirror", {
	  enumerable: true,
	  get: function get() {
	    return _main.ProseMirror;
	  }
	});

	var _options = __webpack_require__(41);

	Object.defineProperty(exports, "defineOption", {
	  enumerable: true,
	  get: function get() {
	    return _options.defineOption;
	  }
	});

	var _selection = __webpack_require__(45);

	Object.defineProperty(exports, "Range", {
	  enumerable: true,
	  get: function get() {
	    return _selection.Range;
	  }
	});
	Object.defineProperty(exports, "SelectionError", {
	  enumerable: true,
	  get: function get() {
	    return _selection.SelectionError;
	  }
	});

	var _range = __webpack_require__(52);

	Object.defineProperty(exports, "MarkedRange", {
	  enumerable: true,
	  get: function get() {
	    return _range.MarkedRange;
	  }
	});

	var _command = __webpack_require__(42);

	Object.defineProperty(exports, "CommandSet", {
	  enumerable: true,
	  get: function get() {
	    return _command.CommandSet;
	  }
	});
	Object.defineProperty(exports, "Command", {
	  enumerable: true,
	  get: function get() {
	    return _command.Command;
	  }
	});

	var _base_commands = __webpack_require__(43);

	Object.defineProperty(exports, "baseCommands", {
	  enumerable: true,
	  get: function get() {
	    return _base_commands.baseCommands;
	  }
	});

	__webpack_require__(53);

	var _browserkeymap = __webpack_require__(21);

	var _browserkeymap2 = _interopRequireDefault(_browserkeymap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Keymap = _browserkeymap2.default;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DIRTY_REDRAW = exports.DIRTY_RESCAN = exports.ProseMirror = undefined;

	__webpack_require__(20);

	var _browserkeymap = __webpack_require__(21);

	var _browserkeymap2 = _interopRequireDefault(_browserkeymap);

	var _model = __webpack_require__(3);

	var _transform = __webpack_require__(22);

	var _sortedinsert = __webpack_require__(32);

	var _sortedinsert2 = _interopRequireDefault(_sortedinsert);

	var _error = __webpack_require__(7);

	var _map = __webpack_require__(33);

	var _event = __webpack_require__(34);

	var _dom = __webpack_require__(14);

	var _format = __webpack_require__(35);

	var _options = __webpack_require__(41);

	var _selection2 = __webpack_require__(45);

	var _dompos = __webpack_require__(46);

	var _draw = __webpack_require__(47);

	var _input = __webpack_require__(48);

	var _history = __webpack_require__(51);

	var _range = __webpack_require__(52);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; This is the class used to represent instances of the editor. A
	// ProseMirror editor holds a [document](#Node) and a
	// [selection](#Selection), and displays an editable surface
	// representing that document in the browser document.
	//
	// Contains event methods (`on`, etc) from the [event
	// mixin](#EventMixin).

	var ProseMirror = exports.ProseMirror = function () {
	  // :: (Object)
	  // Construct a new editor from a set of [options](#edit_options)
	  // and, if it has a [`place`](#place) option, add it to the
	  // document.

	  function ProseMirror(opts) {
	    _classCallCheck(this, ProseMirror);

	    (0, _dom.ensureCSSAdded)();

	    opts = this.options = (0, _options.parseOptions)(opts);
	    // :: Schema
	    // The schema for this editor's document.
	    this.schema = opts.schema;
	    if (opts.doc == null) opts.doc = this.schema.node("doc", null, [this.schema.node("paragraph")]);
	    // :: DOMNode
	    // The editable DOM node containing the document.
	    this.content = (0, _dom.elt)("div", { class: "ProseMirror-content", "pm-container": true });
	    // :: DOMNode
	    // The outer DOM element of the editor.
	    this.wrapper = (0, _dom.elt)("div", { class: "ProseMirror" }, this.content);
	    this.wrapper.ProseMirror = this;

	    if (opts.place && opts.place.appendChild) opts.place.appendChild(this.wrapper);else if (opts.place) opts.place(this.wrapper);

	    this.setDocInner(opts.docFormat ? (0, _format.parseFrom)(this.schema, opts.doc, opts.docFormat) : opts.doc);
	    (0, _draw.draw)(this, this.doc);
	    this.content.contentEditable = true;
	    if (opts.label) this.content.setAttribute("aria-label", opts.label);

	    // :: Object
	    // A namespace where modules can store references to themselves
	    // associated with this editor instance.
	    this.mod = Object.create(null);
	    this.cached = Object.create(null);
	    this.operation = null;
	    this.dirtyNodes = new _map.Map(); // Maps node object to 1 (re-scan content) or 2 (redraw entirely)
	    this.flushScheduled = false;

	    this.sel = new _selection2.SelectionState(this, (0, _selection2.findSelectionAtStart)(this.doc));
	    this.accurateSelection = false;
	    this.input = new _input.Input(this);

	    // :: Object<Command>
	    // The commands available in the editor.
	    this.commands = null;
	    this.commandKeys = null;
	    (0, _options.initOptions)(this);
	  }

	  // :: (string, any)
	  // Update the value of the given [option](#edit_options).

	  _createClass(ProseMirror, [{
	    key: "setOption",
	    value: function setOption(name, value) {
	      (0, _options.setOption)(this, name, value);
	      // :: (name: string, value: *) #path=ProseMirror#events#optionChanged
	      // Fired when [`setOption`](#ProseMirror.setOption) is called.
	      this.signal("optionChanged", name, value);
	    }

	    // :: (string) → any
	    // Get the current value of the given [option](#edit_options).

	  }, {
	    key: "getOption",
	    value: function getOption(name) {
	      return this.options[name];
	    }

	    // :: Selection
	    // Get the current selection.

	  }, {
	    key: "setTextSelection",

	    // :: (Pos, ?Pos)
	    // Set the selection to a [text selection](#TextSelection) from
	    // `anchor` to `head`, or, if `head` is null, a cursor selection at
	    // `anchor`.
	    value: function setTextSelection(anchor, head) {
	      this.setSelection(new _selection2.TextSelection(anchor, head));
	    }

	    // :: (Pos)
	    // Set the selection to a node selection on the node after `pos`.

	  }, {
	    key: "setNodeSelection",
	    value: function setNodeSelection(pos) {
	      this.checkPos(pos, false);
	      var parent = this.doc.path(pos.path);
	      if (pos.offset >= parent.size) _selection2.SelectionError.raise("Trying to set a node selection at the end of a node");
	      var node = parent.child(pos.offset);
	      if (!node.type.selectable) _selection2.SelectionError.raise("Trying to select a non-selectable node");
	      this.input.maybeAbortComposition();
	      this.sel.setAndSignal(new _selection2.NodeSelection(pos, pos.move(1), node));
	    }

	    // :: (Selection)
	    // Set the selection to the given selection object.

	  }, {
	    key: "setSelection",
	    value: function setSelection(selection) {
	      if (selection instanceof _selection2.TextSelection) {
	        this.checkPos(selection.head, true);
	        if (!selection.empty) this.checkPos(selection.anchor, true);
	      } else {
	        this.checkPos(selection.to, false);
	      }
	      this.setSelectionDirect(selection);
	    }
	  }, {
	    key: "setSelectionDirect",
	    value: function setSelectionDirect(selection) {
	      this.ensureOperation();
	      this.input.maybeAbortComposition();
	      if (!selection.eq(this.sel.range)) this.sel.setAndSignal(selection);
	    }

	    // :: (any, ?string)
	    // Replace the editor's document. When `format` is given, it should
	    // be a [parsable format](#format), and `value` should something in
	    // that format. If not, `value` should be a `Node`.

	  }, {
	    key: "setContent",
	    value: function setContent(value, format) {
	      if (format) value = (0, _format.parseFrom)(this.schema, value, format);
	      this.setDoc(value);
	    }

	    // :: (?string) → any
	    // Get the editor's content in a given format. When `format` is not
	    // given, a `Node` is returned. If it is given, it should be an
	    // existing [serialization format](#format).

	  }, {
	    key: "getContent",
	    value: function getContent(format) {
	      return format ? (0, _format.serializeTo)(this.doc, format) : this.doc;
	    }
	  }, {
	    key: "setDocInner",
	    value: function setDocInner(doc) {
	      if (doc.type != this.schema.nodes.doc) _error.AssertionError.raise("Trying to set a document with a different schema");
	      // :: Node The current document.
	      this.doc = doc;
	      this.ranges = new _range.RangeStore(this);
	      // :: History The edit history for the editor.
	      this.history = new _history.History(this);
	    }

	    // :: (Node, ?Selection)
	    // Set the editor's content, and optionally include a new selection.

	  }, {
	    key: "setDoc",
	    value: function setDoc(doc, sel) {
	      if (!sel) sel = (0, _selection2.findSelectionAtStart)(doc);
	      // :: (doc: Node, selection: Selection) #path=ProseMirror#events#beforeSetDoc
	      // Fired when [`setDoc`](#ProseMirror.setDoc) is called, before
	      // the document is actually updated.
	      this.signal("beforeSetDoc", doc, sel);
	      this.ensureOperation();
	      this.setDocInner(doc);
	      this.sel.set(sel, true);
	      // :: (doc: Node, selection: Selection) #path=ProseMirror#events#setDoc
	      // Fired when [`setDoc`](#ProseMirror.setDoc) is called, after
	      // the document is updated.
	      this.signal("setDoc", doc, sel);
	    }
	  }, {
	    key: "updateDoc",
	    value: function updateDoc(doc, mapping, selection) {
	      this.ensureOperation();
	      this.input.maybeAbortComposition();
	      this.ranges.transform(mapping);
	      this.doc = doc;
	      this.sel.setAndSignal(selection || this.sel.range.map(doc, mapping));
	      // :: () #path=ProseMirror#events#change
	      // Fired when the document has changed. See
	      // [`setDoc`](#ProseMirror.event_setDoc) and
	      // [`transform`](#ProseMirror.event_transform) for more specific
	      // change-related events.
	      this.signal("change");
	    }

	    // :: EditorTransform
	    // Create an editor- and selection-aware `Transform` for this editor.

	  }, {
	    key: "apply",

	    // :: (Transform, ?Object) → ?Transform
	    // Apply a transformation (which you might want to create with the
	    // [`tr` getter](#ProseMirror.tr)) to the document in the editor.
	    // The following options are supported:
	    //
	    // **`selection`**`: ?Selection`
	    //   : A new selection to set after the transformation is applied.
	    //
	    // **`scrollIntoView`**: ?bool
	    //   : When true, scroll the selection into view on the next
	    //     [redraw](#ProseMirror.flush).
	    //
	    // Returns the transform, or `false` if there were no steps in it.
	    //
	    // Has the following property:
	    value: function apply(transform) {
	      var options = arguments.length <= 1 || arguments[1] === undefined ? nullOptions : arguments[1];

	      if (transform.doc == this.doc) return false;
	      if (transform.docs[0] != this.doc && (0, _model.findDiffStart)(transform.docs[0], this.doc)) _error.AssertionError.raise("Applying a transform that does not start with the current document");

	      this.updateDoc(transform.doc, transform, options.selection);
	      // :: (Transform, Object) #path=ProseMirror#events#transform
	      // Signals that a (non-empty) transformation has been aplied to
	      // the editor. Passes the `Transform` and the options given to
	      // [`apply`](#ProseMirror.apply) as arguments to the handler.
	      this.signal("transform", transform, options);
	      if (options.scrollIntoView) this.scrollIntoView();
	      return transform;
	    }

	    // :: (Pos, ?bool)
	    // Verify that the given position is valid in the current document,
	    // and throw an error otherwise. When `textblock` is true, the position
	    // must also fall within a textblock node.

	  }, {
	    key: "checkPos",
	    value: function checkPos(pos, textblock) {
	      if (!pos.isValid(this.doc, textblock)) _error.AssertionError.raise("Position " + pos + " is not valid in current document");
	    }
	  }, {
	    key: "ensureOperation",
	    value: function ensureOperation() {
	      return this.operation || this.startOperation();
	    }
	  }, {
	    key: "startOperation",
	    value: function startOperation(options) {
	      var _this = this;

	      this.operation = new Operation(this);
	      if (!(options && options.readSelection === false) && this.sel.readFromDOM()) this.operation.sel = this.sel.range;

	      if (!this.flushScheduled) {
	        (0, _dom.requestAnimationFrame)(function () {
	          _this.flushScheduled = false;
	          _this.flush();
	        });
	        this.flushScheduled = true;
	      }
	      return this.operation;
	    }

	    // :: ()
	    // Flush any pending changes to the DOM. When the document,
	    // selection, or marked ranges in an editor change, the DOM isn't
	    // updated immediately, but rather scheduled to be updated the next
	    // time the browser redraws the screen. This method can be used to
	    // force this to happen immediately. It can be useful when you, for
	    // example, want to measure where on the screen a part of the
	    // document ends up, immediately after changing the document.

	  }, {
	    key: "flush",
	    value: function flush() {
	      if (!document.body.contains(this.wrapper) || !this.operation) return;
	      // :: () #path=ProseMirror#events#flushing
	      // Fired when the editor is about to [flush](#ProseMirror.flush)
	      // an update to the DOM.
	      this.signal("flushing");
	      var op = this.operation;
	      if (!op) return;
	      this.operation = null;
	      this.accurateSelection = true;

	      var docChanged = op.doc != this.doc || this.dirtyNodes.size,
	          redrawn = false;
	      if (!this.input.composing && (docChanged || op.composingAtStart)) {
	        (0, _draw.redraw)(this, this.dirtyNodes, this.doc, op.doc);
	        this.dirtyNodes.clear();
	        redrawn = true;
	      }

	      if ((redrawn || !op.sel.eq(this.sel.range)) && !this.input.composing || op.focus) this.sel.toDOM(op.focus);

	      // FIXME somehow schedule this relative to ui/update so that it
	      // doesn't cause extra layout
	      if (op.scrollIntoView !== false) (0, _dompos.scrollIntoView)(this, op.scrollIntoView);
	      // :: () #path=ProseMirror#events#draw
	      // Fired when the editor redrew its document in the DOM.
	      if (docChanged) this.signal("draw");
	      // :: () #path=ProseMirror#events#flush
	      // Fired when the editor has finished
	      // [flushing](#ProseMirror.flush) an update to the DOM.
	      this.signal("flush");
	      this.accurateSelection = false;
	    }

	    // :: (Keymap, ?number)
	    // Add a
	    // [keymap](https://github.com/marijnh/browserkeymap#an-object-type-for-keymaps)
	    // to the editor. Keymaps added in this way are queried before the
	    // base keymap. The `rank` parameter can be used to
	    // control when they are queried relative to other maps added like
	    // this. Maps with a lower rank get queried first.

	  }, {
	    key: "addKeymap",
	    value: function addKeymap(map) {
	      var rank = arguments.length <= 1 || arguments[1] === undefined ? 50 : arguments[1];

	      (0, _sortedinsert2.default)(this.input.keymaps, { map: map, rank: rank }, function (a, b) {
	        return a.rank - b.rank;
	      });
	    }

	    // :: (union<string, Keymap>)
	    // Remove the given keymap, or the keymap with the given name, from
	    // the editor.

	  }, {
	    key: "removeKeymap",
	    value: function removeKeymap(map) {
	      var maps = this.input.keymaps;
	      for (var i = 0; i < maps.length; ++i) {
	        if (maps[i].map == map || maps[i].map.options.name == map) {
	          maps.splice(i, 1);
	          return true;
	        }
	      }
	    }

	    // :: (Pos, Pos, ?Object) → MarkedRange
	    // Create a marked range between the given positions. Marked ranges
	    // “track” the part of the document they point to—as the document
	    // changes, they are updated to move, grow, and shrink along with
	    // their content.
	    //
	    // `options` may be an object containing these properties:
	    //
	    // **`inclusiveLeft`**`: bool = false`
	    //   : Whether the left side of the range is inclusive. When it is,
	    //     content inserted at that point will become part of the range.
	    //     When not, it will be outside of the range.
	    //
	    // **`inclusiveRight`**`: bool = false`
	    //   : Whether the right side of the range is inclusive.
	    //
	    // **`removeWhenEmpty`**`: bool = true`
	    //   : Whether the range should be forgotten when it becomes empty
	    //     (because all of its content was deleted).
	    //
	    // **`className`**: string
	    //   : A CSS class to add to the inline content that is part of this
	    //     range.

	  }, {
	    key: "markRange",
	    value: function markRange(from, to, options) {
	      this.checkPos(from);
	      this.checkPos(to);
	      var range = new _range.MarkedRange(from, to, options);
	      this.ranges.addRange(range);
	      return range;
	    }

	    // :: (MarkedRange)
	    // Remove the given range from the editor.

	  }, {
	    key: "removeRange",
	    value: function removeRange(range) {
	      this.ranges.removeRange(range);
	    }

	    // :: (MarkType, ?bool, ?Object)
	    // Set (when `to` is true), unset (`to` is false), or toggle (`to`
	    // is null) the given mark type on the selection. When there is a
	    // non-empty selection, the marks of the selection are updated. When
	    // the selection is empty, the set of [active
	    // marks](#ProseMirror.activeMarks) is updated.

	  }, {
	    key: "setMark",
	    value: function setMark(type, to, attrs) {
	      var sel = this.selection;
	      if (sel.empty) {
	        var marks = this.activeMarks();
	        if (to == null) to = !type.isInSet(marks);
	        if (to && !this.doc.path(sel.head.path).type.canContainMark(type)) return;
	        this.input.storedMarks = to ? type.create(attrs).addToSet(marks) : type.removeFromSet(marks);
	        // :: () #path=ProseMirror#events#activeMarkChange
	        // Fired when the set of [active marks](#ProseMirror.activeMarks) changes.
	        this.signal("activeMarkChange");
	      } else {
	        if (to != null ? to : !this.doc.rangeHasMark(sel.from, sel.to, type)) this.apply(this.tr.addMark(sel.from, sel.to, type.create(attrs)));else this.apply(this.tr.removeMark(sel.from, sel.to, type));
	      }
	    }

	    // :: () → [Mark]
	    // Get the marks at the cursor. By default, this yields the marks
	    // associated with the content at the cursor, as per `Node.marksAt`.
	    // But `setMark` may have been used to change the set of active
	    // marks, in which case that set is returned.

	  }, {
	    key: "activeMarks",
	    value: function activeMarks() {
	      var head;
	      return this.input.storedMarks || ((head = this.selection.head) ? this.doc.marksAt(head) : []);
	    }

	    // :: ()
	    // Give the editor focus.

	  }, {
	    key: "focus",
	    value: function focus() {
	      if (this.operation) this.operation.focus = true;else this.sel.toDOM(true);
	    }

	    // :: () → bool
	    // Query whether the editor has focus.

	  }, {
	    key: "hasFocus",
	    value: function hasFocus() {
	      if (this.sel.range instanceof _selection2.NodeSelection) return document.activeElement == this.content;else return (0, _selection2.hasFocus)(this);
	    }

	    // :: ({top: number, left: number}) → ?Pos
	    // If the given coordinates (which should be relative to the top
	    // left corner of the window—not the page) fall within the editable
	    // content, this method will return the document position that
	    // corresponds to those coordinates.

	  }, {
	    key: "posAtCoords",
	    value: function posAtCoords(coords) {
	      return (0, _dompos.posAtCoords)(this, coords);
	    }

	    // :: (Pos) → {top: number, left: number, bottom: number}
	    // Find the screen coordinates (relative to top left corner of the
	    // window) of the given document position.

	  }, {
	    key: "coordsAtPos",
	    value: function coordsAtPos(pos) {
	      this.checkPos(pos);
	      return (0, _dompos.coordsAtPos)(this, pos);
	    }

	    // :: (?Pos)
	    // Scroll the given position, or the cursor position if `pos` isn't
	    // given, into view.

	  }, {
	    key: "scrollIntoView",
	    value: function scrollIntoView() {
	      var pos = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

	      if (pos) this.checkPos(pos);
	      this.ensureOperation();
	      this.operation.scrollIntoView = pos;
	    }

	    // :: (string, ?[any]) → bool
	    // Execute the named [command](#Command). If the command takes
	    // parameters, they can be passed as an array.

	  }, {
	    key: "execCommand",
	    value: function execCommand(name, params) {
	      var cmd = this.commands[name];
	      return !!(cmd && cmd.exec(this, params) !== false);
	    }

	    // :: (string) → ?string
	    // Return the name of the key that is bound to the given command, if
	    // any.

	  }, {
	    key: "keyForCommand",
	    value: function keyForCommand(name) {
	      var cached = this.commandKeys[name];
	      if (cached !== undefined) return cached;

	      var cmd = this.commands[name],
	          keymap = this.input.baseKeymap;
	      if (!cmd) return this.commandKeys[name] = null;
	      var key = cmd.spec.key || (_dom.browser.mac ? cmd.spec.macKey : cmd.spec.pcKey);
	      if (key) {
	        key = _browserkeymap2.default.normalizeKeyName(Array.isArray(key) ? key[0] : key);
	        var deflt = keymap.bindings[key];
	        if (Array.isArray(deflt) ? deflt.indexOf(name) > -1 : deflt == name) return this.commandKeys[name] = key;
	      }
	      for (var _key in keymap.bindings) {
	        var bound = keymap.bindings[_key];
	        if (Array.isArray(bound) ? bound.indexOf(name) > -1 : bound == name) return this.commandKeys[name] = _key;
	      }
	      return this.commandKeys[name] = null;
	    }
	  }, {
	    key: "markRangeDirty",
	    value: function markRangeDirty(range) {
	      this.ensureOperation();
	      var dirty = this.dirtyNodes;
	      var from = range.from,
	          to = range.to;
	      for (var depth = 0, node = this.doc;; depth++) {
	        var fromEnd = depth == from.depth,
	            toEnd = depth == to.depth;
	        if (!fromEnd && !toEnd && from.path[depth] == to.path[depth]) {
	          var child = node.child(from.path[depth]);
	          if (!dirty.has(child)) dirty.set(child, DIRTY_RESCAN);
	          node = child;
	        } else {
	          var _ret = function () {
	            var start = fromEnd ? from.offset : from.path[depth];
	            var end = toEnd ? to.offset : to.path[depth] + 1;
	            if (node.isTextblock) {
	              node.forEach(function (child, cStart, cEnd) {
	                if (cStart < end && cEnd > start) dirty.set(child, DIRTY_REDRAW);
	              });
	            } else {
	              for (var i = node.iter(start, end), child; child = i.next().value;) {
	                dirty.set(child, DIRTY_REDRAW);
	              }
	            }
	            return "break";
	          }();

	          if (_ret === "break") break;
	        }
	      }
	    }
	  }, {
	    key: "markAllDirty",
	    value: function markAllDirty() {
	      this.dirtyNodes.set(this.doc, DIRTY_REDRAW);
	    }
	  }, {
	    key: "selection",
	    get: function get() {
	      if (!this.accurateSelection) this.ensureOperation();
	      return this.sel.range;
	    }
	  }, {
	    key: "tr",
	    get: function get() {
	      return new EditorTransform(this);
	    }
	  }]);

	  return ProseMirror;
	}();

	// :: Object
	// The object `{scrollIntoView: true}`, which is a common argument to
	// pass to `ProseMirror.apply` or `EditorTransform.apply`.

	ProseMirror.prototype.apply.scroll = { scrollIntoView: true };

	var DIRTY_RESCAN = exports.DIRTY_RESCAN = 1,
	    DIRTY_REDRAW = exports.DIRTY_REDRAW = 2;

	var nullOptions = {};

	(0, _event.eventMixin)(ProseMirror);

	var Operation = function Operation(pm) {
	  _classCallCheck(this, Operation);

	  this.doc = pm.doc;
	  this.sel = pm.sel.range;
	  this.scrollIntoView = false;
	  this.focus = false;
	  this.composingAtStart = !!pm.input.composing;
	};

	// ;; A selection-aware extension of `Transform`. Use
	// `ProseMirror.tr` to create an instance.

	var EditorTransform = function (_Transform) {
	  _inherits(EditorTransform, _Transform);

	  function EditorTransform(pm) {
	    _classCallCheck(this, EditorTransform);

	    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(EditorTransform).call(this, pm.doc));

	    _this2.pm = pm;
	    return _this2;
	  }

	  // :: (?Object) → ?EditorTransform
	  // Apply the transformation. Returns the transform, or `false` it is
	  // was empty.

	  _createClass(EditorTransform, [{
	    key: "apply",
	    value: function apply(options) {
	      return this.pm.apply(this, options);
	    }

	    // :: Selection
	    // Get the editor's current selection, [mapped](#Selection.map)
	    // through the steps in this transform.

	  }, {
	    key: "replaceSelection",

	    // :: (?Node, ?bool) → EditorTransform
	    // Replace the selection with the given node, or delete it if `node`
	    // is null. When `inheritMarks` is true and the node is an inline
	    // node, it inherits the marks from the place where it is inserted.
	    value: function replaceSelection(node, inheritMarks) {
	      var _selection = this.selection;
	      var empty = _selection.empty;
	      var from = _selection.from;
	      var to = _selection.to;
	      var selNode = _selection.node;var parent = undefined;
	      if (node && node.isInline && inheritMarks !== false) {
	        var marks = empty ? this.pm.input.storedMarks : this.doc.marksAt(from);
	        node = node.type.create(node.attrs, node.text, marks);
	      }

	      if (selNode && selNode.isTextblock && node && node.isInline) {
	        // Putting inline stuff onto a selected textblock puts it inside
	        from = new _model.Pos(from.toPath(), 0);
	        to = new _model.Pos(from.path, selNode.size);
	      } else if (selNode) {
	        // This node can not simply be removed/replaced. Remove its parent as well
	        while (from.depth && from.offset == 0 && (parent = this.doc.path(from.path)) && from.offset == parent.size - 1 && !parent.type.canBeEmpty && !(node && parent.type.canContain(node))) {
	          from = from.shorten();
	          to = to.shorten(null, 1);
	        }
	      } else if (node && node.isBlock && this.doc.path(from.path.slice(0, from.depth - 1)).type.canContain(node)) {
	        // Inserting a block node into a textblock. Try to insert it above by splitting the textblock
	        this.delete(from, to);
	        var _parent = this.doc.path(from.path);
	        if (from.offset && from.offset != _parent.size) this.split(from);
	        return this.insert(from.shorten(null, from.offset ? 1 : 0), node);
	      }

	      if (node) return this.replaceWith(from, to, node);else return this.delete(from, to);
	    }

	    // :: () → EditorTransform
	    // Delete the selection.

	  }, {
	    key: "deleteSelection",
	    value: function deleteSelection() {
	      return this.replaceSelection();
	    }

	    // :: (string) → EditorTransform
	    // Replace the selection with a text node containing the given string.

	  }, {
	    key: "typeText",
	    value: function typeText(text) {
	      return this.replaceSelection(this.pm.schema.text(text), true);
	    }
	  }, {
	    key: "selection",
	    get: function get() {
	      return this.steps.length ? this.pm.selection.map(this) : this.pm.selection;
	    }
	  }]);

	  return EditorTransform;
	}(_transform.Transform);

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _dom = __webpack_require__(14);

	(0, _dom.insertCSS)("\n\n.ProseMirror {\n  border: 1px solid silver;\n  position: relative;\n}\n\n.ProseMirror-content {\n  padding: 4px 8px 4px 14px;\n  white-space: pre-wrap;\n  line-height: 1.2;\n}\n\n.ProseMirror-drop-target {\n  position: absolute;\n  width: 1px;\n  background: #666;\n  display: none;\n}\n\n.ProseMirror-content ul.tight p, .ProseMirror-content ol.tight p {\n  margin: 0;\n}\n\n.ProseMirror-content ul, .ProseMirror-content ol {\n  padding-left: 30px;\n  cursor: default;\n}\n\n.ProseMirror-content blockquote {\n  padding-left: 1em;\n  border-left: 3px solid #eee;\n  margin-left: 0; margin-right: 0;\n}\n\n.ProseMirror-content pre {\n  white-space: pre-wrap;\n}\n\n.ProseMirror-selectednode {\n  outline: 2px solid #8cf;\n}\n\n.ProseMirror-content p:first-child,\n.ProseMirror-content h1:first-child,\n.ProseMirror-content h2:first-child,\n.ProseMirror-content h3:first-child,\n.ProseMirror-content h4:first-child,\n.ProseMirror-content h5:first-child,\n.ProseMirror-content h6:first-child {\n  margin-top: .3em;\n}\n\n/* Add space around the hr to make clicking it easier */\n\n.ProseMirror-content hr {\n  position: relative;\n  height: 6px;\n  border: none;\n}\n\n.ProseMirror-content hr:after {\n  content: \"\";\n  position: absolute;\n  left: 10px;\n  right: 10px;\n  top: 2px;\n  border-top: 2px solid silver;\n}\n\n.ProseMirror-content img {\n  cursor: default;\n}\n\n/* Make sure li selections wrap around markers */\n\n.ProseMirror-content li {\n  position: relative;\n  pointer-events: none; /* Don't do weird stuff with marker clicks */\n}\n.ProseMirror-content li > * {\n  pointer-events: auto;\n}\n\nli.ProseMirror-selectednode {\n  outline: none;\n}\n\nli.ProseMirror-selectednode:after {\n  content: \"\";\n  position: absolute;\n  left: -32px;\n  right: -2px; top: -2px; bottom: -2px;\n  border: 2px solid #8cf;\n  pointer-events: none;\n}\n\n");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	(function(mod) {
	  if (true) // CommonJS
	    module.exports = mod()
	  else if (typeof define == "function" && define.amd) // AMD
	    return define([], mod)
	  else // Plain browser env
	    (this || window).browserKeymap = mod()
	})(function() {
	  "use strict"

	  var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform)
	          : typeof os != "undefined" ? os.platform() == "darwin" : false

	  // :: Object<string>
	  // A map from key codes to key names.
	  var keyNames = {
	    3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
	    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	  }

	  // Number keys
	  for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i)
	  // Alphabetic keys
	  for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i)
	  // Function keys
	  for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i

	  // :: (KeyboardEvent) → ?string
	  // Find a name for the given keydown event. If the keycode in the
	  // event is not known, this will return `null`. Otherwise, it will
	  // return a string like `"Shift-Cmd-Ctrl-Alt-Home"`. The parts before
	  // the dashes give the modifiers (always in that order, if present),
	  // and the last word gives the key name, which one of the names in
	  // `keyNames`.
	  //
	  // The convention for keypress events is to use the pressed character
	  // between single quotes. Due to limitations in the browser API,
	  // keypress events can not have modifiers.
	  function keyName(event) {
	    if (event.type == "keypress") return "'" + String.fromCharCode(event.charCode) + "'"

	    var base = keyNames[event.keyCode], name = base
	    if (name == null || event.altGraphKey) return null

	    if (event.altKey && base != "Alt") name = "Alt-" + name
	    if (event.ctrlKey && base != "Ctrl") name = "Ctrl-" + name
	    if (event.metaKey && base != "Cmd") name = "Cmd-" + name
	    if (event.shiftKey && base != "Shift") name = "Shift-" + name
	    return name
	  }

	  // :: (string) → bool
	  // Test whether the given key name refers to a modifier key.
	  function isModifierKey(name) {
	    name = /[^-]*$/.exec(name)[0]
	    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
	  }

	  // :: (string) → string
	  // Normalize a sloppy key name, which may have modifiers in the wrong
	  // order or use shorthands for modifiers, to a properly formed key
	  // name. Used to normalize names provided in keymaps.
	  //
	  // Note that the modifier `mod` is a shorthand for `Cmd` on Mac, and
	  // `Ctrl` on other platforms.
	  function normalizeKeyName(name) {
	    var parts = name.split(/-(?!'?$)/), result = parts[parts.length - 1]
	    var alt, ctrl, shift, cmd
	    for (var i = 0; i < parts.length - 1; i++) {
	      var mod = parts[i]
	      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true
	      else if (/^a(lt)?$/i.test(mod)) alt = true
	      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true
	      else if (/^s(hift)$/i.test(mod)) shift = true
	      else if (/^mod$/i.test(mod)) { if (mac) cmd = true; else ctrl = true }
	      else throw new Error("Unrecognized modifier name: " + mod)
	    }
	    if (alt) result = "Alt-" + result
	    if (ctrl) result = "Ctrl-" + result
	    if (cmd) result = "Cmd-" + result
	    if (shift) result = "Shift-" + result
	    return result
	  }

	  // :: (Object, ?Object)
	  // A keymap binds a set of [key names](#keyName) to commands names
	  // or functions.
	  //
	  // Construct a keymap using the bindings in `keys`, whose properties
	  // should be [key names](#keyName) or space-separated sequences of
	  // key names. In the second case, the binding will be for a
	  // multi-stroke key combination.
	  //
	  // When `options` has a property `call`, this will be a programmatic
	  // keymap, meaning that instead of looking keys up in its set of
	  // bindings, it will pass the key name to `options.call`, and use
	  // the return value of that calls as the resolved binding.
	  //
	  // `options.name` can be used to give the keymap a name, making it
	  // easier to [remove](#ProseMirror.removeKeymap) from an editor.
	  function Keymap(keys, options) {
	    this.options = options || {}
	    this.bindings = Object.create(null)
	    if (keys) for (var keyname in keys) if (Object.prototype.hasOwnProperty.call(keys, keyname))
	      this.addBinding(keyname, keys[keyname])
	  }

	  Keymap.prototype = {
	    normalize: function(name) {
	      return this.options.multi !== false ? name.split(/ +(?!\'$)/).map(normalizeKeyName) : [normalizeKeyName(name)]
	    },

	    // :: (string, any)
	    // Add a binding for the given key or key sequence.
	    addBinding: function(keyname, value) {
	      var keys = this.normalize(keyname)
	      for (var i = 0; i < keys.length; i++) {
	        var name = keys.slice(0, i + 1).join(" ")
	        var val = i == keys.length - 1 ? value : "..."
	        var prev = this.bindings[name]
	        if (!prev) this.bindings[name] = val
	        else if (prev != val) throw new Error("Inconsistent bindings for " + name)
	      }
	    },

	    // :: (string)
	    // Remove the binding for the given key or key sequence.
	    removeBinding: function(keyname) {
	      var keys = this.normalize(keyname)
	      for (var i = keys.length - 1; i >= 0; i--) {
	        var name = keys.slice(0, i).join(" ")
	        var val = this.bindings[name]
	        if (val == "..." && !this.unusedMulti(name))
	          break
	        else if (val)
	          delete this.bindings[name]
	      }
	    },

	    unusedMulti: function(name) {
	      for (var binding in this.bindings)
	        if (binding.length > name && binding.indexOf(name) == 0 && binding.charAt(name.length) == " ")
	          return false
	      return true
	    },

	    // :: (string, ?any) → any
	    // Looks up the given key or key sequence in this keymap. Returns
	    // the value the key is bound to (which may be undefined if it is
	    // not bound), or the string `"..."` if the key is a prefix of a
	    // multi-key sequence that is bound by this keymap.
	    lookup: function(key, context) {
	      return this.options.call ? this.options.call(key, context) : this.bindings[key]
	    },

	    constructor: Keymap
	  }

	  Keymap.keyName = keyName
	  Keymap.isModifierKey = isModifierKey
	  Keymap.normalizeKeyName = normalizeKeyName

	  return Keymap
	})


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Remapping = exports.MapResult = exports.PosMap = exports.joinableBlocks = exports.joinPoint = exports.canWrap = exports.canLift = exports.StepResult = exports.Step = exports.Transform = undefined;

	var _transform = __webpack_require__(23);

	Object.defineProperty(exports, "Transform", {
	  enumerable: true,
	  get: function get() {
	    return _transform.Transform;
	  }
	});

	var _step = __webpack_require__(24);

	Object.defineProperty(exports, "Step", {
	  enumerable: true,
	  get: function get() {
	    return _step.Step;
	  }
	});
	Object.defineProperty(exports, "StepResult", {
	  enumerable: true,
	  get: function get() {
	    return _step.StepResult;
	  }
	});

	var _ancestor = __webpack_require__(26);

	Object.defineProperty(exports, "canLift", {
	  enumerable: true,
	  get: function get() {
	    return _ancestor.canLift;
	  }
	});
	Object.defineProperty(exports, "canWrap", {
	  enumerable: true,
	  get: function get() {
	    return _ancestor.canWrap;
	  }
	});

	var _join = __webpack_require__(28);

	Object.defineProperty(exports, "joinPoint", {
	  enumerable: true,
	  get: function get() {
	    return _join.joinPoint;
	  }
	});
	Object.defineProperty(exports, "joinableBlocks", {
	  enumerable: true,
	  get: function get() {
	    return _join.joinableBlocks;
	  }
	});

	var _map = __webpack_require__(25);

	Object.defineProperty(exports, "PosMap", {
	  enumerable: true,
	  get: function get() {
	    return _map.PosMap;
	  }
	});
	Object.defineProperty(exports, "MapResult", {
	  enumerable: true,
	  get: function get() {
	    return _map.MapResult;
	  }
	});
	Object.defineProperty(exports, "Remapping", {
	  enumerable: true,
	  get: function get() {
	    return _map.Remapping;
	  }
	});

	__webpack_require__(29);

	__webpack_require__(30);

	__webpack_require__(31);

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Transform = undefined;

	var _step2 = __webpack_require__(24);

	var _map = __webpack_require__(25);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; A change to a document often consists of a series of
	// [steps](#Step). This class provides a convenience abstraction to
	// build up and track such an array of steps. A `Transform` object
	// implements `Mappable`.
	//
	// The high-level transforming methods return the `Transform` object
	// itself, so that they can be chained.

	var Transform = function () {
	  // :: (Node)
	  // Create a transformation that starts with the given document.

	  function Transform(doc) {
	    _classCallCheck(this, Transform);

	    // :: [Step]
	    // The accumulated steps.
	    this.steps = [];
	    // :: [Node]
	    // The individual document versions. Always has a length one more
	    // than `steps`, since it also includes the original starting
	    // document.
	    this.docs = [doc];
	    // :: [PosMap]
	    // The position maps produced by the steps. Has the same length as
	    // `steps`.
	    this.maps = [];
	  }

	  // :: Node
	  // The current version of the transformed document.

	  _createClass(Transform, [{
	    key: "step",

	    // :: (Step) → ?StepResult
	    // Add a step to this transformation. If the step can be
	    // [applied](#Step.apply) to the current document, the result of
	    // applying it is returned, and an element is added to the
	    // [`steps`](#Transform.steps), [`docs`](#Transform.docs), and
	    // [`maps`](#Transform.maps) arrays.
	    value: function step(_step, from, to, pos, param) {
	      if (typeof _step == "string") _step = new _step2.Step(_step, from, to, pos, param);
	      var result = _step.apply(this.doc);
	      if (result) {
	        this.steps.push(_step);
	        this.maps.push(result.map);
	        this.docs.push(result.doc);
	      }
	      return result;
	    }

	    // :: (Pos, ?number) → MapResult
	    // Map a position through the whole transformation (all the position
	    // maps in [`maps`](#Transform.maps)), and return the result.

	  }, {
	    key: "map",
	    value: function map(pos, bias) {
	      var deleted = false;
	      for (var i = 0; i < this.maps.length; i++) {
	        var result = this.maps[i].map(pos, bias);
	        pos = result.pos;
	        if (result.deleted) deleted = true;
	      }
	      return new _map.MapResult(pos, deleted);
	    }
	  }, {
	    key: "doc",
	    get: function get() {
	      return this.docs[this.docs.length - 1];
	    }

	    // :: Node
	    // The original input document.

	  }, {
	    key: "before",
	    get: function get() {
	      return this.docs[0];
	    }
	  }]);

	  return Transform;
	}();

	exports.Transform = Transform;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.StepResult = exports.Step = undefined;

	var _model = __webpack_require__(3);

	var _error = __webpack_require__(7);

	var _map = __webpack_require__(25);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; A step object wraps an atomic operation. It generally applies
	// only to the document it was created for, since the positions
	// associated with it will only make sense for that document.

	var Step = exports.Step = function () {
	  // :: (string, ?Pos, ?Pos, ?Pos, ?any)
	  // Build a step. The type should name a [defined](Step.define) step
	  // type, and the shape of the positions and parameter should be
	  // appropriate for that type.

	  function Step(type, from, to, pos) {
	    var param = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];

	    _classCallCheck(this, Step);

	    if (!(type in steps)) _error.NamespaceError.raise("Unknown step type: " + type);
	    // :: string
	    // The type of the step.
	    this.type = type;
	    // :: ?Pos
	    // The start of the step's range, if any. Which of the three
	    // optional positions associated with a step a given step type
	    // uses differs. The way each of these positions is mapped when
	    // the step is mapped over a [position mapping](#PosMap) depends
	    // on its role.
	    this.from = from;
	    // :: ?Pos
	    // The end of the step's range.
	    this.to = to;
	    // :: ?Pos
	    // The base position for this step.
	    this.pos = pos;
	    // :: ?any
	    // Extra step-type-specific information associated with the step.
	    this.param = param;
	  }

	  // :: (Node) → ?StepResult
	  // Applies this step to the given document, returning a result
	  // containing the transformed document (the input document is not
	  // changed) and a `PosMap`. If the step could not meaningfully be
	  // applied to the given document, this returns `null`.

	  _createClass(Step, [{
	    key: "apply",
	    value: function apply(doc) {
	      return steps[this.type].apply(doc, this);
	    }

	    // :: (Node, PosMap) → Step
	    // Create an inverted version of this step. Needs the document as it
	    // was before the step, as well as `PosMap` created by applying the
	    // step to that document, as input.

	  }, {
	    key: "invert",
	    value: function invert(oldDoc, map) {
	      return steps[this.type].invert(this, oldDoc, map);
	    }

	    // :: (Mappable) → ?Step
	    // Map this step through a mappable thing, returning either a
	    // version of that step with its positions adjusted, or `null` if
	    // the step was entirely deleted by the mapping.

	  }, {
	    key: "map",
	    value: function map(remapping) {
	      var allDeleted = true;
	      var from = null,
	          to = null,
	          pos = null;

	      if (this.from) {
	        var result = remapping.map(this.from, 1);
	        from = result.pos;
	        if (!result.deleted) allDeleted = false;
	      }
	      if (this.to) {
	        if (this.to.cmp(this.from) == 0) {
	          to = from;
	        } else {
	          var result = remapping.map(this.to, -1);
	          to = result.pos.max(from);
	          if (!result.deleted) allDeleted = false;
	        }
	      }
	      if (this.pos) {
	        if (from && this.pos.cmp(this.from) == 0) {
	          pos = from;
	        } else if (to && this.pos.cmp(this.to) == 0) {
	          pos = to;
	        } else {
	          var result = remapping.map(this.pos, 1);
	          pos = result.pos;
	          if (!result.deleted) allDeleted = false;
	        }
	      }
	      return allDeleted ? null : new Step(this.type, from, to, pos, this.param);
	    }

	    // :: () → Object
	    // Create a JSON-serializeable representation of this step.

	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      var impl = steps[this.type];
	      return {
	        type: this.type,
	        from: this.from,
	        to: this.to,
	        pos: this.pos,
	        param: impl.paramToJSON ? impl.paramToJSON(this.param) : this.param
	      };
	    }

	    // :: (Schema, Object) → Step
	    // Deserialize a step from its JSON representation.

	  }], [{
	    key: "fromJSON",
	    value: function fromJSON(schema, json) {
	      var impl = steps[json.type];
	      return new Step(json.type, json.from && _model.Pos.fromJSON(json.from), json.to && _model.Pos.fromJSON(json.to), json.pos && _model.Pos.fromJSON(json.pos), impl.paramFromJSON ? impl.paramFromJSON(schema, json.param) : json.param);
	    }

	    // :: (string, Object)
	    // Define a new type of step. Implementation should have the
	    // following properties:
	    //
	    // **`apply`**`(doc: Node, step: Step) → ?StepResult
	    //   : Applies the step to a document.
	    // **`invert`**`(step: Step, oldDoc: Node, map: PosMap) → Step
	    //   : Create an inverted version of the step.
	    // **`paramToJSON`**`(param: ?any) → ?Object
	    //   : Serialize this step type's parameter to JSON.
	    // **`paramFromJSON`**`(schema: Schema, json: ?Object) → ?any
	    //   : Deserialize this step type's parameter from JSON.

	  }, {
	    key: "define",
	    value: function define(type, implementation) {
	      steps[type] = implementation;
	    }
	  }]);

	  return Step;
	}();

	// ;; Objects of this type are returned as the result of
	// applying a transform step to a document.

	var StepResult = exports.StepResult = function StepResult(doc) {
	  var map = arguments.length <= 1 || arguments[1] === undefined ? _map.nullMap : arguments[1];

	  _classCallCheck(this, StepResult);

	  // :: Node The transformed document.
	  this.doc = doc;
	  // :: PosMap
	  // The position map that describes the correspondence between the
	  // old and the new document.
	  this.map = map;
	};

	var steps = Object.create(null);

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Remapping = exports.nullMap = exports.MapResult = exports.PosMap = exports.ReplacedRange = exports.MovedRange = undefined;

	var _model = __webpack_require__(3);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; #kind=interface #path=Mappable
	// There are various things that positions can be mapped through.
	// We'll denote those as 'mappable'. This is not an actual class in
	// the codebase, only an agreed-on interface.

	// :: (pos: Pos, bias: ?number) → MapResult
	// #path=Mappable.map
	// Map a position through this object. When given, the `bias`
	// determines in which direction to move when a chunk of content is
	// inserted at or around the mapped position.

	var MovedRange = exports.MovedRange = function () {
	  function MovedRange(start, size) {
	    var dest = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	    _classCallCheck(this, MovedRange);

	    this.start = start;
	    this.size = size;
	    this.dest = dest;
	  }

	  _createClass(MovedRange, [{
	    key: "toString",
	    value: function toString() {
	      return "[moved " + this.start + "+" + this.size + " to " + this.dest + "]";
	    }
	  }, {
	    key: "end",
	    get: function get() {
	      return new _model.Pos(this.start.path, this.start.offset + this.size);
	    }
	  }]);

	  return MovedRange;
	}();

	var Side = function Side(from, to, ref) {
	  _classCallCheck(this, Side);

	  this.from = from;
	  this.to = to;
	  this.ref = ref;
	};

	var ReplacedRange = exports.ReplacedRange = function () {
	  function ReplacedRange(from, to, newFrom, newTo) {
	    var ref = arguments.length <= 4 || arguments[4] === undefined ? from : arguments[4];
	    var newRef = arguments.length <= 5 || arguments[5] === undefined ? newFrom : arguments[5];

	    _classCallCheck(this, ReplacedRange);

	    this.before = new Side(from, to, ref);
	    this.after = new Side(newFrom, newTo, newRef);
	  }

	  _createClass(ReplacedRange, [{
	    key: "toString",
	    value: function toString() {
	      return "[replaced " + this.before.from + "-" + this.before.to + " with " + this.after.from + "-" + this.after.to + "]";
	    }
	  }]);

	  return ReplacedRange;
	}();

	var empty = [];

	function offsetFrom(base, pos) {
	  if (pos.path.length > base.path.length) {
	    var path = [pos.path[base.path.length] - base.offset];
	    for (var i = base.path.length + 1; i < pos.path.length; i++) {
	      path.push(pos.path[i]);
	    }return new _model.Pos(path, pos.offset);
	  } else {
	    return new _model.Pos([], pos.offset - base.offset);
	  }
	}

	function mapThrough(map, pos) {
	  var bias = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
	  var back = arguments[3];

	  for (var i = 0; i < map.replaced.length; i++) {
	    var range = map.replaced[i],
	        side = back ? range.after : range.before;
	    var left = undefined,
	        right = undefined;
	    if ((left = pos.cmp(side.from)) >= 0 && (right = pos.cmp(side.to)) <= 0) {
	      var other = back ? range.before : range.after;
	      return new MapResult(bias < 0 ? other.from : other.to, !!(left && right), { rangeID: i, offset: offsetFrom(side.ref, pos) });
	    }
	  }

	  for (var i = 0; i < map.moved.length; i++) {
	    var range = map.moved[i];
	    var start = back ? range.dest : range.start;
	    if (pos.cmp(start) >= 0 && _model.Pos.cmp(pos.path, pos.offset, start.path, start.offset + range.size) <= 0) {
	      var dest = back ? range.start : range.dest;
	      var depth = start.depth;
	      if (pos.depth > depth) {
	        var offset = dest.offset + (pos.path[depth] - start.offset);
	        return new MapResult(new _model.Pos(dest.path.concat(offset).concat(pos.path.slice(depth + 1)), pos.offset));
	      } else {
	        return new MapResult(new _model.Pos(dest.path, dest.offset + (pos.offset - start.offset)));
	      }
	    }
	  }

	  return new MapResult(pos);
	}

	// ;; A position map, holding information about the way positions in
	// the pre-step version of a document correspond to positions in the
	// post-step version. This class implements `Mappable`.

	var PosMap = exports.PosMap = function () {
	  function PosMap(moved, replaced) {
	    _classCallCheck(this, PosMap);

	    this.moved = moved || empty;
	    this.replaced = replaced || empty;
	  }

	  _createClass(PosMap, [{
	    key: "recover",
	    value: function recover(offset) {
	      return this.replaced[offset.rangeID].after.ref.extend(offset.offset);
	    }

	    // :: (Pos, ?number) → MapResult
	    // Map the given position through this map. The `bias` parameter can
	    // be used to control what happens when the transform inserted
	    // content at (or around) this position—if `bias` is negative, the a
	    // position before the inserted content will be returned, if it is
	    // positive, a position after the insertion is returned.

	  }, {
	    key: "map",
	    value: function map(pos, bias) {
	      return mapThrough(this, pos, bias, false);
	    }

	    // :: () → PosMap
	    // Create an inverted version of this map. The result can be used to
	    // map positions in the post-step document to the pre-step document.

	  }, {
	    key: "invert",
	    value: function invert() {
	      return new InvertedPosMap(this);
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return this.moved.concat(this.replaced).join(" ");
	    }
	  }]);

	  return PosMap;
	}();

	// ;; The return value of mapping a position.

	var MapResult = exports.MapResult = function MapResult(pos) {
	  var deleted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	  var recover = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	  _classCallCheck(this, MapResult);

	  // :: Pos The mapped version of the position.
	  this.pos = pos;
	  // :: bool Tells you whether the position was deleted, that is,
	  // whether the step removed its surroundings from the document.
	  this.deleted = deleted;
	  this.recover = recover;
	};

	var InvertedPosMap = function () {
	  function InvertedPosMap(map) {
	    _classCallCheck(this, InvertedPosMap);

	    this.inner = map;
	  }

	  _createClass(InvertedPosMap, [{
	    key: "recover",
	    value: function recover(offset) {
	      return this.inner.replaced[offset.rangeID].before.ref.extend(offset.offset);
	    }
	  }, {
	    key: "map",
	    value: function map(pos, bias) {
	      return mapThrough(this.inner, pos, bias, true);
	    }
	  }, {
	    key: "invert",
	    value: function invert() {
	      return this.inner;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return "-" + this.inner;
	    }
	  }]);

	  return InvertedPosMap;
	}();

	var nullMap = exports.nullMap = new PosMap();

	// ;; A remapping represents a pipeline of zero or more mappings. It
	// is a specialized data structured used to manage mapping through a
	// series of steps, typically including inverted and non-inverted
	// versions of the same step. (This comes up when ‘rebasing’ steps for
	// collaboration or history management.) This class implements
	// `Mappable`.

	var Remapping = exports.Remapping = function () {
	  // :: (?[PosMap], ?[PosMap])

	  function Remapping() {
	    var head = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var tail = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	    var mirror = arguments.length <= 2 || arguments[2] === undefined ? Object.create(null) : arguments[2];

	    _classCallCheck(this, Remapping);

	    // :: [PosMap]
	    // The maps in the head of the mapping are applied to input
	    // positions first, back-to-front. So the map at the end of this
	    // array (if any) is the very first one applied.
	    this.head = head;
	    // The maps in the tail are applied last, front-to-back.
	    this.tail = tail;
	    this.mirror = mirror;
	  }

	  // :: (PosMap, ?number) → number
	  // Add a map to the mapping's front. If this map is the mirror image
	  // (produced by an inverted step) of another map in this mapping,
	  // that map's id (as returned by this method or
	  // [`addToBack`](#Remapping.addToBack)) should be passed as a second
	  // parameter to register the correspondence.

	  _createClass(Remapping, [{
	    key: "addToFront",
	    value: function addToFront(map, corr) {
	      this.head.push(map);
	      var id = -this.head.length;
	      if (corr != null) this.mirror[id] = corr;
	      return id;
	    }

	    // :: (PosMap, ?number) → number
	    // Add a map to the mapping's back. If the map is the mirror image
	    // of another mapping in this object, the id of that map should be
	    // passed to register the correspondence.

	  }, {
	    key: "addToBack",
	    value: function addToBack(map, corr) {
	      this.tail.push(map);
	      var id = this.tail.length - 1;
	      if (corr != null) this.mirror[corr] = id;
	      return id;
	    }
	  }, {
	    key: "get",
	    value: function get(id) {
	      return id < 0 ? this.head[-id - 1] : this.tail[id];
	    }

	    // :: (Pos, ?number) → MapResult
	    // Map a position through this remapping, optionally passing a bias
	    // direction.

	  }, {
	    key: "map",
	    value: function map(pos, bias) {
	      var deleted = false;

	      for (var i = -this.head.length; i < this.tail.length; i++) {
	        var map = this.get(i);
	        var result = map.map(pos, bias);
	        if (result.recover) {
	          var corr = this.mirror[i];
	          if (corr != null) {
	            i = corr;
	            pos = this.get(corr).recover(result.recover);
	            continue;
	          }
	        }
	        if (result.deleted) deleted = true;
	        pos = result.pos;
	      }

	      return new MapResult(pos, deleted);
	    }
	  }]);

	  return Remapping;
	}();

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.canLift = canLift;
	exports.canWrap = canWrap;

	var _model = __webpack_require__(3);

	var _transform = __webpack_require__(23);

	var _step = __webpack_require__(24);

	var _tree = __webpack_require__(27);

	var _map = __webpack_require__(25);

	// !! **`ancestor`**
	//    : Change the stack of nodes that wrap the part of the document
	//      between `from` and `to`, which must point into the same parent
	//      node.
	//
	//      The set of ancestors to replace is determined by the `depth`
	//      property of the step's parameter. If this is greater than
	//      zero, `from` and `to` must point at the start and end of a
	//      stack of nodes, of that depth, since this step will not split
	//      nodes.
	//
	//      The set of new ancestors to wrap with is determined by the
	//      `types` and `attrs` properties of the parameter. The first
	//      should be an array of `NodeType`s, and the second, optionally,
	//      an array of attribute objects.

	_step.Step.define("ancestor", {
	  apply: function apply(doc, step) {
	    var from = step.from,
	        to = step.to;
	    if (!(0, _tree.isFlatRange)(from, to)) return null;
	    var toParent = from.path,
	        start = from.offset,
	        end = to.offset;
	    var _step$param = step.param;
	    var _step$param$depth = _step$param.depth;
	    var depth = _step$param$depth === undefined ? 0 : _step$param$depth;
	    var _step$param$types = _step$param.types;
	    var types = _step$param$types === undefined ? [] : _step$param$types;
	    var _step$param$attrs = _step$param.attrs;
	    var attrs = _step$param$attrs === undefined ? [] : _step$param$attrs;

	    var inner = doc.path(from.path);
	    for (var i = 0; i < depth; i++) {
	      if (start > 0 || end < doc.path(toParent).size || toParent.length == 0) return null;
	      start = toParent[toParent.length - 1];
	      end = start + 1;
	      toParent = toParent.slice(0, toParent.length - 1);
	    }
	    if (depth == 0 && types.length == 0) return null;

	    var parent = doc.path(toParent),
	        parentSize = parent.size,
	        newParent = undefined;
	    if (parent.type.locked) return null;
	    if (types.length) {
	      var _ret = function () {
	        var lastWrapper = types[types.length - 1];
	        var content = inner.content.slice(from.offset, to.offset);
	        if (!parent.type.canContainType(types[0]) || content.some(function (n) {
	          return !lastWrapper.canContain(n);
	        }) || !inner.size && !lastWrapper.canBeEmpty || lastWrapper.locked) return {
	            v: null
	          };
	        var node = null;
	        for (var i = types.length - 1; i >= 0; i--) {
	          node = types[i].create(attrs[i], node || content);
	        }newParent = parent.splice(start, end, _model.Fragment.from(node));
	      }();

	      if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
	    } else {
	      if (!parent.type.canContainFragment(inner.content) || !inner.size && start == 0 && end == parent.size && !parent.type.canBeEmpty) return null;
	      newParent = parent.splice(start, end, inner.content);
	    }
	    var copy = doc.replaceDeep(toParent, newParent);

	    var toInner = toParent.slice();
	    for (var i = 0; i < types.length; i++) {
	      toInner.push(i ? 0 : start);
	    }var startOfInner = new _model.Pos(toInner, types.length ? 0 : start);
	    var replaced = null;
	    var insertedSize = types.length ? 1 : to.offset - from.offset;
	    if (depth != types.length || depth > 1 || types.length > 1) {
	      var posBefore = new _model.Pos(toParent, start);
	      var posAfter1 = new _model.Pos(toParent, end),
	          posAfter2 = new _model.Pos(toParent, start + insertedSize);
	      var endOfInner = new _model.Pos(toInner, startOfInner.offset + (to.offset - from.offset));
	      replaced = [new _map.ReplacedRange(posBefore, from, posBefore, startOfInner), new _map.ReplacedRange(to, posAfter1, endOfInner, posAfter2, posAfter1, posAfter2)];
	    }
	    var moved = [new _map.MovedRange(from, to.offset - from.offset, startOfInner)];
	    if (end - start != insertedSize) moved.push(new _map.MovedRange(new _model.Pos(toParent, end), parentSize - end, new _model.Pos(toParent, start + insertedSize)));
	    return new _step.StepResult(copy, new _map.PosMap(moved, replaced));
	  },
	  invert: function invert(step, oldDoc, map) {
	    var types = [],
	        attrs = [];
	    if (step.param.depth) for (var i = 0; i < step.param.depth; i++) {
	      var parent = oldDoc.path(step.from.path.slice(0, step.from.path.length - i));
	      types.unshift(parent.type);
	      attrs.unshift(parent.attrs);
	    }
	    var newFrom = map.map(step.from).pos;
	    var newTo = step.from.cmp(step.to) ? map.map(step.to, -1).pos : newFrom;
	    return new _step.Step("ancestor", newFrom, newTo, null, { depth: step.param.types ? step.param.types.length : 0,
	      types: types, attrs: attrs });
	  },
	  paramToJSON: function paramToJSON(param) {
	    return { depth: param.depth,
	      types: param.types && param.types.map(function (t) {
	        return t.name;
	      }),
	      attrs: param.attrs };
	  },
	  paramFromJSON: function paramFromJSON(schema, json) {
	    return { depth: json.depth,
	      types: json.types && json.types.map(function (n) {
	        return schema.nodeType(n);
	      }),
	      attrs: json.attrs };
	  }
	});

	function canBeLifted(doc, range) {
	  var content = [doc.path(range.from.path)],
	      unwrap = false;
	  for (;;) {
	    var parentDepth = -1;

	    var _loop = function _loop(_node, i) {
	      if (!content.some(function (inner) {
	        return !_node.type.canContainContent(inner.type);
	      })) parentDepth = i;
	      _node = _node.child(range.from.path[i]);
	      node = _node;
	    };

	    for (var node = doc, i = 0; i < range.from.path.length; i++) {
	      _loop(node, i);
	    }
	    if (parentDepth > -1) return { path: range.from.path.slice(0, parentDepth), unwrap: unwrap };
	    if (unwrap || !content[0].isBlock) return null;
	    content = content[0].content.slice(range.from.offset, range.to.offset);
	    unwrap = true;
	  }
	}

	// :: (Node, Pos, ?Pos) → bool
	// Tells you whether the given positions' [sibling
	// range](#Node.siblingRange), or any of its ancestor nodes, can be
	// lifted out of a parent.
	function canLift(doc, from, to) {
	  var range = doc.siblingRange(from, to || from);
	  var found = canBeLifted(doc, range);
	  if (found) return { found: found, range: range };
	}

	// :: (Pos, ?Pos) → Transform
	// Lift the nearest liftable ancestor of the [sibling
	// range](#Node.siblingRange) of the given positions out of its
	// parent (or do nothing if no such node exists).
	_transform.Transform.prototype.lift = function (from) {
	  var to = arguments.length <= 1 || arguments[1] === undefined ? from : arguments[1];

	  var can = canLift(this.doc, from, to);
	  if (!can) return this;
	  var found = can.found;
	  var range = can.range;

	  var depth = range.from.path.length - found.path.length;
	  var rangeNode = found.unwrap && this.doc.path(range.from.path);

	  for (var d = 0, pos = range.to;; d++) {
	    if (pos.offset < this.doc.path(pos.path).size) {
	      this.split(pos, depth - d);
	      break;
	    }
	    if (d == depth - 1) break;
	    pos = pos.shorten(null, 1);
	  }
	  for (var d = 0, pos = range.from;; d++) {
	    if (pos.offset > 0) {
	      this.split(pos, depth - d);
	      var cut = range.from.path.length - depth,
	          path = pos.path.slice(0, cut).concat(pos.path[cut] + 1);
	      while (path.length < range.from.path.length) {
	        path.push(0);
	      }range = { from: new _model.Pos(path, 0), to: new _model.Pos(path, range.to.offset - range.from.offset) };
	      break;
	    }
	    if (d == depth - 1) break;
	    pos = pos.shorten();
	  }
	  if (found.unwrap) {
	    for (var i = range.to.offset - 1; i > range.from.offset; i--) {
	      this.join(new _model.Pos(range.from.path, i));
	    }var size = 0;
	    for (var i = rangeNode.iter(range.from.offset, range.to.offset), child; child = i.next().value;) {
	      size += child.size;
	    }var path = range.from.path.concat(range.from.offset);
	    range = { from: new _model.Pos(path, 0), to: new _model.Pos(path, size) };
	    ++depth;
	  }
	  this.step("ancestor", range.from, range.to, null, { depth: depth });
	  return this;
	};

	// :: (Node, Pos, ?Pos, NodeType) → bool
	// Determines whether the [sibling range](#Node.siblingRange) of the
	// given positions can be wrapped in the given node type.
	function canWrap(doc, from, to, type) {
	  var range = doc.siblingRange(from, to || from);
	  if (range.from.offset == range.to.offset) return null;
	  var parent = doc.path(range.from.path);
	  var around = parent.type.findConnection(type);
	  var inside = type.findConnection(parent.child(range.from.offset).type);
	  if (around && inside) return { range: range, around: around, inside: inside };
	}

	// :: (Pos, ?Pos, NodeType, ?Object) → Transform
	// Wrap the [sibling range](#Node.siblingRange) of the given positions
	// in a node of the given type, with the given attributes (if
	// possible).
	_transform.Transform.prototype.wrap = function (from, to, type, wrapAttrs) {
	  var can = canWrap(this.doc, from, to, type);
	  if (!can) return this;
	  var range = can.range;
	  var around = can.around;
	  var inside = can.inside;

	  var types = around.concat(type).concat(inside);
	  var attrs = around.map(function () {
	    return null;
	  }).concat(wrapAttrs).concat(inside.map(function () {
	    return null;
	  }));
	  this.step("ancestor", range.from, range.to, null, { types: types, attrs: attrs });
	  if (inside.length) {
	    var toInner = range.from.path.slice();
	    for (var i = 0; i < around.length + inside.length + 1; i++) {
	      toInner.push(i ? 0 : range.from.offset);
	    }for (var i = range.to.offset - 1 - range.from.offset; i > 0; i--) {
	      this.split(new _model.Pos(toInner, i), inside.length);
	    }
	  }
	  return this;
	};

	// :: (Pos, ?Pos, NodeType, ?Object) → Transform
	// Set the type of all textblocks (partly) between `from` and `to` to
	// the given node type with the given attributes.
	_transform.Transform.prototype.setBlockType = function (from, to, type, attrs) {
	  var _this = this;

	  this.doc.nodesBetween(from, to || from, function (node, path) {
	    if (node.isTextblock && !node.hasMarkup(type, attrs)) {
	      path = path.slice();
	      // Ensure all markup that isn't allowed in the new node type is cleared
	      _this.clearMarkup(new _model.Pos(path, 0), new _model.Pos(path, node.size), type);
	      _this.step("ancestor", new _model.Pos(path, 0), new _model.Pos(path, _this.doc.path(path).size), null, { depth: 1, types: [type], attrs: [attrs] });
	      return false;
	    }
	  });
	  return this;
	};

	// :: (Pos, NodeType, ?Object) → Transform
	// Change the type and attributes of the node after `pos`.
	_transform.Transform.prototype.setNodeType = function (pos, type, attrs) {
	  var node = this.doc.nodeAfter(pos);
	  var path = pos.toPath();
	  this.step("ancestor", new _model.Pos(path, 0), new _model.Pos(path, node.size), null, { depth: 1, types: [type], attrs: [attrs] });
	  return this;
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.copyStructure = copyStructure;
	exports.copyInline = copyInline;
	exports.isFlatRange = isFlatRange;
	exports.replaceHasEffect = replaceHasEffect;
	exports.samePathDepth = samePathDepth;

	var _model = __webpack_require__(3);

	function copyStructure(node, from, to, f) {
	  var depth = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];

	  if (node.isTextblock) {
	    return f(node, from ? from.offset : 0, to ? to.offset : node.size);
	  } else {
	    if (!node.size) return node;
	    var start = from ? from.path[depth] : 0;
	    var end = to ? to.path[depth] + 1 : node.size;
	    var content = node.content.toArray(0, start);
	    for (var iter = node.iter(start, end), child; child = iter.next().value;) {
	      var passFrom = iter.offset - child.width == start ? from : null;
	      var passTo = iter.offset == end ? to : null;
	      content.push(copyStructure(child, passFrom, passTo, f, depth + 1));
	    }
	    return node.copy(_model.Fragment.fromArray(content.concat(node.content.toArray(end))));
	  }
	}

	function copyInline(node, from, to, f) {
	  return node.splice(from, to, node.content.slice(from, to).map(f));
	}

	function isFlatRange(from, to) {
	  if (from.path.length != to.path.length) return false;
	  for (var i = 0; i < from.path.length; i++) {
	    if (from.path[i] != to.path[i]) return false;
	  }return from.offset <= to.offset;
	}

	function canBeJoined(node, offset, depth) {
	  if (!depth || offset == 0 || offset == node.size) return false;
	  var left = node.child(offset - 1),
	      right = node.child(offset);
	  return left.sameMarkup(right);
	}

	function replaceHasEffect(doc, from, to) {
	  for (var depth = 0, node = doc;; depth++) {
	    var fromEnd = depth == from.depth,
	        toEnd = depth == to.depth;
	    if (fromEnd || toEnd || from.path[depth] != to.path[depth]) {
	      var gapStart = undefined,
	          gapEnd = undefined;
	      if (fromEnd) {
	        gapStart = from.offset;
	      } else {
	        gapStart = from.path[depth] + 1;
	        for (var i = depth + 1, n = node.child(gapStart - 1); i <= from.path.length; i++) {
	          if (i == from.path.length) {
	            if (from.offset < n.size) return true;
	          } else {
	            if (from.path[i] + 1 < n.size) return true;
	            n = n.child(from.path[i]);
	          }
	        }
	      }
	      if (toEnd) {
	        gapEnd = to.offset;
	      } else {
	        gapEnd = to.path[depth];
	        for (var i = depth + 1; i <= to.path.length; i++) {
	          if ((i == to.path.length ? to.offset : to.path[i]) > 0) return true;
	        }
	      }
	      if (gapStart != gapEnd) return true;
	      return canBeJoined(node, gapStart, Math.min(from.depth, to.depth) - depth);
	    } else {
	      node = node.child(from.path[depth]);
	    }
	  }
	}

	function samePathDepth(a, b) {
	  for (var i = 0;; i++) {
	    if (i == a.path.length || i == b.path.length || a.path[i] != b.path[i]) return i;
	  }
	}

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.joinableBlocks = joinableBlocks;
	exports.joinPoint = joinPoint;

	var _model = __webpack_require__(3);

	var _transform = __webpack_require__(23);

	var _step = __webpack_require__(24);

	var _map = __webpack_require__(25);

	// !! **`join`**
	//   : Join two block elements together. `from` and `to` must point at
	//     the end of the first and start of the second element (so that
	//     the intention is preserved even when the positions are mapped).

	_step.Step.define("join", {
	  apply: function apply(doc, step) {
	    var before = doc.path(step.from.path);
	    var after = doc.path(step.to.path);
	    if (step.from.offset < before.size || step.to.offset > 0 || !before.type.canContainFragment(after.content)) return null;
	    var pFrom = step.from.path,
	        pTo = step.to.path;
	    var last = pFrom.length - 1,
	        offset = pFrom[last] + 1;
	    if (pFrom.length != pTo.length || pFrom.length == 0 || offset != pTo[last]) return null;
	    for (var i = 0; i < last; i++) {
	      if (pFrom[i] != pTo[i]) return null;
	    }var targetPath = pFrom.slice(0, last);
	    var target = doc.path(targetPath),
	        oldSize = target.size;
	    if (target.type.locked) return null;
	    var joined = before.append(after.content);
	    var copy = doc.replaceDeep(targetPath, target.splice(offset - 1, offset + 1, _model.Fragment.from(joined)));

	    var map = new _map.PosMap([new _map.MovedRange(step.to, after.size, step.from), new _map.MovedRange(new _model.Pos(targetPath, offset + 1), oldSize - offset - 1, new _model.Pos(targetPath, offset))], [new _map.ReplacedRange(step.from, step.to, step.from, step.from, step.to.shorten())]);
	    return new _step.StepResult(copy, map);
	  },
	  invert: function invert(step, oldDoc) {
	    return new _step.Step("split", null, null, step.from, oldDoc.path(step.to.path).copy());
	  }
	});

	// :: (Node, Pos) → bool
	// Test whether the blocks before and after a given position can be
	// joined.
	function joinableBlocks(doc, pos) {
	  if (pos.offset == 0) return false;
	  var parent = doc.path(pos.path);
	  if (parent.isTextblock || pos.offset == parent.size) return false;
	  var type = parent.child(pos.offset - 1).type;
	  return !type.isTextblock && type.contains && type == parent.child(pos.offset).type;
	}

	// :: (Node, Pos, ?number) → ?Pos
	// Find an ancestor of the given position that can be joined to the
	// block before (or after if `dir` is positive). Returns the joinable
	// point, if any.
	function joinPoint(doc, pos) {
	  var dir = arguments.length <= 2 || arguments[2] === undefined ? -1 : arguments[2];

	  for (;;) {
	    if (joinableBlocks(doc, pos)) return pos;
	    if (pos.depth == 0) return null;
	    pos = pos.shorten(null, dir < 0 ? 0 : 1);
	  }
	}

	// :: (Pos) → Transform
	// Join the blocks around the given position.
	_transform.Transform.prototype.join = function (at) {
	  var parent = this.doc.path(at.path);
	  if (at.offset == 0 || at.offset == parent.size || parent.isTextblock) return this;
	  this.step("join", new _model.Pos(at.path.concat(at.offset - 1), parent.child(at.offset - 1).size), new _model.Pos(at.path.concat(at.offset), 0));
	  return this;
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _model = __webpack_require__(3);

	var _transform = __webpack_require__(23);

	var _step = __webpack_require__(24);

	var _tree = __webpack_require__(27);

	// !!
	// **`addMark`**
	//   : Add the `Mark` given as the step's parameter to all
	//     inline content between `from` and `to` (when allowed).
	//
	// **`removeMark`**
	//   : Remove the `Mark` given as the step's parameter from all inline
	//     content between `from` and `to`.

	_step.Step.define("addMark", {
	  apply: function apply(doc, step) {
	    return new _step.StepResult((0, _tree.copyStructure)(doc, step.from, step.to, function (node, from, to) {
	      if (!node.type.canContainMark(step.param)) return node;
	      return (0, _tree.copyInline)(node, from, to, function (node) {
	        return node.mark(step.param.addToSet(node.marks));
	      });
	    }));
	  },
	  invert: function invert(step, _oldDoc, map) {
	    return new _step.Step("removeMark", step.from, map.map(step.to).pos, null, step.param);
	  },
	  paramToJSON: function paramToJSON(param) {
	    return param.toJSON();
	  },
	  paramFromJSON: function paramFromJSON(schema, json) {
	    return schema.markFromJSON(json);
	  }
	});

	// :: (Pos, Pos, Mark) → Transform
	// Add the given mark to the inline content between `from` and `to`.
	_transform.Transform.prototype.addMark = function (from, to, mark) {
	  var _this = this;

	  var removed = [],
	      added = [],
	      removing = null,
	      adding = null;
	  this.doc.inlineNodesBetween(from, to, function (_ref, path, start, end, parent) {
	    var marks = _ref.marks;

	    if (mark.isInSet(marks) || !parent.type.canContainMark(mark.type)) {
	      adding = removing = null;
	    } else {
	      var rm = mark.type.isInSet(marks);
	      if (rm) {
	        if (removing && removing.param.eq(rm)) {
	          removing.to = new _model.Pos(path, end);
	        } else {
	          removing = new _step.Step("removeMark", new _model.Pos(path, start), new _model.Pos(path, end), null, rm);
	          removed.push(removing);
	        }
	      } else if (removing) {
	        removing = null;
	      }
	      if (adding) {
	        adding.to = new _model.Pos(path, end);
	      } else {
	        adding = new _step.Step("addMark", new _model.Pos(path, start), new _model.Pos(path, end), null, mark);
	        added.push(adding);
	      }
	    }
	  });
	  removed.forEach(function (s) {
	    return _this.step(s);
	  });
	  added.forEach(function (s) {
	    return _this.step(s);
	  });
	  return this;
	};

	_step.Step.define("removeMark", {
	  apply: function apply(doc, step) {
	    return new _step.StepResult((0, _tree.copyStructure)(doc, step.from, step.to, function (node, from, to) {
	      return (0, _tree.copyInline)(node, from, to, function (node) {
	        return node.mark(step.param.removeFromSet(node.marks));
	      });
	    }));
	  },
	  invert: function invert(step, _oldDoc, map) {
	    return new _step.Step("addMark", step.from, map.map(step.to).pos, null, step.param);
	  },
	  paramToJSON: function paramToJSON(param) {
	    return param.toJSON();
	  },
	  paramFromJSON: function paramFromJSON(schema, json) {
	    return schema.markFromJSON(json);
	  }
	});

	// :: (Pos, Pos, union<Mark, MarkType>) → Transform
	// Remove the given mark, or all marks of the given type, from inline
	// nodes between `from` and `to`.
	_transform.Transform.prototype.removeMark = function (from, to) {
	  var _this2 = this;

	  var mark = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	  var matched = [],
	      step = 0;
	  this.doc.inlineNodesBetween(from, to, function (_ref2, path, start, end) {
	    var marks = _ref2.marks;

	    step++;
	    var toRemove = null;
	    if (mark instanceof _model.MarkType) {
	      var found = mark.isInSet(marks);
	      if (found) toRemove = [found];
	    } else if (mark) {
	      if (mark.isInSet(marks)) toRemove = [mark];
	    } else {
	      toRemove = marks;
	    }
	    if (toRemove && toRemove.length) {
	      path = path.slice();
	      for (var i = 0; i < toRemove.length; i++) {
	        var rm = toRemove[i],
	            found = undefined;
	        for (var j = 0; j < matched.length; j++) {
	          var m = matched[j];
	          if (m.step == step - 1 && rm.eq(matched[j].style)) found = m;
	        }
	        if (found) {
	          found.to = new _model.Pos(path, end);
	          found.step = step;
	        } else {
	          matched.push({ style: rm, from: new _model.Pos(path, start), to: new _model.Pos(path, end), step: step });
	        }
	      }
	    }
	  });
	  matched.forEach(function (m) {
	    return _this2.step("removeMark", m.from, m.to, null, m.style);
	  });
	  return this;
	};

	// :: (Pos, Pos, ?NodeType) → Transform
	// Remove all marks and non-text inline nodes, or if `newParent` is
	// given, all marks and inline nodes that may not appear as content of
	// `newParent`, from the given range.
	_transform.Transform.prototype.clearMarkup = function (from, to, newParent) {
	  var _this3 = this;

	  var delSteps = []; // Must be accumulated and applied in inverse order
	  this.doc.inlineNodesBetween(from, to, function (_ref3, path, start, end) {
	    var marks = _ref3.marks;
	    var type = _ref3.type;

	    if (newParent ? !newParent.canContainType(type) : !type.isText) {
	      path = path.slice();
	      var _from = new _model.Pos(path, start);
	      delSteps.push(new _step.Step("replace", _from, new _model.Pos(path, end), _from));
	      return;
	    }
	    for (var i = 0; i < marks.length; i++) {
	      var mark = marks[i];
	      if (!newParent || !newParent.canContainMark(mark.type)) {
	        path = path.slice();
	        _this3.step("removeMark", new _model.Pos(path, start), new _model.Pos(path, end), null, mark);
	      }
	    }
	  });
	  for (var i = delSteps.length - 1; i >= 0; i--) {
	    this.step(delSteps[i]);
	  }return this;
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _model = __webpack_require__(3);

	var _transform = __webpack_require__(23);

	var _step = __webpack_require__(24);

	var _map = __webpack_require__(25);

	// !! **`split`**
	//   : Split a block node at `pos`. The parameter, if given, may be
	//     `{type, ?attrs}` object giving the node type and optionally the
	//     attributes of the node created to hold the content after the
	//     split.

	_step.Step.define("split", {
	  apply: function apply(doc, step) {
	    var pos = step.pos;
	    if (pos.depth == 0) return null;

	    var _pos$shorten = pos.shorten();

	    var parentPath = _pos$shorten.path;
	    var offset = _pos$shorten.offset;

	    var parent = doc.path(parentPath);
	    var target = parent.child(offset),
	        targetSize = target.size;

	    var _ref = step.param || target;

	    var typeAfter = _ref.type;
	    var attrsAfter = _ref.attrs;

	    var splitAt = pos.offset;
	    if (splitAt == 0 && !target.type.canBeEmpty || target.type.locked || splitAt == target.size && !typeAfter.canBeEmpty) return null;
	    var newParent = parent.splice(offset, offset + 1, _model.Fragment.from([target.slice(0, splitAt), typeAfter.create(attrsAfter, target.content.slice(splitAt))]));
	    var copy = doc.replaceDeep(parentPath, newParent);

	    var dest = new _model.Pos(parentPath.concat(offset + 1), 0);
	    var map = new _map.PosMap([new _map.MovedRange(pos, targetSize - pos.offset, dest), new _map.MovedRange(new _model.Pos(parentPath, offset + 1), newParent.size - 2 - offset, new _model.Pos(parentPath, offset + 2))], [new _map.ReplacedRange(pos, pos, pos, dest, pos, pos.shorten(null, 1))]);
	    return new _step.StepResult(copy, map);
	  },
	  invert: function invert(step, _oldDoc, map) {
	    return new _step.Step("join", step.pos, map.map(step.pos).pos);
	  },
	  paramToJSON: function paramToJSON(param) {
	    return param && { type: param.type.name, attrs: param.attrs };
	  },
	  paramFromJSON: function paramFromJSON(schema, json) {
	    return json && { type: schema.nodeType(json.type), attrs: json.attrs };
	  }
	});

	// :: (Pos, ?number, ?NodeType, ?Object) → Transform
	// Split the node at the given position, and optionally, if `depth` is
	// greater than one, any number of nodes above that. By default, the part
	// split off will inherit the node type of the original node. This can
	// be changed by passing `typeAfter` and `attrsAfter`.
	_transform.Transform.prototype.split = function (pos) {
	  var depth = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	  var typeAfter = arguments[2];
	  var attrsAfter = arguments[3];

	  if (depth == 0) return this;
	  for (var i = 0;; i++) {
	    this.step("split", null, null, pos, typeAfter && { type: typeAfter, attrs: attrsAfter });
	    if (i == depth - 1) return this;
	    typeAfter = null;
	    pos = pos.shorten(null, 1);
	  }
	};

	// :: (Pos, ?number) → Transform
	// Split at the given position, _if_ that position isn't already at
	// the start or end of a node. If `depth` is greater than one, also do
	// so for parent positions above the given position.
	_transform.Transform.prototype.splitIfNeeded = function (pos) {
	  var depth = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

	  for (var off = 0; off < depth; off++) {
	    var here = pos.shorten(pos.depth - off);
	    if (here.offset && here.offset < this.doc.path(here.path).size) this.step("split", null, null, here);
	  }
	  return this;
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.replace = replace;

	var _model = __webpack_require__(3);

	var _transform = __webpack_require__(23);

	var _step = __webpack_require__(24);

	var _map = __webpack_require__(25);

	var _tree = __webpack_require__(27);

	// !! **`replace`**
	//   : Delete the part of the document between `from` and `to` and
	//     optionally replace it with another chunk of content. `pos` must
	//     point at the ‘root’ at which the cut starts—a position between
	//     and above `from` and `to`.
	//
	//     When new content is to be inserted, the step's parameter should
	//     be an object of shape `{content: `[`Fragment`](#Fragment)`,
	//     openLeft: number, openRight: number}`. The step will insert the
	//     given content at the root of the cut, and `openLeft` and
	//     `openRight` indicate how much of the content on both sides
	//     should be consided ‘open’.
	//
	//     A replace step will try to join open nodes on both sides of the
	//     cut. That is, nodes in the original document that are partially
	//     cut off by `from` and `to`, and nodes at the sides of the
	//     replacement content as specificed by `openLeft` and
	//     `openRight`. For example, if `openLeft` is 2, the first node of
	//     the replacement content as well as its first child is
	//     considered open. Whenever two open nodes with the same
	//     [markup](#Node.sameMarkup) end up next to each other, they are
	//     joined. Open nodes that aren't joined are [closed](#Node.close)
	//     to ensure their content (or lack of it) is valid.

	function findMovedChunks(oldNode, oldPath, newNode, startDepth) {
	  var moved = [];
	  var newPath = oldPath.path.slice(0, startDepth);

	  for (var depth = startDepth;; depth++) {
	    var joined = depth == oldPath.depth ? 0 : 1;
	    var cut = depth == oldPath.depth ? oldPath.offset : oldPath.path[depth];
	    var afterCut = oldNode.size - cut;
	    var newOffset = newNode.size - afterCut;

	    var from = oldPath.shorten(depth, joined);
	    var to = new _model.Pos(newPath, newOffset + joined);
	    if (from.cmp(to)) moved.push(new _map.MovedRange(from, afterCut - joined, to));

	    if (!joined) return moved;

	    oldNode = oldNode.child(cut);
	    newNode = newNode.child(newOffset);
	    newPath = newPath.concat(newOffset);
	  }
	}

	function replace(node, from, to, root, repl) {
	  var depth = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];

	  if (depth == root.length) {
	    var before = node.sliceBetween(null, from, depth);
	    var after = node.sliceBetween(to, null, depth),
	        result = undefined;
	    if (!before.type.canContainFragment(repl.content)) return null;
	    if (repl.content.size) result = before.append(repl.content, from.depth - depth, repl.openLeft).append(after.content, repl.openRight, to.depth - depth);else result = before.append(after.content, from.depth - depth, to.depth - depth);
	    if (!result.size && !result.type.canBeEmpty) result = result.copy(result.type.defaultContent());
	    return { doc: result, moved: findMovedChunks(node, to, result, depth) };
	  } else {
	    var pos = root[depth];
	    var result = replace(node.child(pos), from, to, root, repl, depth + 1);
	    if (!result) return null;
	    return { doc: node.replace(pos, result.doc), moved: result.moved };
	  }
	}

	var nullRepl = { content: _model.emptyFragment, openLeft: 0, openRight: 0 };

	_step.Step.define("replace", {
	  apply: function apply(doc, step) {
	    var rootPos = step.pos,
	        root = rootPos.path;
	    if (step.from.depth < root.length || step.to.depth < root.length) return null;
	    for (var i = 0; i < root.length; i++) {
	      if (step.from.path[i] != root[i] || step.to.path[i] != root[i]) return null;
	    }var result = replace(doc, step.from, step.to, rootPos.path, step.param || nullRepl);
	    if (!result) return null;
	    var out = result.doc;
	    var moved = result.moved;

	    var end = moved.length ? moved[moved.length - 1].dest : step.to;
	    var replaced = new _map.ReplacedRange(step.from, step.to, step.from, end, rootPos, rootPos);
	    return new _step.StepResult(out, new _map.PosMap(moved, [replaced]));
	  },
	  invert: function invert(step, oldDoc, map) {
	    var depth = step.pos.depth;
	    return new _step.Step("replace", step.from, map.map(step.to).pos, step.from.shorten(depth), {
	      content: oldDoc.path(step.pos.path).content.sliceBetween(step.from, step.to, depth),
	      openLeft: step.from.depth - depth,
	      openRight: step.to.depth - depth
	    });
	  },
	  paramToJSON: function paramToJSON(param) {
	    return param && { content: param.content.size && param.content.toJSON(),
	      openLeft: param.openLeft, openRight: param.openRight };
	  },
	  paramFromJSON: function paramFromJSON(schema, json) {
	    return json && { content: _model.Fragment.fromJSON(schema, json.content),
	      openLeft: json.openLeft, openRight: json.openRight };
	  }
	});

	function shiftFromStack(stack, depth) {
	  var shifted = stack[depth] = stack[depth].splice(0, 1, _model.emptyFragment);
	  for (var i = depth - 1; i >= 0; i--) {
	    shifted = stack[i] = stack[i].replace(0, shifted);
	  }
	}

	// FIXME find a not so horribly confusing way to express this
	function buildInserted(nodesLeft, source, start, end) {
	  var sliced = source.sliceBetween(start, end);
	  var nodesRight = [];
	  for (var node = sliced, i = 0; i <= start.path.length; i++, node = node.firstChild) {
	    nodesRight.push(node);
	  }var same = (0, _tree.samePathDepth)(start, end);
	  var searchLeft = nodesLeft.length - 1,
	      searchRight = nodesRight.length - 1;
	  var result = null;

	  var inner = nodesRight[searchRight];
	  if (inner.isTextblock && inner.size && nodesLeft[searchLeft].isTextblock) {
	    result = nodesLeft[searchLeft--].copy(inner.content);
	    --searchRight;
	    shiftFromStack(nodesRight, searchRight);
	  }

	  for (;;) {
	    var node = nodesRight[searchRight],
	        type = node.type,
	        matched = null;
	    var outside = searchRight <= same;
	    for (var i = searchLeft; i >= 0; i--) {
	      var left = nodesLeft[i];
	      if (outside ? left.type.canContainContent(node.type) : left.type == type) {
	        matched = i;
	        break;
	      }
	    }
	    if (matched != null) {
	      if (!result) {
	        result = nodesLeft[matched].copy(node.content);
	        searchLeft = matched - 1;
	      } else {
	        while (searchLeft >= matched) {
	          var wrap = nodesLeft[searchLeft];
	          var content = _model.Fragment.from(result);
	          result = wrap.copy(searchLeft == matched ? content.append(node.content) : content);
	          searchLeft--;
	        }
	      }
	    }
	    if (matched != null || node.size == 0) {
	      if (outside) break;
	      if (searchRight) shiftFromStack(nodesRight, searchRight - 1);
	    }
	    searchRight--;
	  }

	  var repl = { content: result ? result.content : _model.emptyFragment,
	    openLeft: start.depth - searchRight,
	    openRight: end.depth - searchRight };
	  return { repl: repl, depth: searchLeft + 1 };
	}

	function moveText(tr, doc, before, after) {
	  var root = (0, _tree.samePathDepth)(before, after);
	  var cutAt = after.shorten(null, 1);
	  while (cutAt.path.length > root && doc.path(cutAt.path).size == 1) {
	    cutAt = cutAt.shorten(null, 1);
	  }tr.split(cutAt, cutAt.path.length - root);
	  var start = after,
	      end = new _model.Pos(start.path, doc.path(start.path).size);
	  var parent = doc.path(start.path.slice(0, root));
	  var wanted = parent.pathNodes(before.path.slice(root));
	  var existing = parent.pathNodes(start.path.slice(root));
	  while (wanted.length && existing.length && wanted[0].sameMarkup(existing[0])) {
	    wanted.shift();
	    existing.shift();
	  }
	  if (existing.length || wanted.length) tr.step("ancestor", start, end, null, {
	    depth: existing.length,
	    types: wanted.map(function (n) {
	      return n.type;
	    }),
	    attrs: wanted.map(function (n) {
	      return n.attrs;
	    })
	  });
	  for (var i = root; i < before.path.length; i++) {
	    tr.join(before.shorten(i, 1));
	  }
	}

	// :: (Pos, Pos) → Transform
	// Delete the content between the given positions.
	_transform.Transform.prototype.delete = function (from, to) {
	  if (from.cmp(to)) this.replace(from, to);
	  return this;
	};

	// :: (Pos, Pos, Node, Pos, Pos) → Transform
	// Replace the part of the document between `from` and `to` with the
	// part of the `source` between `start` and `end`.
	_transform.Transform.prototype.replace = function (from, to, source, start, end) {
	  var repl = undefined,
	      depth = undefined,
	      doc = this.doc,
	      maxDepth = (0, _tree.samePathDepth)(from, to);
	  if (source) {
	    ;
	    var _buildInserted = buildInserted(doc.pathNodes(from.path), source, start, end);

	    repl = _buildInserted.repl;
	    depth = _buildInserted.depth;

	    while (depth > maxDepth) {
	      if (repl.content.size) repl = { content: _model.Fragment.from(doc.path(from.path.slice(0, depth)).copy(repl.content)),
	        openLeft: repl.openLeft + 1, openRight: repl.openRight + 1 };
	      depth--;
	    }
	  } else {
	    repl = nullRepl;
	    depth = maxDepth;
	  }
	  var root = from.shorten(depth),
	      docAfter = doc,
	      after = to;
	  if (repl.content.size || (0, _tree.replaceHasEffect)(doc, from, to)) {
	    var result = this.step("replace", from, to, root, repl);
	    docAfter = result.doc;
	    after = result.map.map(to).pos;
	  }

	  // If no text nodes before or after end of replacement, don't glue text
	  if (!doc.path(to.path).isTextblock) return this;
	  if (!(repl.content.size ? source.path(end.path).isTextblock : doc.path(from.path).isTextblock)) return this;

	  var nodesAfter = doc.path(root.path).pathNodes(to.path.slice(depth)).slice(1);
	  var nodesBefore = undefined;
	  if (repl.content.size) {
	    var inserted = repl.content;
	    nodesBefore = [];
	    for (var i = 0; i < repl.openRight; i++) {
	      var last = inserted.child(inserted.size - 1);
	      nodesBefore.push(last);
	      inserted = last.content;
	    }
	  } else {
	    nodesBefore = doc.path(root.path).pathNodes(from.path.slice(depth)).slice(1);
	  }

	  if (nodesBefore.length && (nodesAfter.length != nodesBefore.length || !nodesAfter.every(function (n, i) {
	    return n.sameMarkup(nodesBefore[i]);
	  }))) {
	    var _after$shorten = after.shorten(root.depth);

	    var path = _after$shorten.path;
	    var offset = _after$shorten.offset;var before = undefined;
	    for (var node = docAfter.path(path), i = 0;; i++) {
	      if (i == nodesBefore.length) {
	        before = new _model.Pos(path, offset);
	        break;
	      }
	      path.push(offset - 1);
	      node = node.child(offset - 1);
	      offset = node.size;
	    }
	    moveText(this, docAfter, before, after);
	  }
	  return this;
	};

	// :: (Pos, Pos, union<Fragment, Node, [Node]>) → Transform
	// Replace the given range with the given content, which may be a
	// fragment, node, or array of nodes.
	_transform.Transform.prototype.replaceWith = function (from, to, content) {
	  if (!(content instanceof _model.Fragment)) content = _model.Fragment.from(content);
	  if (_model.Pos.samePath(from.path, to.path)) this.step("replace", from, to, from, { content: content, openLeft: 0, openRight: 0 });else this.delete(from, to).step("replace", from, from, from, { content: content, openLeft: 0, openRight: 0 });
	  return this;
	};

	// :: (Pos, union<Fragment, Node, [Node]>) → Transform
	// Insert the given content at the `pos`.
	_transform.Transform.prototype.insert = function (pos, content) {
	  return this.replaceWith(pos, pos, content);
	};

	// :: (Pos, string) → Transform
	// Insert the given text at `pos`, inheriting the marks of the
	// existing content at that position.
	_transform.Transform.prototype.insertText = function (pos, text) {
	  return this.insert(pos, this.doc.type.schema.text(text, this.doc.marksAt(pos)));
	};

	// :: (Pos, Node) → Transform
	// Insert the given node at `pos`, inheriting the marks of the
	// existing content at that position.
	_transform.Transform.prototype.insertInline = function (pos, node) {
	  return this.insert(pos, node.mark(this.doc.marksAt(pos)));
	};

/***/ },
/* 32 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = sortedInsert;
	function sortedInsert(array, elt, compare) {
	  var i = 0;
	  for (; i < array.length; i++) {
	    if (compare(array[i], elt) > 0) break;
	  }array.splice(i, 0, elt);
	}

/***/ },
/* 33 */
/***/ function(module, exports) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Map = exports.Map = window.Map || function () {
	  function _class() {
	    _classCallCheck(this, _class);

	    this.content = [];
	  }

	  _createClass(_class, [{
	    key: "set",
	    value: function set(key, value) {
	      var found = this.find(key);
	      if (found > -1) this.content[found + 1] = value;else this.content.push(key, value);
	    }
	  }, {
	    key: "get",
	    value: function get(key) {
	      var found = this.find(key);
	      return found == -1 ? undefined : this.content[found + 1];
	    }
	  }, {
	    key: "has",
	    value: function has(key) {
	      return this.find(key) > -1;
	    }
	  }, {
	    key: "find",
	    value: function find(key) {
	      for (var i = 0; i < this.content.length; i += 2) {
	        if (this.content[i] === key) return i;
	      }
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.content.length = 0;
	    }
	  }, {
	    key: "size",
	    get: function get() {
	      return this.content.length / 2;
	    }
	  }]);

	  return _class;
	}();

/***/ },
/* 34 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.eventMixin = eventMixin;
	// ;; #path=EventMixin #kind=interface
	// A set of methods for objects that emit events. Added by calling
	// `eventMixin` on a constructor.

	var methods = {
	  // :: (type: string, handler: (...args: [any])) #path=EventMixin.on
	  // Register an event handler for the given event type.

	  on: function on(type, handler) {
	    var map = this._handlers || (this._handlers = {});
	    var arr = map[type] || (map[type] = []);
	    arr.push(handler);
	  },

	  // :: (type: string, handler: (...args: [any])) #path=EventMixin.off
	  // Unregister an event handler for the given event type.
	  off: function off(type, handler) {
	    var arr = this._handlers && this._handlers[type];
	    if (arr) for (var i = 0; i < arr.length; ++i) {
	      if (arr[i] == handler) {
	        arr.splice(i, 1);break;
	      }
	    }
	  },

	  // :: (type: string, ...args: [any]) #path=EventMixin.signal
	  // Signal an event of the given type, passing any number of
	  // arguments. Will call the handlers for the event, passing them the
	  // arguments.
	  signal: function signal(type) {
	    var arr = this._handlers && this._handlers[type];

	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    if (arr) for (var i = 0; i < arr.length; ++i) {
	      arr[i].apply(arr, args);
	    }
	  },

	  // :: (type: string, ...args: [any]) #path=EventMixin.signalHandleable
	  // Signal a handleable event of the given type. All handlers for the
	  // event will be called with the given arguments, until one of them
	  // returns something that is not the value `false`. When that
	  // happens, the return value of that handler is returned. If that
	  // does not happen, `false` is returned.
	  signalHandleable: function signalHandleable(type) {
	    var arr = this._handlers && this._handlers[type];
	    if (arr) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	      }

	      for (var i = 0; i < arr.length; ++i) {
	        var result = arr[i].apply(arr, args);
	        if (result !== false) return result;
	      }
	    }return false;
	  },

	  // :: (type: string, value: any)
	  // Give all handlers for an event a chance to transform a value. The
	  // value returned from a handler will be passed to the next handler.
	  // The method returns the value returned by the final handler (or
	  // the original value, if there are no handlers).
	  signalPipelined: function signalPipelined(type, value) {
	    var arr = this._handlers && this._handlers[type];
	    if (arr) for (var i = 0; i < arr.length; ++i) {
	      value = arr[i](value);
	    }return value;
	  },

	  // :: (type: string) → bool #path=EventMixin.hasHandler
	  // Query whether there are any handlers for this event type.
	  hasHandler: function hasHandler(type) {
	    var arr = this._handlers && this._handlers[type];
	    return arr && arr.length > 0;
	  }
	};

	// :: (())
	// Add the methods in the `EventMixin` interface to the prototype
	// object of the given constructor.
	function eventMixin(ctor) {
	  var proto = ctor.prototype;
	  for (var prop in methods) {
	    if (methods.hasOwnProperty(prop)) proto[prop] = methods[prop];
	  }
	}

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _register = __webpack_require__(36);

	Object.defineProperty(exports, "serializeTo", {
	  enumerable: true,
	  get: function get() {
	    return _register.serializeTo;
	  }
	});
	Object.defineProperty(exports, "knownTarget", {
	  enumerable: true,
	  get: function get() {
	    return _register.knownTarget;
	  }
	});
	Object.defineProperty(exports, "defineTarget", {
	  enumerable: true,
	  get: function get() {
	    return _register.defineTarget;
	  }
	});
	Object.defineProperty(exports, "parseFrom", {
	  enumerable: true,
	  get: function get() {
	    return _register.parseFrom;
	  }
	});
	Object.defineProperty(exports, "knownSource", {
	  enumerable: true,
	  get: function get() {
	    return _register.knownSource;
	  }
	});
	Object.defineProperty(exports, "defineSource", {
	  enumerable: true,
	  get: function get() {
	    return _register.defineSource;
	  }
	});

	var _from_dom = __webpack_require__(37);

	Object.defineProperty(exports, "fromDOM", {
	  enumerable: true,
	  get: function get() {
	    return _from_dom.fromDOM;
	  }
	});
	Object.defineProperty(exports, "fromHTML", {
	  enumerable: true,
	  get: function get() {
	    return _from_dom.fromHTML;
	  }
	});

	var _to_dom = __webpack_require__(38);

	Object.defineProperty(exports, "toDOM", {
	  enumerable: true,
	  get: function get() {
	    return _to_dom.toDOM;
	  }
	});
	Object.defineProperty(exports, "toHTML", {
	  enumerable: true,
	  get: function get() {
	    return _to_dom.toHTML;
	  }
	});
	Object.defineProperty(exports, "nodeToDOM", {
	  enumerable: true,
	  get: function get() {
	    return _to_dom.nodeToDOM;
	  }
	});

	var _from_text = __webpack_require__(39);

	Object.defineProperty(exports, "fromText", {
	  enumerable: true,
	  get: function get() {
	    return _from_text.fromText;
	  }
	});

	var _to_text = __webpack_require__(40);

	Object.defineProperty(exports, "toText", {
	  enumerable: true,
	  get: function get() {
	    return _to_text.toText;
	  }
	});

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.serializeTo = serializeTo;
	exports.knownTarget = knownTarget;
	exports.defineTarget = defineTarget;
	exports.parseFrom = parseFrom;
	exports.knownSource = knownSource;
	exports.defineSource = defineSource;

	var _error = __webpack_require__(7);

	var serializers = Object.create(null);

	// :: (Node, string, ?Object) → any
	// Serialize the given document to the given format. If `options` is
	// given, it will be passed along to the serializer function.
	function serializeTo(doc, format, options) {
	  var converter = serializers[format];
	  if (!converter) _error.NamespaceError.raise("Target format " + format + " not defined");
	  return converter(doc, options);
	}

	// :: (string) → bool
	// Query whether a given serialization format has been registered.
	function knownTarget(format) {
	  return !!serializers[format];
	}

	// :: (string, (Node, ?Object) → any)
	// Register a function as the serializer for `format`.
	function defineTarget(format, func) {
	  serializers[format] = func;
	}

	defineTarget("json", function (doc) {
	  return doc.toJSON();
	});

	var parsers = Object.create(null);

	// :: (Schema, any, string, ?Object) → Node
	// Parse document `value` from the format named by `format`. If
	// `options` is given, it is passed along to the parser function.
	function parseFrom(schema, value, format, options) {
	  var converter = parsers[format];
	  if (!converter) _error.NamespaceError.raise("Source format " + format + " not defined");
	  return converter(schema, value, options);
	}

	// :: (string) → bool
	// Query whether a parser for the named format has been registered.
	function knownSource(format) {
	  return !!parsers[format];
	}

	// :: (string, (Schema, any, ?Object) → Node)
	// Register a parser function for `format`.
	function defineSource(format, func) {
	  parsers[format] = func;
	}

	defineSource("json", function (schema, json) {
	  return schema.nodeFromJSON(json);
	});

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fromDOM = fromDOM;
	exports.fromHTML = fromHTML;

	var _model = __webpack_require__(3);

	var _sortedinsert = __webpack_require__(32);

	var _sortedinsert2 = _interopRequireDefault(_sortedinsert);

	var _register = __webpack_require__(36);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// :: (Schema, DOMNode, ?Object) → Node
	// Parse document from the content of a DOM node. To pass an explicit
	// parent document (for example, when not in a browser window
	// environment, where we simply use the global document), pass it as
	// the `document` property of `options`.
	function fromDOM(schema, dom, options) {
	  if (!options) options = {};
	  var context = new DOMParseState(schema, options.topNode || schema.node("doc"), options);
	  var start = options.from ? dom.childNodes[options.from] : dom.firstChild;
	  var end = options.to != null && dom.childNodes[options.to] || null;
	  context.addAll(start, end, true);
	  var doc = undefined;
	  while (context.stack.length) {
	    doc = context.leave();
	  }return doc;
	}

	// ;; #path=DOMParseSpec #kind=interface
	// To define the way [node](#NodeType) and [mark](#MarkType) types are
	// parsed, you can associate one or more DOM parsing specifications to
	// them using the [`register`](#SchemaItem.register) method with the
	// `"parseDOM"` namespace, using the HTML node name (lowercase) as
	// value name. Each of them defines a parsing strategy for a certain
	// type of DOM node. When `"_"` is used as name, the parser is
	// activated for all nodes.

	// :: ?number #path=DOMParseSpec.rank
	// The precedence of this parsing strategy. Should be a number between
	// 0 and 100, which determines when this parser gets a chance relative
	// to others that apply to the node (low ranks go first). Defaults to
	// 50.

	// :: union<string, (dom: DOMNode, state: DOMParseState) → ?bool> #path=DOMParseSpec.parse
	// The function that, given a DOM node, parses it, updating the parse
	// state. It should return (the exact value) `false` when it wants to
	// indicate that it was not able to parse this node. This function is
	// called in such a way that `this` is bound to the type that the
	// parse spec was associated with.
	//
	// When this is set to the string `"block"`, the content of the DOM
	// node is parsed as the content in a node of the type that this spec
	// was associated with.
	//
	// When set to the string `"mark"`, the content of the DOM node is
	// parsed with an instance of the mark that this spec was associated
	// with added to their marks.

	(0, _register.defineSource)("dom", fromDOM);

	// :: (Schema, string, ?Object) → Node
	// Parses the HTML into a DOM, and then calls through to `fromDOM`.
	function fromHTML(schema, html, options) {
	  var wrap = (options && options.document || window.document).createElement("div");
	  wrap.innerHTML = html;
	  return fromDOM(schema, wrap, options);
	}

	(0, _register.defineSource)("html", fromHTML);

	var blockElements = {
	  address: true, article: true, aside: true, blockquote: true, canvas: true,
	  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,
	  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,
	  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,
	  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true
	};

	var ignoreElements = {
	  head: true, noscript: true, object: true, script: true, style: true, title: true
	};

	var noMarks = [];

	// ;; A state object used to track context during a parse,
	// and to expose methods to custom parsing functions.

	var DOMParseState = function () {
	  function DOMParseState(schema, topNode, options) {
	    _classCallCheck(this, DOMParseState);

	    // :: Object The options passed to this parse.
	    this.options = options || {};
	    // :: Schema The schema that we are parsing into.
	    this.schema = schema;
	    this.stack = [];
	    this.marks = noMarks;
	    this.closing = false;
	    this.enter(topNode.type, topNode.attrs);
	    var info = schemaInfo(schema);
	    this.tagInfo = info.tags;
	    this.styleInfo = info.styles;
	  }

	  _createClass(DOMParseState, [{
	    key: "addDOM",
	    value: function addDOM(dom) {
	      if (dom.nodeType == 3) {
	        var value = dom.nodeValue;
	        var top = this.top,
	            last = undefined;
	        if (/\S/.test(value) || top.type.isTextblock) {
	          value = value.replace(/\s+/g, " ");
	          // If this starts with whitespace, and there is either no node
	          // before it or a node that ends with whitespace, strip the
	          // leading space.
	          if (/^\s/.test(value) && (!(last = top.content[top.content.length - 1]) || last.type.name == "text" && /\s$/.test(last.text))) value = value.slice(1);
	          if (value) this.insertNode(this.schema.text(value, this.marks));
	        }
	      } else if (dom.nodeType != 1 || dom.hasAttribute("pm-ignore")) {
	        // Ignore non-text non-element nodes
	      } else {
	          var style = dom.getAttribute("style");
	          if (style) this.addElementWithStyles(parseStyles(style), dom);else this.addElement(dom);
	        }
	    }
	  }, {
	    key: "addElement",
	    value: function addElement(dom) {
	      var name = dom.nodeName.toLowerCase();
	      if (!this.parseNodeType(name, dom) && !ignoreElements.hasOwnProperty(name)) {
	        this.addAll(dom.firstChild, null);
	        if (blockElements.hasOwnProperty(name) && this.top.type == this.schema.defaultTextblockType()) this.closing = true;
	      }
	    }
	  }, {
	    key: "addElementWithStyles",
	    value: function addElementWithStyles(styles, dom) {
	      var _this = this;

	      var wrappers = [];
	      for (var i = 0; i < styles.length; i += 2) {
	        var parsers = this.styleInfo[styles[i]],
	            value = styles[i + 1];
	        if (parsers) for (var j = 0; j < parsers.length; j++) {
	          wrappers.push(parsers[j], value);
	        }
	      }
	      var next = function next(i) {
	        if (i == wrappers.length) {
	          _this.addElement(dom);
	        } else {
	          var parser = wrappers[i];
	          parser.parse.call(parser.type, wrappers[i + 1], _this, next.bind(null, i + 2));
	        }
	      };
	      next(0);
	    }
	  }, {
	    key: "tryParsers",
	    value: function tryParsers(parsers, dom) {
	      if (parsers) for (var i = 0; i < parsers.length; i++) {
	        var parser = parsers[i];
	        if (parser.parse.call(parser.type, dom, this) !== false) return true;
	      }
	    }
	  }, {
	    key: "parseNodeType",
	    value: function parseNodeType(name, dom) {
	      return this.tryParsers(this.tagInfo[name], dom) || this.tryParsers(this.tagInfo._, dom);
	    }
	  }, {
	    key: "addAll",
	    value: function addAll(from, to, sync) {
	      var stack = sync && this.stack.slice();
	      for (var dom = from; dom != to; dom = dom.nextSibling) {
	        this.addDOM(dom);
	        if (sync && blockElements.hasOwnProperty(dom.nodeName.toLowerCase())) this.sync(stack);
	      }
	    }
	  }, {
	    key: "doClose",
	    value: function doClose() {
	      if (!this.closing || this.stack.length < 2) return;
	      var left = this.leave();
	      this.enter(left.type, left.attrs);
	      this.closing = false;
	    }
	  }, {
	    key: "insertNode",
	    value: function insertNode(node) {
	      if (this.top.type.canContain(node)) {
	        this.doClose();
	      } else {
	        for (var i = this.stack.length - 1; i >= 0; i--) {
	          var route = this.stack[i].type.findConnection(node.type);
	          if (!route) continue;
	          if (i == this.stack.length - 1) {
	            this.doClose();
	          } else {
	            while (this.stack.length > i + 1) {
	              this.leave();
	            }
	          }
	          for (var j = 0; j < route.length; j++) {
	            this.enter(route[j]);
	          }if (this.marks.length) this.marks = noMarks;
	          break;
	        }
	      }
	      this.top.content.push(node);
	      return node;
	    }

	    // :: (DOMNode, NodeType, ?Object, [Node]) → Node
	    // Insert a node of the given type, with the given content, based on
	    // `dom`, at the current position in the document.

	  }, {
	    key: "insert",
	    value: function insert(type, attrs, content) {
	      return this.insertNode(type.createAutoFill(attrs, content, this.marks));
	    }
	  }, {
	    key: "enter",
	    value: function enter(type, attrs) {
	      this.stack.push({ type: type, attrs: attrs, content: [] });
	    }
	  }, {
	    key: "leave",
	    value: function leave() {
	      if (this.marks.length) this.marks = noMarks;
	      var top = this.stack.pop();
	      var last = top.content[top.content.length - 1];
	      if (last && last.isText && /\s$/.test(last.text)) top.content[top.content.length - 1] = last.copy(last.text.slice(0, last.text.length - 1));
	      var node = top.type.createAutoFill(top.attrs, top.content);
	      if (this.stack.length) this.insertNode(node);
	      return node;
	    }
	  }, {
	    key: "sync",
	    value: function sync(stack) {
	      while (this.stack.length > stack.length) {
	        this.leave();
	      }for (;;) {
	        var n = this.stack.length - 1,
	            one = this.stack[n],
	            two = stack[n];
	        if (one.type == two.type && _model.Node.sameAttrs(one.attrs, two.attrs)) break;
	        this.leave();
	      }
	      while (stack.length > this.stack.length) {
	        var add = stack[this.stack.length];
	        this.enter(add.type, add.attrs);
	      }
	      if (this.marks.length) this.marks = noMarks;
	      this.closing = false;
	    }

	    // :: (DOMNode, NodeType, ?Object)
	    // Parse the contents of `dom` as children of a node of the given
	    // type.

	  }, {
	    key: "wrapIn",
	    value: function wrapIn(dom, type, attrs) {
	      this.enter(type, attrs);
	      this.addAll(dom.firstChild, null, true);
	      this.leave();
	    }

	    // :: (DOMNode, Mark)
	    // Parse the contents of `dom`, with `mark` added to the set of
	    // current marks.

	  }, {
	    key: "wrapMark",
	    value: function wrapMark(inner, mark) {
	      var old = this.marks;
	      this.marks = (mark.instance || mark).addToSet(old);
	      if (inner.call) inner();else this.addAll(inner.firstChild, null);
	      this.marks = old;
	    }
	  }, {
	    key: "top",
	    get: function get() {
	      return this.stack[this.stack.length - 1];
	    }
	  }]);

	  return DOMParseState;
	}();

	function parseStyles(style) {
	  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g,
	      m = undefined,
	      result = [];
	  while (m = re.exec(style)) {
	    result.push(m[1], m[2].trim());
	  }return result;
	}

	function schemaInfo(schema) {
	  return schema.cached.parseDOMInfo || (schema.cached.parseDOMInfo = summarizeSchemaInfo(schema));
	}

	function summarizeSchemaInfo(schema) {
	  var tags = Object.create(null),
	      styles = Object.create(null);
	  tags._ = [];
	  schema.registry("parseDOM", function (tag, info, type) {
	    var parse = info.parse;
	    if (parse == "block") parse = function parse(dom, state) {
	      state.wrapIn(dom, this);
	    };else if (parse == "mark") parse = function parse(dom, state) {
	      state.wrapMark(dom, this);
	    };
	    (0, _sortedinsert2.default)(tags[tag] || (tags[tag] = []), {
	      type: type, parse: parse,
	      rank: info.rank == null ? 50 : info.rank
	    }, function (a, b) {
	      return a.rank - b.rank;
	    });
	  });
	  schema.registry("parseDOMStyle", function (style, info, type) {
	    (0, _sortedinsert2.default)(styles[style] || (styles[style] = []), {
	      type: type,
	      parse: info.parse,
	      rank: info.rank == null ? 50 : info.rank
	    }, function (a, b) {
	      return a.rank - b.rank;
	    });
	  });
	  return { tags: tags, styles: styles };
	}

	_model.Paragraph.register("parseDOM", "p", { parse: "block" });

	_model.BlockQuote.register("parseDOM", "blockquote", { parse: "block" });

	var _loop = function _loop(i) {
	  _model.Heading.registerComputed("parseDOM", "h" + i, function (type) {
	    if (i <= type.maxLevel) return {
	      parse: function parse(dom, state) {
	        state.wrapIn(dom, this, { level: i });
	      }
	    };
	  });
	};

	for (var i = 1; i <= 6; i++) {
	  _loop(i);
	}_model.HorizontalRule.register("parseDOM", "hr", { parse: "block" });

	_model.CodeBlock.register("parseDOM", "pre", { parse: function parse(dom, state) {
	    var params = dom.firstChild && /^code$/i.test(dom.firstChild.nodeName) && dom.firstChild.getAttribute("class");
	    if (params && /fence/.test(params)) {
	      var found = [],
	          re = /(?:^|\s)lang-(\S+)/g,
	          m = undefined;
	      while (m = re.test(params)) {
	        found.push(m[1]);
	      }params = found.join(" ");
	    } else {
	      params = null;
	    }
	    var text = dom.textContent;
	    state.insert(this, { params: params }, text ? [state.schema.text(text)] : []);
	  } });

	_model.BulletList.register("parseDOM", "ul", { parse: "block" });

	_model.OrderedList.register("parseDOM", "ol", { parse: function parse(dom, state) {
	    var attrs = { order: dom.getAttribute("start") || 1 };
	    state.wrapIn(dom, this, attrs);
	  } });

	_model.ListItem.register("parseDOM", "li", { parse: "block" });

	_model.HardBreak.register("parseDOM", "br", { parse: function parse(_, state) {
	    state.insert(this);
	  } });

	_model.Image.register("parseDOM", "img", { parse: function parse(dom, state) {
	    state.insert(this, {
	      src: dom.getAttribute("src"),
	      title: dom.getAttribute("title") || null,
	      alt: dom.getAttribute("alt") || null
	    });
	  } });

	// Inline style tokens

	_model.LinkMark.register("parseDOM", "a", { parse: function parse(dom, state) {
	    var href = dom.getAttribute("href");
	    if (!href) return false;
	    state.wrapMark(dom, this.create({ href: href, title: dom.getAttribute("title") }));
	  } });

	_model.EmMark.register("parseDOM", "i", { parse: "mark" });
	_model.EmMark.register("parseDOM", "em", { parse: "mark" });
	_model.StrongMark.register("parseDOMStyle", "font-style", { parse: function parse(value, state, inner) {
	    if (value == "italic") state.wrapMark(inner, this);else inner();
	  } });

	_model.StrongMark.register("parseDOM", "b", { parse: "mark" });
	_model.StrongMark.register("parseDOM", "strong", { parse: "mark" });
	_model.StrongMark.register("parseDOMStyle", "font-weight", { parse: function parse(value, state, inner) {
	    if (value == "bold" || value == "bolder" || !/\D/.test(value) && +value >= 500) state.wrapMark(inner, this);else inner();
	  } });

	_model.CodeMark.register("parseDOM", "code", { parse: "mark" });

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.toDOM = toDOM;
	exports.nodeToDOM = nodeToDOM;
	exports.toHTML = toHTML;

	var _model = __webpack_require__(3);

	var _register = __webpack_require__(36);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; Object used to to expose relevant values and methods
	// to DOM serializer functions.

	var DOMSerializer = function () {
	  function DOMSerializer(options) {
	    _classCallCheck(this, DOMSerializer);

	    // :: Object The options passed to the serializer.
	    this.options = options || {};
	    // :: DOMDocument The DOM document in which we are working.
	    this.doc = this.options.document || window.document;
	  }

	  // :: (string, ?Object, ...union<string, DOMNode>) → DOMNode
	  // Create a DOM node of the given type, with (optionally) the given
	  // attributes and content. Content elements may be strings (for text
	  // nodes) or other DOM nodes.

	  _createClass(DOMSerializer, [{
	    key: "elt",
	    value: function elt(type, attrs) {
	      var result = this.doc.createElement(type);
	      if (attrs) for (var name in attrs) {
	        if (name == "style") result.style.cssText = attrs[name];else if (attrs[name]) result.setAttribute(name, attrs[name]);
	      }

	      for (var _len = arguments.length, content = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	        content[_key - 2] = arguments[_key];
	      }

	      for (var i = 0; i < content.length; i++) {
	        result.appendChild(typeof content[i] == "string" ? this.doc.createTextNode(content[i]) : content[i]);
	      }return result;
	    }
	  }, {
	    key: "renderNode",
	    value: function renderNode(node, offset) {
	      var dom = node.type.serializeDOM(node, this);
	      if (this.options.onRender) dom = this.options.onRender(node, dom, offset) || dom;
	      return dom;
	    }
	  }, {
	    key: "renderContent",
	    value: function renderContent(node, where) {
	      if (!where) where = this.doc.createDocumentFragment();
	      if (!node.isTextblock) this.renderBlocksInto(node, where);else if (this.options.renderInlineFlat) this.renderInlineFlatInto(node, where);else this.renderInlineInto(node, where);
	      return where;
	    }
	  }, {
	    key: "renderBlocksInto",
	    value: function renderBlocksInto(parent, where) {
	      for (var i = parent.iter(), child; child = i.next().value;) {
	        if (this.options.path) this.options.path.push(i.offset - child.width);
	        where.appendChild(this.renderNode(child, i.offset - child.width));
	        if (this.options.path) this.options.path.pop();
	      }
	    }
	  }, {
	    key: "renderInlineInto",
	    value: function renderInlineInto(parent, where) {
	      var _this = this;

	      var top = where;
	      var active = [];
	      parent.forEach(function (node, offset) {
	        var keep = 0;
	        for (; keep < Math.min(active.length, node.marks.length); ++keep) {
	          if (!node.marks[keep].eq(active[keep])) break;
	        }while (keep < active.length) {
	          active.pop();
	          top = top.parentNode;
	        }
	        while (active.length < node.marks.length) {
	          var add = node.marks[active.length];
	          active.push(add);
	          top = top.appendChild(_this.renderMark(add));
	        }
	        top.appendChild(_this.renderNode(node, offset));
	      });
	    }
	  }, {
	    key: "renderInlineFlatInto",
	    value: function renderInlineFlatInto(parent, where) {
	      var _this2 = this;

	      parent.forEach(function (node, start) {
	        var dom = _this2.renderNode(node, start);
	        dom = _this2.wrapInlineFlat(dom, node.marks);
	        dom = _this2.options.renderInlineFlat(node, dom, start) || dom;
	        where.appendChild(dom);
	      });
	    }
	  }, {
	    key: "renderMark",
	    value: function renderMark(mark) {
	      return mark.type.serializeDOM(mark, this);
	    }
	  }, {
	    key: "wrapInlineFlat",
	    value: function wrapInlineFlat(dom, marks) {
	      for (var i = marks.length - 1; i >= 0; i--) {
	        var wrap = this.renderMark(marks[i]);
	        wrap.appendChild(dom);
	        dom = wrap;
	      }
	      return dom;
	    }

	    // :: (Node, string, ?Object) → DOMNode
	    // Render the content of ProseMirror node into a DOM node with the
	    // given tag name and attributes.

	  }, {
	    key: "renderAs",
	    value: function renderAs(node, tagName, tagAttrs) {
	      var dom = this.renderContent(node, this.elt(tagName, tagAttrs));
	      if (this.options.onContainer) this.options.onContainer(dom);
	      return dom;
	    }
	  }]);

	  return DOMSerializer;
	}();

	// :: (Node, ?Object) → DOMFragment
	// Serialize the content of the given node to a DOM fragment. When not
	// in the browser, the `document` option, containing a DOM document,
	// should be passed so that the serialize can create nodes.
	//
	// To define rendering behavior for your own [node](#NodeType) and
	// [mark](#MarkType) types, give them a `serializeDOM` method. This
	// method is passed a `Node` and a `DOMSerializer`, and should return
	// the [DOM
	// node](https://developer.mozilla.org/en-US/docs/Web/API/Node) that
	// represents this node and its content. For marks, that should be an
	// inline wrapping node like `<a>` or `<strong>`.
	//
	// Individual attributes can also define serialization behavior. If an
	// `Attribute` object has a `serializeDOM` method, that will be called
	// with the DOM node representing the node that the attribute applies
	// to and the atttribute's value, so that it can set additional DOM
	// attributes on the DOM node.

	function toDOM(node, options) {
	  return new DOMSerializer(options).renderContent(node);
	}

	(0, _register.defineTarget)("dom", toDOM);

	// :: (Node, ?Object) → DOMNode
	// Serialize a given node to a DOM node. This is useful when you need
	// to serialize a part of a document, as opposed to the whole
	// document.
	function nodeToDOM(node, options, offset) {
	  var serializer = new DOMSerializer(options);
	  var dom = serializer.renderNode(node, offset);
	  if (node.isInline) {
	    dom = serializer.wrapInlineFlat(dom, node.marks);
	    if (serializer.options.renderInlineFlat) dom = options.renderInlineFlat(node, dom, offset) || dom;
	  }
	  return dom;
	}

	// :: (Node, ?Object) → string
	// Serialize a node as an HTML string. Goes through `toDOM` and then
	// serializes the result. Again, you must pass a `document` option
	// when not in the browser.
	function toHTML(node, options) {
	  var serializer = new DOMSerializer(options);
	  var wrap = serializer.elt("div");
	  wrap.appendChild(serializer.renderContent(node));
	  return wrap.innerHTML;
	}

	(0, _register.defineTarget)("html", toHTML);

	// Block nodes

	function def(cls, method) {
	  cls.prototype.serializeDOM = method;
	}

	def(_model.BlockQuote, function (node, s) {
	  return s.renderAs(node, "blockquote");
	});

	_model.BlockQuote.prototype.countCoordsAsChild = function (_, path, dom, coords) {
	  var childBox = dom.firstChild.getBoundingClientRect();
	  if (coords.left < childBox.left - 2) return _model.Pos.from(path);
	};

	def(_model.BulletList, function (node, s) {
	  return s.renderAs(node, "ul");
	});

	def(_model.OrderedList, function (node, s) {
	  return s.renderAs(node, "ol", { start: node.attrs.order != "1" && node.attrs.order });
	});

	_model.OrderedList.prototype.countCoordsAsChild = _model.BulletList.prototype.countCoordsAsChild = function (_, path, dom, coords) {
	  for (var i = 0; i < dom.childNodes.length; i++) {
	    var child = dom.childNodes[i];
	    if (!child.hasAttribute("pm-offset")) continue;
	    var childBox = child.getBoundingClientRect();
	    if (coords.left > childBox.left - 2) return null;
	    if (childBox.top <= coords.top && childBox.bottom >= coords.top) return new _model.Pos(path, i);
	  }
	};

	def(_model.ListItem, function (node, s) {
	  return s.renderAs(node, "li");
	});

	def(_model.HorizontalRule, function (_, s) {
	  return s.elt("hr");
	});

	def(_model.Paragraph, function (node, s) {
	  return s.renderAs(node, "p");
	});

	def(_model.Heading, function (node, s) {
	  return s.renderAs(node, "h" + node.attrs.level);
	});

	def(_model.CodeBlock, function (node, s) {
	  var code = s.renderAs(node, "code");
	  if (node.attrs.params != null) code.className = "fence " + node.attrs.params.replace(/(^|\s+)/g, "$&lang-");
	  return s.elt("pre", null, code);
	});

	// Inline content

	def(_model.Text, function (node, s) {
	  return s.doc.createTextNode(node.text);
	});

	def(_model.Image, function (node, s) {
	  return s.elt("img", {
	    src: node.attrs.src,
	    alt: node.attrs.alt,
	    title: node.attrs.title
	  });
	});

	def(_model.HardBreak, function (_, s) {
	  return s.elt("br");
	});

	// Inline styles

	def(_model.EmMark, function (_, s) {
	  return s.elt("em");
	});

	def(_model.StrongMark, function (_, s) {
	  return s.elt("strong");
	});

	def(_model.CodeMark, function (_, s) {
	  return s.elt("code");
	});

	def(_model.LinkMark, function (mark, s) {
	  return s.elt("a", { href: mark.attrs.href,
	    title: mark.attrs.title });
	});

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fromText = fromText;

	var _register = __webpack_require__(36);

	// FIXME is it meaningful to try and attach text-parsing information
	// to node types?

	// :: (Schema, string) → Node
	// Convert a string into a simple ProseMirror document.
	function fromText(schema, text) {
	  var blocks = text.trim().split(/\n{2,}/);
	  var nodes = [];
	  for (var i = 0; i < blocks.length; i++) {
	    var spans = [];
	    var parts = blocks[i].split("\n");
	    for (var j = 0; j < parts.length; j++) {
	      if (j) spans.push(schema.node("hard_break"));
	      if (parts[j]) spans.push(schema.text(parts[j]));
	    }
	    nodes.push(schema.node("paragraph", null, spans));
	  }
	  if (!nodes.length) nodes.push(schema.node("paragraph"));
	  return schema.node("doc", null, nodes);
	}

	(0, _register.defineSource)("text", fromText);

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.toText = toText;

	var _model = __webpack_require__(3);

	var _register = __webpack_require__(36);

	_model.Block.prototype.serializeText = function (node) {
	  var accum = "";
	  node.forEach(function (child) {
	    return accum += child.type.serializeText(child);
	  });
	  return accum;
	};

	_model.Textblock.prototype.serializeText = function (node) {
	  var text = _model.Block.prototype.serializeText(node);
	  return text && text + "\n\n";
	};

	_model.Inline.prototype.serializeText = function () {
	  return "";
	};

	_model.HardBreak.prototype.serializeText = function () {
	  return "\n";
	};

	_model.Text.prototype.serializeText = function (node) {
	  return node.text;
	};

	// :: (Node) → string
	// Serialize a node as a plain text string.
	function toText(doc) {
	  return doc.type.serializeText(doc).trim();
	}

	(0, _register.defineTarget)("text", toText);

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.defineOption = defineOption;
	exports.parseOptions = parseOptions;
	exports.initOptions = initOptions;
	exports.setOption = setOption;

	var _model = __webpack_require__(3);

	var _error = __webpack_require__(7);

	var _prompt = __webpack_require__(17);

	var _command = __webpack_require__(42);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Option = function Option(defaultValue, update, updateOnInit) {
	  _classCallCheck(this, Option);

	  this.defaultValue = defaultValue;
	  this.update = update;
	  this.updateOnInit = updateOnInit !== false;
	};

	var options = Object.create(null);

	// :: (string, any, (pm: ProseMirror, newValue: any, oldValue: any, init: bool), bool)
	// Define a new option. The `update` handler will be called with the
	// option's old and new value every time the option is
	// [changed](#ProseMirror.setOption). When `updateOnInit` is true, it
	// is also called on editor init, with null as the old value, and a fourth
	// argument of true.
	function defineOption(name, defaultValue, update, updateOnInit) {
	  options[name] = new Option(defaultValue, update, updateOnInit);
	}

	// :: Schema #path=schema #kind=option
	// The [schema](#Schema) that the editor's document should use.
	defineOption("schema", _model.defaultSchema, false);

	// :: any #path=doc #kind=option
	// The starting document. Usually a `Node`, but can be in another
	// format when the `docFormat` option is also specified.
	defineOption("doc", null, function (pm, value) {
	  return pm.setDoc(value);
	}, false);

	// :: ?string #path=docFormat #kind=option
	// The format in which the `doc` option is given. Defaults to `null`
	// (a raw `Node`).
	defineOption("docFormat", null);

	// :: ?union<DOMNode, (DOMNode)> #path=place #kind=option
	// Determines the placement of the editor in the page. When `null`,
	// the editor is not placed. When a DOM node is given, the editor is
	// appended to that node. When a function is given, it is called
	// with the editor's wrapping DOM node, and is expected to place it
	// into the document.
	defineOption("place", null);

	// :: number #path=historyDepth #kind=option
	// The amount of history events that are collected before the oldest
	// events are discarded. Defaults to 100.
	defineOption("historyDepth", 100);

	// :: number #path=historyEventDelay #kind=option
	// The amount of milliseconds that must pass between changes to
	// start a new history event. Defaults to 500.
	defineOption("historyEventDelay", 500);

	// :: CommandSet #path=commands #kind=option
	// Specifies the set of [commands](#Command) available in the editor
	// (which in turn determines the base key bindings and items available
	// in the menus). Defaults to `CommandSet.default`.
	defineOption("commands", _command.CommandSet.default, _command.updateCommands);

	// :: ParamPrompt #path=commandParamPrompt #kind=option
	// A default [parameter prompting](#ui/prompt) class to use when a
	// command is [executed](#ProseMirror.execCommand) without providing
	// parameters.
	defineOption("commandParamPrompt", _prompt.ParamPrompt);

	// :: ?string #path=label #kind=option
	// The label of the editor. When set, the editable DOM node gets an
	// `aria-label` attribute with this value.
	defineOption("label", null);

	function parseOptions(obj) {
	  var result = Object.create(null);
	  var given = obj ? [obj].concat(obj.use || []) : [];
	  outer: for (var opt in options) {
	    for (var i = 0; i < given.length; i++) {
	      if (opt in given[i]) {
	        result[opt] = given[i][opt];
	        continue outer;
	      }
	    }
	    result[opt] = options[opt].defaultValue;
	  }
	  return result;
	}

	function initOptions(pm) {
	  for (var opt in options) {
	    var desc = options[opt];
	    if (desc.update && desc.updateOnInit) desc.update(pm, pm.options[opt], null, true);
	  }
	}

	function setOption(pm, name, value) {
	  var desc = options[name];
	  if (desc === undefined) _error.AssertionError.raise("Option '" + name + "' is not defined");
	  if (desc.update === false) _error.AssertionError.raise("Option '" + name + "' can not be changed");
	  var old = pm.options[name];
	  pm.options[name] = value;
	  if (desc.update) desc.update(pm, value, old, false);
	}

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CommandSet = exports.Command = undefined;
	exports.updateCommands = updateCommands;
	exports.selectedNodeAttr = selectedNodeAttr;

	var _browserkeymap = __webpack_require__(21);

	var _browserkeymap2 = _interopRequireDefault(_browserkeymap);

	var _model = __webpack_require__(3);

	var _transform = __webpack_require__(22);

	var _dom = __webpack_require__(14);

	var _sortedinsert = __webpack_require__(32);

	var _sortedinsert2 = _interopRequireDefault(_sortedinsert);

	var _error = __webpack_require__(7);

	var _obj = __webpack_require__(11);

	var _base_commands = __webpack_require__(43);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; A command is a named piece of functionality that can be bound to
	// a key, shown in the menu, or otherwise exposed to the user.
	//
	// The commands available in a given editor are determined by the
	// `commands` option. By default, they come from the `baseCommands`
	// object and the commands [registered](#SchemaItem.register) with
	// schema items. Registering a `CommandSpec` on a [node](#NodeType) or
	// [mark](#MarkType) type will cause that command to come into scope
	// in editors whose schema includes that item.

	var Command = exports.Command = function () {
	  function Command(spec, self, name) {
	    _classCallCheck(this, Command);

	    // :: string The name of the command.
	    this.name = name;
	    if (!this.name) _error.NamespaceError.raise("Trying to define a command without a name");
	    // :: CommandSpec The command's specifying object.
	    this.spec = spec;
	    this.self = self;
	  }

	  // :: (ProseMirror, ?[any]) → ?bool
	  // Execute this command. If the command takes
	  // [parameters](#Command.params), they can be passed as second
	  // argument here, or otherwise the user will be prompted for them
	  // using the value of the `commandParamPrompt` option.
	  //
	  // Returns the value returned by the command spec's [`run`
	  // method](#CommandSpec.run), or a `ParamPrompt` instance if the
	  // command is ran asynchronously through a prompt.

	  _createClass(Command, [{
	    key: "exec",
	    value: function exec(pm, params) {
	      var run = this.spec.run;
	      if (!params) {
	        if (!this.params.length) return run.call(this.self, pm);
	        return new pm.options.commandParamPrompt(pm, this).open();
	      } else {
	        if (this.params.length != (params ? params.length : 0)) _error.AssertionError.raise("Invalid amount of parameters for command " + this.name);
	        return run.call.apply(run, [this.self, pm].concat(_toConsumableArray(params)));
	      }
	    }

	    // :: (ProseMirror) → bool
	    // Ask this command whether it is currently relevant, given the
	    // editor's document and selection. If the command does not define a
	    // [`select`](#CommandSpec.select) method, this always returns true.

	  }, {
	    key: "select",
	    value: function select(pm) {
	      var f = this.spec.select;
	      return f ? f.call(this.self, pm) : true;
	    }

	    // :: (ProseMirror) → bool
	    // Ask this command whether it is “active”. This is mostly used to
	    // style inline mark icons (such as strong) differently when the
	    // selection contains such marks.

	  }, {
	    key: "active",
	    value: function active(pm) {
	      var f = this.spec.active;
	      return f ? f.call(this.self, pm) : false;
	    }

	    // :: [CommandParam]
	    // Get the list of parameters that this command expects.

	  }, {
	    key: "params",
	    get: function get() {
	      return this.spec.params || empty;
	    }

	    // :: string
	    // Get the label for this command.

	  }, {
	    key: "label",
	    get: function get() {
	      return this.spec.label || this.name;
	    }
	  }]);

	  return Command;
	}();

	var empty = [];

	function deriveCommandSpec(type, spec, name) {
	  if (!spec.derive) return spec;
	  var conf = _typeof(spec.derive) == "object" ? spec.derive : {};
	  var dname = conf.name || name;
	  var derive = type.constructor.deriveableCommands[dname];
	  if (!derive) _error.AssertionError.raise("Don't know how to derive command " + dname);
	  var derived = derive.call(type, conf);
	  for (var prop in spec) {
	    if (prop != "derive") derived[prop] = spec[prop];
	  }return derived;
	}

	// ;; The type used as the value of the `commands` option. Allows you
	// to specify the set of commands that are available in the editor by
	// adding and modifying command specs.

	var CommandSet = function () {
	  function CommandSet(base, op) {
	    _classCallCheck(this, CommandSet);

	    this.base = base;
	    this.op = op;
	  }

	  // :: (union<Object<CommandSpec>, string>, ?(string, CommandSpec) → bool) → CommandSet
	  // Add a set of commands, creating a new command set. If `set` is
	  // the string `"schema"`, the commands are retrieved from the
	  // editor's schema's [registry](#Schema.registry), otherwise, it
	  // should be an object mapping command names to command specs.
	  //
	  // A filter function can be given to add only the commands for which
	  // the filter returns true.

	  _createClass(CommandSet, [{
	    key: "add",
	    value: function add(set, filter) {
	      return new CommandSet(this, function (commands, schema) {
	        function add(name, spec, self) {
	          if (!filter || filter(name, spec)) {
	            if (commands[name]) _error.AssertionError.raise("Duplicate definition of command " + name);
	            commands[name] = new Command(spec, self, name);
	          }
	        }

	        if (set === "schema") {
	          schema.registry("command", function (name, spec, type, typeName) {
	            add(typeName + ":" + name, deriveCommandSpec(type, spec, name), type);
	          });
	        } else {
	          for (var name in set) {
	            add(name, set[name]);
	          }
	        }
	      });
	    }

	    // :: (Object<?CommandSpec>) → CommandSet
	    // Create a new command set by adding, modifying, or deleting
	    // commands. The `update` object can map a command name to `null` to
	    // delete it, to a full `CommandSpec` (containing a `run` property)
	    // to add it, or to a partial `CommandSpec` (without a `run`
	    // property) to update some properties in the command by that name.

	  }, {
	    key: "update",
	    value: function update(_update) {
	      return new CommandSet(this, function (commands) {
	        for (var name in _update) {
	          var spec = _update[name];
	          if (!spec) {
	            delete commands[name];
	          } else if (spec.run) {
	            commands[name] = new Command(spec, null, name);
	          } else {
	            var known = commands[name];
	            if (known) commands[name] = new Command((0, _obj.copyObj)(spec, (0, _obj.copyObj)(known.spec)), known.self, name);
	          }
	        }
	      });
	    }
	  }, {
	    key: "derive",
	    value: function derive(schema) {
	      var commands = this.base ? this.base.derive(schema) : Object.create(null);
	      this.op(commands, schema);
	      return commands;
	    }
	  }]);

	  return CommandSet;
	}();

	// :: CommandSet
	// A set without any commands.

	exports.CommandSet = CommandSet;
	CommandSet.empty = new CommandSet(null, function () {
	  return null;
	});

	// :: CommandSet
	// The default value of the `commands` option. Includes the [base
	// commands](#baseCommands) and the commands defined by the schema.
	CommandSet.default = CommandSet.empty.add("schema").add(_base_commands.baseCommands);

	// ;; #path=CommandSpec #kind=interface
	// Commands are defined using objects that specify various aspects of
	// the command. The only property that _must_ appear in a command spec
	// is [`run`](#CommandSpec.run). You should probably also give your
	// commands a `label`.

	// :: string #path=CommandSpec.label
	// A user-facing label for the command. This will be used, among other
	// things. as the tooltip title for the command's menu item. If there
	// is no `label`, the command's `name` will be used instead.

	// :: (pm: ProseMirror, ...params: [any]) → ?bool #path=CommandSpec.run
	// The function that executes the command. If the command has
	// [parameters](#CommandSpec.params), their values are passed as
	// arguments. For commands [registered](#SchemaItem.register) on node or
	// mark types, `this` will be bound to the node or mark type when this
	// function is ran. Should return `false` when the command could not
	// be executed.

	// :: [CommandParam] #path=CommandSpec.params
	// The parameters that this command expects.

	// :: (pm: ProseMirror) → bool #path=CommandSpec.select
	// The function used to [select](#Command.select) the command. `this`
	// will again be bound to a node or mark type, when available.

	// :: (pm: ProseMirror) → bool #path=CommandSpec.active
	// The function used to determine whether the command is
	// [active](#Command.active). `this` refers to the associated node or
	// mark type.

	// :: union<string, [string]> #path=CommandSpec.keys
	// The default key bindings for this command. May either be an array
	// of strings containing [key
	// names](https://github.com/marijnh/browserkeymap#a-string-notation-for-key-events),
	// or an object with optional `all`, `mac`, and `pc` properties,
	// specifying arrays of keys for different platforms.

	// :: union<bool, Object> #path=CommandSpec.derive
	// [Mark](#MarkType) and [node](#NodeType) types often need to define
	// boilerplate commands. To reduce the amount of duplicated code, you
	// can derive such commands by setting the `derive` property to either
	// `true` or an object which is passed to the deriving function. If
	// this object has a `name` property, that is used, instead of the
	// command name, to pick a deriving function.
	//
	// For node types, you can derive `"insert"`, `"make"`, and `"wrap"`.
	//
	// For mark types, you can derive `"set"`, `"unset"`, and `"toggle"`.

	// ;; #path=CommandParam #kind=interface
	// The parameters that a command can take are specified using objects
	// with the following properties:

	// :: string #path=CommandParam.label
	// The user-facing name of the parameter. Shown to the user when
	// prompting for this parameter.

	// :: string #path=CommandParam.type
	// The type of the parameter. Supported types are `"text"` and `"select"`.

	// :: any #path=CommandParam.default
	// A default value for the parameter.

	// :: (ProseMirror) → ?any #path=CommandParam.prefill
	// A function that, given an editor instance (and a `this` bound to
	// the command's source item), tries to derive an initial value for
	// the parameter, or return null if it can't.

	// :: (any) → ?string #path=CommandParam.validate
	// An optional function that is called to validate values provided for
	// this parameter. Should return a falsy value when the value is
	// valid, and an error message when it is not.

	function deriveKeymap(pm) {
	  var bindings = {},
	      platform = _dom.browser.mac ? "mac" : "pc";
	  function add(command, keys) {
	    for (var i = 0; i < keys.length; i++) {
	      var _$exec = /^(.+?)(?:\((\d+)\))?$/.exec(keys[i]);

	      var _$exec2 = _slicedToArray(_$exec, 3);

	      var _ = _$exec2[0];
	      var name = _$exec2[1];
	      var _$exec2$ = _$exec2[2];
	      var rank = _$exec2$ === undefined ? 50 : _$exec2$;

	      (0, _sortedinsert2.default)(bindings[name] || (bindings[name] = []), { command: command, rank: rank }, function (a, b) {
	        return a.rank - b.rank;
	      });
	    }
	  }
	  for (var name in pm.commands) {
	    var cmd = pm.commands[name],
	        keys = cmd.spec.keys;
	    if (!keys) continue;
	    if (Array.isArray(keys)) add(cmd, keys);
	    if (keys.all) add(cmd, keys.all);
	    if (keys[platform]) add(cmd, keys[platform]);
	  }

	  for (var key in bindings) {
	    bindings[key] = bindings[key].map(function (b) {
	      return b.command.name;
	    });
	  }return new _browserkeymap2.default(bindings);
	}

	function updateCommands(pm, set) {
	  // :: () #path=ProseMirror#events#commandsChanging
	  // Fired before the set of commands for the editor is updated.
	  pm.signal("commandsChanging");
	  pm.commands = set.derive(pm.schema);
	  pm.input.baseKeymap = deriveKeymap(pm);
	  pm.commandKeys = Object.create(null);
	  // :: () #path=ProseMirror#events#commandsChanged
	  // Fired when the set of commands for the editor is updated.
	  pm.signal("commandsChanged");
	}

	function markActive(pm, type) {
	  var sel = pm.selection;
	  if (sel.empty) return type.isInSet(pm.activeMarks());else return pm.doc.rangeHasMark(sel.from, sel.to, type);
	}

	function canAddInline(pm, type) {
	  var _pm$selection = pm.selection;
	  var from = _pm$selection.from;
	  var to = _pm$selection.to;
	  var empty = _pm$selection.empty;

	  if (empty) return !type.isInSet(pm.activeMarks()) && pm.doc.path(from.path).type.canContainMark(type);
	  var can = false;
	  pm.doc.nodesBetween(from, to, function (node) {
	    if (can || node.isTextblock && !node.type.canContainMark(type)) return false;
	    if (node.isInline && !type.isInSet(node.marks)) can = true;
	  });
	  return can;
	}

	function markApplies(pm, type) {
	  var _pm$selection2 = pm.selection;
	  var from = _pm$selection2.from;
	  var to = _pm$selection2.to;

	  var relevant = false;
	  pm.doc.nodesBetween(from, to, function (node) {
	    if (node.isTextblock) {
	      if (node.type.canContainMark(type)) relevant = true;
	      return false;
	    }
	  });
	  return relevant;
	}

	function selectedMarkAttr(pm, type, attr) {
	  var _pm$selection3 = pm.selection;
	  var from = _pm$selection3.from;
	  var to = _pm$selection3.to;
	  var empty = _pm$selection3.empty;

	  var start = undefined,
	      end = undefined;
	  if (empty) {
	    start = end = type.isInSet(pm.activeMarks());
	  } else {
	    var startParent = pm.doc.path(from.path);
	    var startChunk = startParent.size > from.offset && startParent.chunkAfter(from.offset);
	    start = startChunk ? type.isInSet(startChunk.node.marks) : null;
	    end = type.isInSet(pm.doc.marksAt(to));
	  }
	  if (start && end && start.attrs[attr] == end.attrs[attr]) return start.attrs[attr];
	}

	function selectedNodeAttr(pm, type, name) {
	  var node = pm.selection.node;

	  if (node && node.type == type) return node.attrs[name];
	}

	function deriveParams(type, params) {
	  return params && params.map(function (param) {
	    var attr = type.attrs[param.attr];
	    var obj = { type: "text",
	      default: attr.default,
	      prefill: type instanceof _model.NodeType ? function (pm) {
	        return selectedNodeAttr(pm, this, param.attr);
	      } : function (pm) {
	        return selectedMarkAttr(pm, this, param.attr);
	      } };
	    for (var prop in param) {
	      obj[prop] = param[prop];
	    }return obj;
	  });
	}

	function fillAttrs(conf, givenParams) {
	  var attrs = conf.attrs;
	  if (conf.params) {
	    (function () {
	      var filled = Object.create(null);
	      if (attrs) for (var name in attrs) {
	        filled[name] = attrs[name];
	      }conf.params.forEach(function (param, i) {
	        return filled[param.attr] = givenParams[i];
	      });
	      attrs = filled;
	    })();
	  }
	  return attrs;
	}

	_model.NodeType.deriveableCommands = Object.create(null);
	_model.MarkType.deriveableCommands = Object.create(null);

	_model.MarkType.deriveableCommands.set = function (conf) {
	  return {
	    run: function run(pm) {
	      for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        params[_key - 1] = arguments[_key];
	      }

	      pm.setMark(this, true, fillAttrs(conf, params));
	    },
	    select: function select(pm) {
	      return conf.inverseSelect ? markApplies(pm, this) && !markActive(pm, this) : canAddInline(pm, this);
	    },

	    params: deriveParams(this, conf.params)
	  };
	};

	_model.MarkType.deriveableCommands.unset = function () {
	  return {
	    run: function run(pm) {
	      pm.setMark(this, false);
	    },
	    select: function select(pm) {
	      return markActive(pm, this);
	    }
	  };
	};

	_model.MarkType.deriveableCommands.toggle = function () {
	  return {
	    run: function run(pm) {
	      pm.setMark(this, null);
	    },
	    active: function active(pm) {
	      return markActive(pm, this);
	    },
	    select: function select(pm) {
	      return markApplies(pm, this);
	    }
	  };
	};

	function isAtTopOfListItem(doc, from, to, listType) {
	  return _model.Pos.samePath(from.path, to.path) && from.path.length >= 2 && from.path[from.path.length - 1] == 0 && listType.canContain(doc.path(from.path.slice(0, from.path.length - 1)));
	}

	_model.NodeType.deriveableCommands.wrap = function (conf) {
	  return {
	    run: function run(pm) {
	      var _pm$selection4 = pm.selection;
	      var from = _pm$selection4.from;
	      var to = _pm$selection4.to;
	      var head = _pm$selection4.head;var doJoin = false;
	      if (conf.list && head && isAtTopOfListItem(pm.doc, from, to, this)) {
	        // Don't do anything if this is the top of the list
	        if (from.path[from.path.length - 2] == 0) return false;
	        doJoin = true;
	      }

	      for (var _len2 = arguments.length, params = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        params[_key2 - 1] = arguments[_key2];
	      }

	      var tr = pm.tr.wrap(from, to, this, fillAttrs(conf, params));
	      if (doJoin) tr.join(from.shorten(from.depth - 2));
	      return tr.apply(pm.apply.scroll);
	    },
	    select: function select(pm) {
	      var _pm$selection5 = pm.selection;
	      var from = _pm$selection5.from;
	      var to = _pm$selection5.to;
	      var head = _pm$selection5.head;

	      if (conf.list && head && isAtTopOfListItem(pm.doc, from, to, this) && from.path[from.path.length - 2] == 0) return false;
	      return (0, _transform.canWrap)(pm.doc, from, to, this, conf.attrs);
	    },

	    params: deriveParams(this, conf.params)
	  };
	};

	function alreadyHasBlockType(doc, from, to, type, attrs) {
	  var found = false;
	  if (!attrs) attrs = {};
	  doc.nodesBetween(from, to || from, function (node) {
	    if (node.isTextblock) {
	      if (node.hasMarkup(type, attrs)) found = true;
	      return false;
	    }
	  });
	  return found;
	}

	function activeTextblockIs(pm, type, attrs) {
	  var _pm$selection6 = pm.selection;
	  var from = _pm$selection6.from;
	  var to = _pm$selection6.to;
	  var node = _pm$selection6.node;

	  if (!node || node.isInline) {
	    if (!_model.Pos.samePath(from.path, to.path)) return false;
	    node = pm.doc.path(from.path);
	  } else if (!node.isTextblock) {
	    return false;
	  }
	  return node.hasMarkup(type, attrs);
	}

	_model.NodeType.deriveableCommands.make = function (conf) {
	  return {
	    run: function run(pm) {
	      var _pm$selection7 = pm.selection;
	      var from = _pm$selection7.from;
	      var to = _pm$selection7.to;

	      return pm.tr.setBlockType(from, to, this, conf.attrs).apply(pm.apply.scroll);
	    },
	    select: function select(pm) {
	      var _pm$selection8 = pm.selection;
	      var from = _pm$selection8.from;
	      var to = _pm$selection8.to;
	      var node = _pm$selection8.node;

	      if (node) return node.isTextblock && !node.hasMarkup(this, conf.attrs);else return !alreadyHasBlockType(pm.doc, from, to, this, conf.attrs);
	    },
	    active: function active(pm) {
	      return activeTextblockIs(pm, this, conf.attrs);
	    }
	  };
	};

	_model.NodeType.deriveableCommands.insert = function (conf) {
	  return {
	    run: function run(pm) {
	      for (var _len3 = arguments.length, params = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	        params[_key3 - 1] = arguments[_key3];
	      }

	      return pm.tr.replaceSelection(this.create(fillAttrs(conf, params))).apply(pm.apply.scroll);
	    },

	    select: this.isInline ? function (pm) {
	      return pm.doc.path(pm.selection.from.path).type.canContainType(this);
	    } : null,
	    params: deriveParams(this, conf.params)
	  };
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.baseCommands = undefined;

	var _model = __webpack_require__(3);

	var _transform = __webpack_require__(22);

	var _error = __webpack_require__(7);

	var _char = __webpack_require__(44);

	var _selection = __webpack_require__(45);

	var _dompos = __webpack_require__(46);

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// :: Object<CommandSpec>
	// The set of default commands defined by the core library. They are
	// included in the [default command set](#CommandSet.default).
	var baseCommands = exports.baseCommands = Object.create(null);

	// Get an offset moving backward from a current offset inside a node.
	function moveBackward(parent, offset, by) {
	  if (by != "char" && by != "word") _error.AssertionError.raise("Unknown motion unit: " + by);

	  var cat = null,
	      counted = 0;
	  for (;;) {
	    if (offset == 0) return offset;

	    var _parent$chunkBefore = parent.chunkBefore(offset);

	    var start = _parent$chunkBefore.start;
	    var node = _parent$chunkBefore.node;

	    if (!node.isText) return cat ? offset : offset - 1;

	    if (by == "char") {
	      for (var i = offset - start; i > 0; i--) {
	        if (!(0, _char.isExtendingChar)(node.text.charAt(i - 1))) return offset - 1;
	        offset--;
	      }
	    } else if (by == "word") {
	      // Work from the current position backwards through text of a singular
	      // character category (e.g. "cat" of "#!*") until reaching a character in a
	      // different category (i.e. the end of the word).
	      for (var i = offset - start; i > 0; i--) {
	        var nextCharCat = (0, _char.charCategory)(node.text.charAt(i - 1));
	        if (cat == null || counted == 1 && cat == "space") cat = nextCharCat;else if (cat != nextCharCat) return offset;
	        offset--;
	        counted++;
	      }
	    }
	  }
	}

	// ;; #kind=command
	// Delete the selection, if there is one.
	//
	// **Keybindings:** Backspace, Delete, Mod-Backspace, Mod-Delete,
	// **Ctrl-H (Mac), Alt-Backspace (Mac), Ctrl-D (Mac),
	// **Ctrl-Alt-Backspace (Mac), Alt-Delete (Mac), Alt-D (Mac)
	baseCommands.deleteSelection = {
	  label: "Delete the selection",
	  run: function run(pm) {
	    return pm.tr.replaceSelection().apply(pm.apply.scroll);
	  },

	  keys: {
	    all: ["Backspace(10)", "Delete(10)", "Mod-Backspace(10)", "Mod-Delete(10)"],
	    mac: ["Ctrl-H(10)", "Alt-Backspace(10)", "Ctrl-D(10)", "Ctrl-Alt-Backspace(10)", "Alt-Delete(10)", "Alt-D(10)"]
	  }
	};

	function deleteBarrier(pm, cut) {
	  var around = pm.doc.path(cut.path);
	  var before = around.child(cut.offset - 1),
	      after = around.child(cut.offset);
	  if (before.type.canContainContent(after.type) && pm.tr.join(cut).apply(pm.apply.scroll) !== false) return;

	  var conn = undefined;
	  if (after.isTextblock && (conn = before.type.findConnection(after.type))) {
	    var tr = pm.tr,
	        end = cut.move(1);
	    tr.step("ancestor", cut, end, null, { types: [before.type].concat(_toConsumableArray(conn)),
	      attrs: [before.attrs].concat(_toConsumableArray(conn.map(function () {
	        return null;
	      }))) });
	    tr.join(end);
	    tr.join(cut);
	    if (tr.apply(pm.apply.scroll) !== false) return;
	  }

	  var selAfter = (0, _selection.findSelectionFrom)(pm.doc, cut, 1);
	  return pm.tr.lift(selAfter.from, selAfter.to).apply(pm.apply.scroll);
	}

	// ;; #kind=command
	// If the selection is empty and at the start of a textblock, move
	// that block closer to the block before it, by lifting it out of its
	// parent or, if it has no parent it doesn't share with the node
	// before it, moving it into a parent of that node, or joining it with
	// that.
	//
	// **Keybindings:** Backspace, Mod-Backspace
	baseCommands.joinBackward = {
	  label: "Join with the block above",
	  run: function run(pm) {
	    var _pm$selection = pm.selection;
	    var head = _pm$selection.head;
	    var empty = _pm$selection.empty;

	    if (!empty || head.offset > 0) return false;

	    // Find the node before this one
	    var before = undefined,
	        cut = undefined;
	    for (var i = head.path.length - 1; !before && i >= 0; i--) {
	      if (head.path[i] > 0) {
	        cut = head.shorten(i);
	        before = pm.doc.path(cut.path).child(cut.offset - 1);
	      }
	    } // If there is no node before this, try to lift
	    if (!before) return pm.tr.lift(head).apply(pm.apply.scroll);

	    // If the node doesn't allow children, delete it
	    if (before.type.contains == null) return pm.tr.delete(cut.move(-1), cut).apply(pm.apply.scroll);

	    // Apply the joining algorithm
	    return deleteBarrier(pm, cut);
	  },

	  keys: ["Backspace(30)", "Mod-Backspace(30)"]
	};

	// ;; #kind=command
	// Delete the character before the cursor, if the selection is empty
	// and the cursor isn't at the start of a textblock.
	//
	// **Keybindings:** Backspace, Ctrl-H (Mac)
	baseCommands.deleteCharBefore = {
	  label: "Delete a character before the cursor",
	  run: function run(pm) {
	    var _pm$selection2 = pm.selection;
	    var head = _pm$selection2.head;
	    var empty = _pm$selection2.empty;

	    if (!empty || head.offset == 0) return false;
	    var from = moveBackward(pm.doc.path(head.path), head.offset, "char");
	    return pm.tr.delete(new _model.Pos(head.path, from), head).apply(pm.apply.scroll);
	  },

	  keys: {
	    all: ["Backspace(60)"],
	    mac: ["Ctrl-H(40)"]
	  }
	};

	// ;; #kind=command
	// Delete the word before the cursor, if the selection is empty and
	// the cursor isn't at the start of a textblock.
	//
	// **Keybindings:** Mod-Backspace, Alt-Backspace (Mac)
	baseCommands.deleteWordBefore = {
	  label: "Delete the word before the cursor",
	  run: function run(pm) {
	    var _pm$selection3 = pm.selection;
	    var head = _pm$selection3.head;
	    var empty = _pm$selection3.empty;

	    if (!empty || head.offset == 0) return false;
	    var from = moveBackward(pm.doc.path(head.path), head.offset, "word");
	    return pm.tr.delete(new _model.Pos(head.path, from), head).apply(pm.apply.scroll);
	  },

	  keys: {
	    all: ["Mod-Backspace(40)"],
	    mac: ["Alt-Backspace(40)"]
	  }
	};

	function moveForward(parent, offset, by) {
	  if (by != "char" && by != "word") _error.AssertionError.raise("Unknown motion unit: " + by);

	  var cat = null,
	      counted = 0;
	  for (;;) {
	    if (offset == parent.size) return offset;

	    var _parent$chunkAfter = parent.chunkAfter(offset);

	    var start = _parent$chunkAfter.start;
	    var node = _parent$chunkAfter.node;

	    if (!node.isText) return cat ? offset : offset + 1;

	    if (by == "char") {
	      for (var i = offset - start; i < node.text.length; i++) {
	        if (!(0, _char.isExtendingChar)(node.text.charAt(i + 1))) return offset + 1;
	        offset++;
	      }
	    } else if (by == "word") {
	      for (var i = offset - start; i < node.text.length; i++) {
	        var nextCharCat = (0, _char.charCategory)(node.text.charAt(i));
	        if (cat == null || counted == 1 && cat == "space") cat = nextCharCat;else if (cat != nextCharCat) return offset;
	        offset++;
	        counted++;
	      }
	    }
	  }
	}

	// ;; #kind=command
	// If the selection is empty and the cursor is at the end of a
	// textblock, move the node after it closer to the node with the
	// cursor (lifting it out of parents that aren't shared, moving it
	// into parents of the cursor block, or joining the two when they are
	// siblings).
	//
	// **Keybindings:** Delete, Mod-Delete
	baseCommands.joinForward = {
	  label: "Join with the block below",
	  run: function run(pm) {
	    var _pm$selection4 = pm.selection;
	    var head = _pm$selection4.head;
	    var empty = _pm$selection4.empty;

	    if (!empty || head.offset < pm.doc.path(head.path).size) return false;

	    // Find the node after this one
	    var after = undefined,
	        cut = undefined;
	    for (var i = head.path.length - 1; !after && i >= 0; i--) {
	      cut = head.shorten(i, 1);
	      var parent = pm.doc.path(cut.path);
	      if (cut.offset < parent.size) after = parent.child(cut.offset);
	    }

	    // If there is no node after this, there's nothing to do
	    if (!after) return false;

	    // If the node doesn't allow children, delete it
	    if (after.type.contains == null) return pm.tr.delete(cut, cut.move(1)).apply(pm.apply.scroll);

	    // Apply the joining algorithm
	    return deleteBarrier(pm, cut);
	  },

	  keys: ["Delete(30)", "Mod-Delete(30)"]
	};

	// ;; #kind=command
	// Delete the character after the cursor, if the selection is empty
	// and the cursor isn't at the end of its textblock.
	//
	// **Keybindings:** Delete, Ctrl-D (Mac)
	baseCommands.deleteCharAfter = {
	  label: "Delete a character after the cursor",
	  run: function run(pm) {
	    var _pm$selection5 = pm.selection;
	    var head = _pm$selection5.head;
	    var empty = _pm$selection5.empty;

	    if (!empty || head.offset == pm.doc.path(head.path).size) return false;
	    var to = moveForward(pm.doc.path(head.path), head.offset, "char");
	    return pm.tr.delete(head, new _model.Pos(head.path, to)).apply(pm.apply.scroll);
	  },

	  keys: {
	    all: ["Delete(60)"],
	    mac: ["Ctrl-D(60)"]
	  }
	};

	// ;; #kind=command
	// Delete the word after the cursor, if the selection is empty and the
	// cursor isn't at the end of a textblock.
	//
	// **Keybindings:** Mod-Delete, Ctrl-Alt-Backspace (Mac), Alt-Delete
	// (Mac), Alt-D (Mac)
	baseCommands.deleteWordAfter = {
	  label: "Delete a word after the cursor",
	  run: function run(pm) {
	    var _pm$selection6 = pm.selection;
	    var head = _pm$selection6.head;
	    var empty = _pm$selection6.empty;

	    if (!empty || head.offset == pm.doc.path(head.path).size) return false;
	    var to = moveForward(pm.doc.path(head.path), head.offset, "word");
	    return pm.tr.delete(head, new _model.Pos(head.path, to)).apply(pm.apply.scroll);
	  },

	  keys: {
	    all: ["Mod-Delete(40)"],
	    mac: ["Ctrl-Alt-Backspace(40)", "Alt-Delete(40)", "Alt-D(40)"]
	  }
	};

	function joinPointAbove(pm) {
	  var _pm$selection7 = pm.selection;
	  var node = _pm$selection7.node;
	  var from = _pm$selection7.from;

	  if (node) return (0, _transform.joinableBlocks)(pm.doc, from) ? from : null;else return (0, _transform.joinPoint)(pm.doc, from, -1);
	}

	// ;; #kind=command
	// Join the selected block or, if there is a text selection, the
	// closest ancestor block of the selection that can be joined, with
	// the sibling above it.
	//
	// **Keybindings:** Alt-Up
	baseCommands.joinUp = {
	  label: "Join with above block",
	  run: function run(pm) {
	    var point = joinPointAbove(pm),
	        isNode = pm.selection.node;
	    if (!point) return false;
	    pm.tr.join(point).apply();
	    if (isNode) pm.setNodeSelection(point.move(-1));
	  },
	  select: function select(pm) {
	    return joinPointAbove(pm);
	  },

	  menu: {
	    group: "block", rank: 80,
	    display: {
	      type: "icon",
	      width: 800, height: 900,
	      path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z"
	    }
	  },
	  keys: ["Alt-Up"]
	};

	function joinPointBelow(pm) {
	  var _pm$selection8 = pm.selection;
	  var node = _pm$selection8.node;
	  var to = _pm$selection8.to;

	  if (node) return (0, _transform.joinableBlocks)(pm.doc, to) ? to : null;else return (0, _transform.joinPoint)(pm.doc, to, 1);
	}

	// ;; #kind=command
	// Join the selected block, or the closest ancestor of the selection
	// that can be joined, with the sibling after it.
	//
	// **Keybindings:** Alt-Down
	baseCommands.joinDown = {
	  label: "Join with below block",
	  run: function run(pm) {
	    var node = pm.selection.node;
	    var point = joinPointBelow(pm);
	    if (!point) return false;
	    pm.tr.join(point).apply();
	    if (node) pm.setNodeSelection(point.move(-1));
	  },
	  select: function select(pm) {
	    return joinPointBelow(pm);
	  },

	  keys: ["Alt-Down"]
	};

	// ;; #kind=command
	// Lift the selected block, or the closest ancestor block of the
	// selection that can be lifted, out of its parent node.
	//
	// **Keybindings:** Alt-Left
	baseCommands.lift = {
	  label: "Lift out of enclosing block",
	  run: function run(pm) {
	    var _pm$selection9 = pm.selection;
	    var from = _pm$selection9.from;
	    var to = _pm$selection9.to;

	    return pm.tr.lift(from, to).apply(pm.apply.scroll);
	  },
	  select: function select(pm) {
	    var _pm$selection10 = pm.selection;
	    var from = _pm$selection10.from;
	    var to = _pm$selection10.to;

	    return (0, _transform.canLift)(pm.doc, from, to);
	  },

	  menu: {
	    group: "block", rank: 75,
	    display: {
	      type: "icon",
	      width: 1024, height: 1024,
	      path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z"
	    }
	  },
	  keys: ["Alt-Left"]
	};

	// ;; #kind=command
	// If the selection is in a node whose type has a truthy `isCode`
	// property, replace the selection with a newline character.
	//
	// **Keybindings:** Enter
	baseCommands.newlineInCode = {
	  label: "Insert newline",
	  run: function run(pm) {
	    var _pm$selection11 = pm.selection;
	    var from = _pm$selection11.from;
	    var to = _pm$selection11.to;
	    var node = _pm$selection11.node;var block = undefined;
	    if (!node && _model.Pos.samePath(from.path, to.path) && (block = pm.doc.path(from.path)).type.isCode && to.offset < block.size) return pm.tr.typeText("\n").apply(pm.apply.scroll);else return false;
	  },

	  keys: ["Enter(10)"]
	};

	// ;; #kind=command
	// If a content-less block node is selected, create an empty paragraph
	// before (if it is its parent's first child) or after it.
	//
	// **Keybindings:** Enter
	baseCommands.createParagraphNear = {
	  label: "Create a paragraph near the selected leaf block",
	  run: function run(pm) {
	    var _pm$selection12 = pm.selection;
	    var from = _pm$selection12.from;
	    var to = _pm$selection12.to;
	    var node = _pm$selection12.node;

	    if (!node || !node.isBlock || node.type.contains) return false;
	    var side = from.offset ? to : from;
	    pm.tr.insert(side, pm.schema.defaultTextblockType().create()).apply(pm.apply.scroll);
	    pm.setTextSelection(new _model.Pos(side.toPath(), 0));
	  },

	  keys: ["Enter(20)"]
	};

	// ;; #kind=command
	// If the cursor is in an empty textblock that can be lifted, lift the
	// block.
	//
	// **Keybindings:** Enter
	baseCommands.liftEmptyBlock = {
	  label: "Move current block up",
	  run: function run(pm) {
	    var _pm$selection13 = pm.selection;
	    var head = _pm$selection13.head;
	    var empty = _pm$selection13.empty;

	    if (!empty || head.offset > 0 || pm.doc.path(head.path).size) return false;
	    if (head.depth > 1) {
	      var shorter = head.shorten();
	      if (shorter.offset > 0 && shorter.offset < pm.doc.path(shorter.path).size - 1 && pm.tr.split(shorter).apply() !== false) return;
	    }
	    return pm.tr.lift(head).apply(pm.apply.scroll);
	  },

	  keys: ["Enter(30)"]
	};

	// ;; #kind=command
	// Split the parent block of the selection. If the selection is a text
	// selection, delete it.
	//
	// **Keybindings:** Enter
	baseCommands.splitBlock = {
	  label: "Split the current block",
	  run: function run(pm) {
	    var _pm$selection14 = pm.selection;
	    var from = _pm$selection14.from;
	    var to = _pm$selection14.to;
	    var node = _pm$selection14.node;var block = pm.doc.path(to.path);
	    if (node && node.isBlock) {
	      if (!from.offset) return false;
	      return pm.tr.split(from).apply(pm.apply.scroll);
	    } else {
	      var deflt = pm.schema.defaultTextblockType();
	      var type = to.offset == block.size ? deflt : null;
	      var tr = pm.tr.delete(from, to).split(from, 1, type);
	      if (to.offset < block.size && !from.offset && pm.doc.path(from.path).type != deflt) tr.setNodeType(from.shorten(), deflt);
	      return tr.apply(pm.apply.scroll);
	    }
	  },

	  keys: ["Enter(60)"]
	};

	function nodeAboveSelection(pm) {
	  var sel = pm.selection,
	      i = 0;
	  if (sel.node) return !!sel.from.depth && sel.from.shorten();
	  for (; i < sel.head.depth && i < sel.anchor.depth; i++) {
	    if (sel.head.path[i] != sel.anchor.path[i]) break;
	  }return i == 0 ? false : sel.head.shorten(i - 1);
	}

	// ;; #kind=command
	// Move the selection to the node wrapping the current selection, if
	// any. (Will not select the document node.)
	//
	// **Keybindings:** Esc
	baseCommands.selectParentNode = {
	  label: "Select parent node",
	  run: function run(pm) {
	    var node = nodeAboveSelection(pm);
	    if (!node) return false;
	    pm.setNodeSelection(node);
	  },
	  select: function select(pm) {
	    return nodeAboveSelection(pm);
	  },

	  menu: {
	    group: "block", rank: 90,
	    display: { type: "icon", text: "⬚", style: "font-weight: bold; vertical-align: 20%" }
	  },
	  keys: ["Esc"]
	};

	function moveSelectionBlock(pm, dir) {
	  var _pm$selection15 = pm.selection;
	  var from = _pm$selection15.from;
	  var to = _pm$selection15.to;
	  var node = _pm$selection15.node;

	  var side = dir > 0 ? to : from;
	  return (0, _selection.findSelectionFrom)(pm.doc, node && node.isBlock ? side : side.shorten(null, dir > 0 ? 1 : 0), dir);
	}

	function selectNodeHorizontally(pm, dir) {
	  var _pm$selection16 = pm.selection;
	  var empty = _pm$selection16.empty;
	  var node = _pm$selection16.node;
	  var from = _pm$selection16.from;
	  var to = _pm$selection16.to;

	  if (!empty && !node) return false;

	  if (node && node.isInline) {
	    pm.setTextSelection(dir > 0 ? to : from);
	    return true;
	  }

	  var parent = undefined;
	  if (!node && (parent = pm.doc.path(from.path)) && (dir > 0 ? from.offset < parent.size : from.offset)) {
	    var _ref = dir > 0 ? parent.chunkAfter(from.offset) : parent.chunkBefore(from.offset);

	    var nextNode = _ref.node;
	    var start = _ref.start;

	    if (nextNode.type.selectable && start == from.offset - (dir > 0 ? 0 : 1)) {
	      pm.setNodeSelection(dir < 0 ? from.move(-1) : from);
	      return true;
	    }
	    return false;
	  }

	  var next = moveSelectionBlock(pm, dir);
	  if (next && (next instanceof _selection.NodeSelection || node)) {
	    pm.setSelectionDirect(next);
	    return true;
	  }
	  return false;
	}

	// ;; #kind=command
	// Select the node directly before the cursor, if any.
	//
	// **Keybindings:** Left, Mod-Left
	baseCommands.selectNodeLeft = {
	  label: "Move the selection onto or out of the block to the left",
	  run: function run(pm) {
	    var done = selectNodeHorizontally(pm, -1);
	    if (done) pm.scrollIntoView();
	    return done;
	  },

	  keys: ["Left", "Mod-Left"]
	};

	// ;; #kind=command
	// Select the node directly after the cursor, if any.
	//
	// **Keybindings:** Right, Mod-Right
	baseCommands.selectNodeRight = {
	  label: "Move the selection onto or out of the block to the right",
	  run: function run(pm) {
	    var done = selectNodeHorizontally(pm, 1);
	    if (done) pm.scrollIntoView();
	    return done;
	  },

	  keys: ["Right", "Mod-Right"]
	};

	function selectNodeVertically(pm, dir) {
	  var _pm$selection17 = pm.selection;
	  var empty = _pm$selection17.empty;
	  var node = _pm$selection17.node;
	  var from = _pm$selection17.from;
	  var to = _pm$selection17.to;

	  if (!empty && !node) return false;

	  var leavingTextblock = true;
	  if (!node || node.isInline) leavingTextblock = (0, _selection.verticalMotionLeavesTextblock)(pm, dir > 0 ? to : from, dir);

	  if (leavingTextblock) {
	    var next = moveSelectionBlock(pm, dir);
	    if (next && next instanceof _selection.NodeSelection) {
	      pm.setSelectionDirect(next);
	      if (!node) pm.sel.lastNonNodePos = from;
	      return true;
	    }
	  }

	  if (!node) return false;

	  if (node.isInline) {
	    (0, _dompos.setDOMSelectionToPos)(pm, from);
	    return false;
	  }

	  var last = pm.sel.lastNonNodePos;
	  var beyond = (0, _selection.findSelectionFrom)(pm.doc, dir < 0 ? from : to, dir);
	  if (last && beyond && _model.Pos.samePath(last.path, beyond.from.path)) {
	    (0, _dompos.setDOMSelectionToPos)(pm, last);
	    return false;
	  }
	  pm.setSelectionDirect(beyond);
	  return true;
	}

	// ;; #kind=command
	// Select the node directly above the cursor, if any.
	//
	// **Keybindings:** Up
	baseCommands.selectNodeUp = {
	  label: "Move the selection onto or out of the block above",
	  run: function run(pm) {
	    var done = selectNodeVertically(pm, -1);
	    if (done !== false) pm.scrollIntoView();
	    return done;
	  },

	  keys: ["Up"]
	};

	// ;; #kind=command
	// Select the node directly below the cursor, if any.
	//
	// **Keybindings:** Down
	baseCommands.selectNodeDown = {
	  label: "Move the selection onto or out of the block below",
	  run: function run(pm) {
	    var done = selectNodeVertically(pm, 1);
	    if (done !== false) pm.scrollIntoView();
	    return done;
	  },

	  keys: ["Down"]
	};

	// ;; #kind=command
	// Undo the most recent change event, if any.
	//
	// **Keybindings:** Mod-Z
	baseCommands.undo = {
	  label: "Undo last change",
	  run: function run(pm) {
	    pm.scrollIntoView();return pm.history.undo();
	  },
	  select: function select(pm) {
	    return pm.history.undoDepth > 0;
	  },

	  menu: {
	    group: "history", rank: 10,
	    display: {
	      type: "icon",
	      width: 1024, height: 1024,
	      path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z"
	    }
	  },
	  keys: ["Mod-Z"]
	};

	// ;; #kind=command
	// Redo the most recently undone change event, if any.
	//
	// **Keybindings:** Mod-Y, Shift-Mod-Z
	baseCommands.redo = {
	  label: "Redo last undone change",
	  run: function run(pm) {
	    pm.scrollIntoView();return pm.history.redo();
	  },
	  select: function select(pm) {
	    return pm.history.redoDepth > 0;
	  },

	  menu: {
	    group: "history", rank: 20,
	    display: {
	      type: "icon",
	      width: 1024, height: 1024,
	      path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z"
	    }
	  },
	  keys: ["Mod-Y", "Shift-Mod-Z"]
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isWordChar = isWordChar;
	exports.charCategory = charCategory;
	exports.isExtendingChar = isExtendingChar;
	var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

	// Extending unicode characters. A series of a non-extending char +
	// any number of extending chars is treated as a single unit as far
	// as editing and measuring is concerned. This is not fully correct,
	// since some scripts/fonts/browsers also treat other configurations
	// of code points as a group.
	var extendingChar = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

	function isWordChar(ch) {
	  return (/\w/.test(ch) || isExtendingChar(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
	  );
	}

	// Get the category of a given character. Either a "space",
	// a character that can be part of a word ("word"), or anything else ("other").
	function charCategory(ch) {
	  return (/\s/.test(ch) ? "space" : isWordChar(ch) ? "word" : "other"
	  );
	}

	function isExtendingChar(ch) {
	  return ch.charCodeAt(0) >= 768 && extendingChar.test(ch);
	}

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NodeSelection = exports.TextSelection = exports.Selection = exports.SelectionState = exports.SelectionError = undefined;
	exports.rangeFromDOMLoose = rangeFromDOMLoose;
	exports.hasFocus = hasFocus;
	exports.findSelectionFrom = findSelectionFrom;
	exports.findSelectionNear = findSelectionNear;
	exports.findSelectionAtStart = findSelectionAtStart;
	exports.findSelectionAtEnd = findSelectionAtEnd;
	exports.verticalMotionLeavesTextblock = verticalMotionLeavesTextblock;

	var _model = __webpack_require__(3);

	var _error = __webpack_require__(7);

	var _dom = __webpack_require__(14);

	var _dompos = __webpack_require__(46);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// ;; Error type used to signal selection-related problems.

	var SelectionError = exports.SelectionError = function (_ProseMirrorError) {
	  _inherits(SelectionError, _ProseMirrorError);

	  function SelectionError() {
	    _classCallCheck(this, SelectionError);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(SelectionError).apply(this, arguments));
	  }

	  return SelectionError;
	}(_error.ProseMirrorError);

	var SelectionState = exports.SelectionState = function () {
	  function SelectionState(pm, range) {
	    var _this2 = this;

	    _classCallCheck(this, SelectionState);

	    this.pm = pm;
	    this.range = range;

	    this.lastNonNodePos = null;
	    this.lastFocusTime = this.lastFastPollTime = 0;

	    this.polling = null;
	    this.lastAnchorNode = this.lastHeadNode = this.lastAnchorOffset = this.lastHeadOffset = null;
	    this.lastNode = null;

	    pm.content.addEventListener("focus", function () {
	      return _this2.receivedFocus();
	    });
	    this.poller = this.poller.bind(this);
	  }

	  _createClass(SelectionState, [{
	    key: "setAndSignal",
	    value: function setAndSignal(range, clearLast) {
	      this.set(range, clearLast);
	      // :: () #path=ProseMirror#events#selectionChange
	      // Indicates that the editor's selection has changed.
	      this.pm.signal("selectionChange");
	    }
	  }, {
	    key: "set",
	    value: function set(range, clearLast) {
	      this.range = range;
	      if (!range.node) this.lastNonNodePos = null;
	      if (clearLast !== false) this.lastAnchorNode = null;
	    }
	  }, {
	    key: "poller",
	    value: function poller() {
	      if (hasFocus(this.pm)) {
	        if (!this.pm.operation) this.readFromDOM();
	        this.polling = setTimeout(this.poller, 100);
	      } else {
	        this.polling = null;
	      }
	    }
	  }, {
	    key: "startPolling",
	    value: function startPolling() {
	      clearTimeout(this.polling);
	      this.polling = setTimeout(this.poller, 50);
	    }
	  }, {
	    key: "fastPoll",
	    value: function fastPoll() {
	      this.lastFastPollTime = Date.now();
	      this.startPolling();
	    }
	  }, {
	    key: "stopPolling",
	    value: function stopPolling() {
	      clearTimeout(this.polling);
	      this.polling = null;
	    }
	  }, {
	    key: "domChanged",
	    value: function domChanged() {
	      var sel = window.getSelection();
	      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastHeadNode || sel.focusOffset != this.lastHeadOffset;
	    }
	  }, {
	    key: "storeDOMState",
	    value: function storeDOMState() {
	      var sel = window.getSelection();
	      this.lastAnchorNode = sel.anchorNode;this.lastAnchorOffset = sel.anchorOffset;
	      this.lastHeadNode = sel.focusNode;this.lastHeadOffset = sel.focusOffset;
	    }
	  }, {
	    key: "readFromDOM",
	    value: function readFromDOM() {
	      if (this.pm.input.composing || !hasFocus(this.pm) || !this.domChanged()) return false;

	      var sel = window.getSelection(),
	          doc = this.pm.doc;
	      var anchor = (0, _dompos.posFromDOM)(this.pm, sel.anchorNode, sel.anchorOffset);
	      var head = sel.isCollapsed ? anchor : (0, _dompos.posFromDOM)(this.pm, sel.focusNode, sel.focusOffset);

	      // Ignore selection changes that look like 'selection resets',
	      // caused by some browsers when an editable element is focused but
	      // does not have the selection (as happens for node selections),
	      // for example when the page gains focus.
	      //
	      // If we have a node selection, were recently focused, did not
	      // recently fast-poll, and have a collapsed selection at the start
	      // of the document, ignore it and reset to our stored selection.
	      if (this.range.node && sel.isCollapsed && this.lastFocusTime > Date.now() - 100 && this.lastFastPollTime < Date.now() - 100) {
	        var minPos = findSelectionAtStart(this.pm.doc, undefined, true);
	        if (minPos && anchor.cmp(minPos.anchor) == 0) return this.toDOM();
	      }

	      var newRange = findSelectionNear(doc, head, this.range.head && this.range.head.cmp(head) < 0 ? -1 : 1);
	      if (newRange instanceof TextSelection && doc.path(anchor.path).isTextblock) newRange = new TextSelection(anchor, newRange.head);
	      this.setAndSignal(newRange);

	      if (newRange instanceof NodeSelection || newRange.head.cmp(head) || newRange.anchor.cmp(anchor)) {
	        this.toDOM();
	      } else {
	        this.clearNode();
	        this.storeDOMState();
	      }
	      return true;
	    }
	  }, {
	    key: "toDOM",
	    value: function toDOM(takeFocus) {
	      if (this.range instanceof NodeSelection) this.nodeToDOM(takeFocus);else this.rangeToDOM(takeFocus);
	    }
	  }, {
	    key: "nodeToDOM",
	    value: function nodeToDOM(takeFocus) {
	      window.getSelection().removeAllRanges();
	      if (takeFocus) this.pm.content.focus();
	      var dom = (0, _dompos.pathToDOM)(this.pm.content, this.range.from.toPath());
	      if (dom != this.lastNode) {
	        this.clearNode();
	        dom.classList.add("ProseMirror-selectednode");
	        this.lastNode = dom;
	      }
	    }
	  }, {
	    key: "clearNode",
	    value: function clearNode() {
	      if (this.lastNode) {
	        this.lastNode.classList.remove("ProseMirror-selectednode");
	        this.lastNode = null;
	        return true;
	      }
	    }
	  }, {
	    key: "rangeToDOM",
	    value: function rangeToDOM(takeFocus) {
	      if (!this.clearNode() && !hasFocus(this.pm)) {
	        if (!takeFocus) return;
	        // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444
	        else if (_dom.browser.gecko) this.pm.content.focus();
	      }
	      if (!this.domChanged()) return;

	      var content = this.pm.content;
	      var anchor = (0, _dompos.DOMFromPos)(content, this.range.anchor);
	      var head = (0, _dompos.DOMFromPos)(content, this.range.head);

	      var sel = window.getSelection(),
	          range = document.createRange();
	      if (sel.extend) {
	        range.setEnd(anchor.node, anchor.offset);
	        range.collapse(false);
	      } else {
	        if (this.range.anchor.cmp(this.range.head) > 0) {
	          var tmp = anchor;anchor = head;head = tmp;
	        }
	        range.setEnd(head.node, head.offset);
	        range.setStart(anchor.node, anchor.offset);
	      }
	      sel.removeAllRanges();
	      sel.addRange(range);
	      if (sel.extend) sel.extend(head.node, head.offset);
	      this.storeDOMState();
	    }
	  }, {
	    key: "receivedFocus",
	    value: function receivedFocus() {
	      this.lastFocusTime = Date.now();
	      if (this.polling == null) this.startPolling();
	    }
	  }]);

	  return SelectionState;
	}();

	// ;; An editor selection. Can be one of two selection types:
	// `TextSelection` and `NodeSelection`. Both have the properties
	// listed here, but also contain more information (such as the
	// selected [node](#NodeSelection.node) or the
	// [head](#TextSelection.head) and [anchor](#TextSelection.anchor)).

	var Selection = exports.Selection = function Selection() {
	  _classCallCheck(this, Selection);
	};

	// :: Pos #path=Selection.prototype.from
	// The start of the selection.

	// :: Pos #path=Selection.prototype.to
	// The end of the selection.

	// :: bool #path=Selection.empty
	// True if the selection is an empty text selection (head an anchor
	// are the same).

	// :: (other: Selection) → bool #path=Selection.eq
	// Test whether the selection is the same as another selection.

	// :: (doc: Node, mapping: Mappable) → Selection #path=Selection.map
	// Map this selection through a [mappable](#Mappable) thing. `doc`
	// should be the new document, to which we are mapping.

	// ;; A text selection represents a classical editor
	// selection, with a head (the moving side) and anchor (immobile
	// side), both of which point into textblock nodes. It can be empty (a
	// regular cursor position).

	var TextSelection = exports.TextSelection = function (_Selection) {
	  _inherits(TextSelection, _Selection);

	  // :: (Pos, ?Pos)
	  // Construct a text selection. When `head` is not given, it defaults
	  // to `anchor`.

	  function TextSelection(anchor, head) {
	    _classCallCheck(this, TextSelection);

	    // :: Pos
	    // The selection's immobile side (does not move when pressing
	    // shift-arrow).

	    var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(TextSelection).call(this));

	    _this3.anchor = anchor;
	    // :: Pos
	    // The selection's mobile side (the side that moves when pressing
	    // shift-arrow).
	    _this3.head = head || anchor;
	    return _this3;
	  }

	  _createClass(TextSelection, [{
	    key: "eq",
	    value: function eq(other) {
	      return other instanceof TextSelection && !other.head.cmp(this.head) && !other.anchor.cmp(this.anchor);
	    }
	  }, {
	    key: "map",
	    value: function map(doc, mapping) {
	      var head = mapping.map(this.head).pos;
	      if (!doc.path(head.path).isTextblock) return findSelectionNear(doc, head);
	      var anchor = mapping.map(this.anchor).pos;
	      return new TextSelection(doc.path(anchor.path).isTextblock ? anchor : head, head);
	    }
	  }, {
	    key: "inverted",
	    get: function get() {
	      return this.anchor.cmp(this.head) > 0;
	    }
	  }, {
	    key: "from",
	    get: function get() {
	      return this.inverted ? this.head : this.anchor;
	    }
	  }, {
	    key: "to",
	    get: function get() {
	      return this.inverted ? this.anchor : this.head;
	    }
	  }, {
	    key: "empty",
	    get: function get() {
	      return this.anchor.cmp(this.head) == 0;
	    }
	  }]);

	  return TextSelection;
	}(Selection);

	// ;; A node selection is a selection that points at a
	// single node. All nodes marked [selectable](#NodeType.selectable)
	// can be the target of a node selection. In such an object, `from`
	// and `to` point directly before and after the selected node.

	var NodeSelection = exports.NodeSelection = function (_Selection2) {
	  _inherits(NodeSelection, _Selection2);

	  // :: (Pos, Pos, Node)
	  // Create a node selection. Does not verify the validity of its
	  // arguments. Use `ProseMirror.setNodeSelection` for an easier,
	  // error-checking way to create a node selection.

	  function NodeSelection(from, to, node) {
	    _classCallCheck(this, NodeSelection);

	    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(NodeSelection).call(this));

	    _this4.from = from;
	    _this4.to = to;
	    // :: Node The selected node.
	    _this4.node = node;
	    return _this4;
	  }

	  _createClass(NodeSelection, [{
	    key: "eq",
	    value: function eq(other) {
	      return other instanceof NodeSelection && !this.from.cmp(other.from);
	    }
	  }, {
	    key: "map",
	    value: function map(doc, mapping) {
	      var from = mapping.map(this.from, 1).pos;
	      var to = mapping.map(this.to, -1).pos;
	      if (_model.Pos.samePath(from.path, to.path) && from.offset == to.offset - 1) {
	        var node = doc.nodeAfter(from);
	        if (node.type.selectable) return new NodeSelection(from, to, node);
	      }
	      return findSelectionNear(doc, from);
	    }
	  }, {
	    key: "empty",
	    get: function get() {
	      return false;
	    }
	  }]);

	  return NodeSelection;
	}(Selection);

	function rangeFromDOMLoose(pm) {
	  if (!hasFocus(pm)) return null;
	  var sel = window.getSelection();
	  return new TextSelection((0, _dompos.posFromDOM)(pm, sel.anchorNode, sel.anchorOffset, true), (0, _dompos.posFromDOM)(pm, sel.focusNode, sel.focusOffset, true));
	}

	function hasFocus(pm) {
	  var sel = window.getSelection();
	  return sel.rangeCount && (0, _dom.contains)(pm.content, sel.anchorNode);
	}

	function findSelectionIn(doc, path, offset, dir, text) {
	  var node = doc.path(path);
	  if (node.isTextblock) return new TextSelection(new _model.Pos(path, offset));

	  for (var i = offset + (dir > 0 ? 0 : -1); dir > 0 ? i < node.size : i >= 0; i += dir) {
	    var child = node.child(i);
	    if (!text && child.type.contains == null && child.type.selectable) return new NodeSelection(new _model.Pos(path, i), new _model.Pos(path, i + 1), child);
	    path.push(i);
	    var inside = findSelectionIn(doc, path, dir < 0 ? child.size : 0, dir, text);
	    if (inside) return inside;
	    path.pop();
	  }
	}

	// FIXME we'll need some awareness of bidi motion when determining block start and end

	function findSelectionFrom(doc, pos, dir, text) {
	  for (var path = pos.path.slice(), offset = pos.offset;;) {
	    var found = findSelectionIn(doc, path, offset, dir, text);
	    if (found) return found;
	    if (!path.length) break;
	    offset = path.pop() + (dir > 0 ? 1 : 0);
	  }
	}

	function findSelectionNear(doc, pos) {
	  var bias = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
	  var text = arguments[3];

	  var result = findSelectionFrom(doc, pos, bias, text) || findSelectionFrom(doc, pos, -bias, text);
	  if (!result) SelectionError("Searching for selection in invalid document " + doc);
	  return result;
	}

	function findSelectionAtStart(node) {
	  var path = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	  var text = arguments[2];

	  return findSelectionIn(node, path.slice(), 0, 1, text);
	}

	function findSelectionAtEnd(node) {
	  var path = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	  var text = arguments[2];

	  return findSelectionIn(node, path.slice(), node.size, -1, text);
	}

	function verticalMotionLeavesTextblock(pm, pos, dir) {
	  var dom = (0, _dompos.pathToDOM)(pm.content, pos.path);
	  var coords = (0, _dompos.coordsAtPos)(pm, pos);
	  for (var child = dom.firstChild; child; child = child.nextSibling) {
	    if (child.nodeType != 1) continue;
	    var boxes = child.getClientRects();
	    for (var i = 0; i < boxes.length; i++) {
	      var box = boxes[i];
	      if (dir < 0 ? box.bottom < coords.top : box.top > coords.bottom) return false;
	    }
	  }
	  return true;
	}

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.pathFromDOM = pathFromDOM;
	exports.widthFromDOM = widthFromDOM;
	exports.posFromDOM = posFromDOM;
	exports.findByPath = findByPath;
	exports.pathToDOM = pathToDOM;
	exports.childContainer = childContainer;
	exports.DOMFromPos = DOMFromPos;
	exports.scrollIntoView = scrollIntoView;
	exports.posAtCoords = posAtCoords;
	exports.coordsAtPos = coordsAtPos;
	exports.setDOMSelectionToPos = setDOMSelectionToPos;
	exports.selectableNodeAbove = selectableNodeAbove;
	exports.handleNodeClick = handleNodeClick;

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _error = __webpack_require__(7);

	function pathFromDOM(pm, node) {
	  var path = [];
	  for (; node != pm.content;) {
	    var attr = node.getAttribute("pm-offset");
	    if (attr) path.unshift(+attr);
	    node = node.parentNode;
	  }
	  return path;
	}

	function widthFromDOM(dom) {
	  var attr = dom.getAttribute("pm-leaf");
	  return attr && attr != "true" ? +attr : 1;
	}

	function posFromDOM(pm, dom, domOffset, loose) {
	  if (!loose && pm.operation && pm.doc != pm.operation.doc) _error.AssertionError.raise("Fetching a position from an outdated DOM structure");

	  if (domOffset == null) {
	    domOffset = Array.prototype.indexOf.call(dom.parentNode.childNodes, dom);
	    dom = dom.parentNode;
	  }

	  var extraOffset = 0,
	      tag = undefined;
	  for (;;) {
	    var adjust = 0;
	    if (dom.nodeType == 3) {
	      extraOffset += domOffset;
	    } else if (dom.hasAttribute("pm-container")) {
	      break;
	    } else if (tag = dom.getAttribute("pm-inner-offset")) {
	      extraOffset += +tag;
	      adjust = -1;
	    } else if (domOffset && domOffset == dom.childNodes.length) {
	      adjust = 1;
	    }

	    var parent = dom.parentNode;
	    domOffset = adjust < 0 ? 0 : Array.prototype.indexOf.call(parent.childNodes, dom) + adjust;
	    dom = parent;
	  }

	  var path = pathFromDOM(pm, dom);
	  if (dom.hasAttribute("pm-leaf")) return _model.Pos.from(path, extraOffset + (domOffset ? 1 : 0));

	  var offset = 0;
	  for (var i = domOffset - 1; i >= 0; i--) {
	    var child = dom.childNodes[i];
	    if (child.nodeType == 3) {
	      if (loose) extraOffset += child.nodeValue.length;
	    } else if (tag = child.getAttribute("pm-offset")) {
	      offset = +tag + widthFromDOM(child);
	      break;
	    } else if (loose && !child.hasAttribute("pm-ignore")) {
	      extraOffset += child.textContent.length;
	    }
	  }
	  return new _model.Pos(path, offset + extraOffset);
	}

	function findByPath(node, n, fromEnd) {
	  var container = childContainer(node);
	  for (var ch = fromEnd ? container.lastChild : container.firstChild; ch; ch = fromEnd ? ch.previousSibling : ch.nextSibling) {
	    if (ch.nodeType != 1) continue;
	    var offset = ch.getAttribute("pm-offset");
	    if (offset && +offset == n) return ch;
	  }
	}

	function pathToDOM(parent, path) {
	  var node = parent;
	  for (var i = 0; i < path.length; i++) {
	    node = findByPath(node, path[i]);
	    if (!node) _error.AssertionError.raise("Failed to resolve path " + path.join("/"));
	  }
	  return node;
	}

	function childContainer(dom) {
	  return dom.hasAttribute("pm-container") ? dom : dom.querySelector("[pm-container]");
	}

	function findByOffset(node, offset, after) {
	  for (var ch = node.firstChild, i = 0, attr; ch; ch = ch.nextSibling, i++) {
	    if (ch.nodeType == 1 && (attr = ch.getAttribute("pm-offset"))) {
	      var diff = offset - +attr,
	          width = widthFromDOM(ch);
	      if (diff >= 0 && (after ? diff <= width : diff < width)) return { node: ch, offset: i, innerOffset: diff };
	    }
	  }
	}

	function leafAt(node, offset) {
	  for (;;) {
	    var child = node.firstChild;
	    if (!child) return { node: node, offset: offset };
	    if (child.nodeType != 1) return { node: child, offset: offset };
	    if (child.hasAttribute("pm-inner-offset")) {
	      var nodeOffset = 0;
	      for (;;) {
	        var nextSib = child.nextSibling,
	            nextOffset = undefined;
	        if (!nextSib || (nextOffset = +nextSib.getAttribute("pm-inner-offset")) >= offset) break;
	        child = nextSib;
	        nodeOffset = nextOffset;
	      }
	      offset -= nodeOffset;
	    }
	    node = child;
	  }
	}

	// Get a DOM element at a given position in the document.
	function DOMFromPos(parent, pos) {
	  var dom = childContainer(pathToDOM(parent, pos.path));
	  var found = findByOffset(dom, pos.offset, true),
	      inner = undefined;
	  if (!found) return { node: dom, offset: 0 };
	  if (found.node.getAttribute("pm-leaf") == "true" || !(inner = leafAt(found.node, found.innerOffset))) return { node: found.node.parentNode, offset: found.offset + (found.innerOffset ? 1 : 0) };else return inner;
	}

	function windowRect() {
	  return { left: 0, right: window.innerWidth,
	    top: 0, bottom: window.innerHeight };
	}

	var scrollMargin = 5;

	function scrollIntoView(pm, pos) {
	  if (!pos) pos = pm.sel.range.head || pm.sel.range.from;
	  var coords = coordsAtPos(pm, pos);
	  for (var parent = pm.content;; parent = parent.parentNode) {
	    var atBody = parent == document.body;
	    var rect = atBody ? windowRect() : parent.getBoundingClientRect();
	    var moveX = 0,
	        moveY = 0;
	    if (coords.top < rect.top) moveY = -(rect.top - coords.top + scrollMargin);else if (coords.bottom > rect.bottom) moveY = coords.bottom - rect.bottom + scrollMargin;
	    if (coords.left < rect.left) moveX = -(rect.left - coords.left + scrollMargin);else if (coords.right > rect.right) moveX = coords.right - rect.right + scrollMargin;
	    if (moveX || moveY) {
	      if (atBody) window.scrollBy(moveX, moveY);
	    } else {
	      if (moveY) parent.scrollTop += moveY;
	      if (moveX) parent.scrollLeft += moveX;
	    }
	    if (atBody) break;
	  }
	}

	function findOffsetInNode(node, coords) {
	  var closest = undefined,
	      dyClosest = 1e8,
	      coordsClosest = undefined,
	      offset = 0;
	  for (var child = node.firstChild, i = 0; child; child = child.nextSibling, i++) {
	    var rects = undefined;
	    if (child.nodeType == 1) rects = child.getClientRects();else if (child.nodeType == 3) rects = textRects(child);else continue;

	    for (var _i = 0; _i < rects.length; _i++) {
	      var rect = rects[_i];
	      if (rect.left <= coords.left && rect.right >= coords.left) {
	        var dy = rect.top > coords.top ? rect.top - coords.top : rect.bottom < coords.top ? coords.top - rect.bottom : 0;
	        if (dy < dyClosest) {
	          // FIXME does not group by row
	          closest = child;
	          dyClosest = dy;
	          coordsClosest = dy ? { left: coords.left, top: rect.top } : coords;
	          if (child.nodeType == 1 && !child.firstChild) offset = _i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
	          continue;
	        }
	      }
	      if (!closest && (coords.top >= rect.bottom || coords.top >= rect.top && coords.left >= rect.right)) offset = _i + 1;
	    }
	  }
	  if (!closest) return { node: node, offset: offset };
	  if (closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);
	  if (closest.firstChild) return findOffsetInNode(closest, coordsClosest);
	  return { node: node, offset: offset };
	}

	function findOffsetInText(node, coords) {
	  var len = node.nodeValue.length;
	  var range = document.createRange();
	  for (var i = 0; i < len; i++) {
	    range.setEnd(node, i + 1);
	    range.setStart(node, i);
	    var rect = range.getBoundingClientRect();
	    if (rect.top == rect.bottom) continue;
	    if (rect.left <= coords.left && rect.right >= coords.left && rect.top <= coords.top && rect.bottom >= coords.top) return { node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
	  }
	  return { node: node, offset: 0 };
	}

	// Given an x,y position on the editor, get the position in the document.
	function posAtCoords(pm, coords) {
	  var elt = document.elementFromPoint(coords.left, coords.top + 1);
	  if (!(0, _dom.contains)(pm.content, elt)) return null;

	  if (!elt.firstChild) elt = elt.parentNode;

	  var _findOffsetInNode = findOffsetInNode(elt, coords);

	  var node = _findOffsetInNode.node;
	  var offset = _findOffsetInNode.offset;

	  return posFromDOM(pm, node, offset);
	}

	function textRect(node, from, to) {
	  var range = document.createRange();
	  range.setEnd(node, to);
	  range.setStart(node, from);
	  return range.getBoundingClientRect();
	}

	function textRects(node) {
	  var range = document.createRange();
	  range.setEnd(node, node.nodeValue.length);
	  range.setStart(node, 0);
	  return range.getClientRects();
	}

	// Given a position in the document model, get a bounding box of the character at
	// that position, relative to the window.
	function coordsAtPos(pm, pos) {
	  var _DOMFromPos = DOMFromPos(pm.content, pos);

	  var node = _DOMFromPos.node;
	  var offset = _DOMFromPos.offset;

	  var side = undefined,
	      rect = undefined;
	  if (node.nodeType == 3) {
	    if (offset < node.nodeValue.length) {
	      rect = textRect(node, offset, offset + 1);
	      side = "left";
	    }
	    if ((!rect || rect.left == rect.right) && offset) {
	      rect = textRect(node, offset - 1, offset);
	      side = "right";
	    }
	  } else if (node.firstChild) {
	    if (offset < node.childNodes.length) {
	      var child = node.childNodes[offset];
	      rect = child.nodeType == 3 ? textRect(child, 0, child.nodeValue.length) : child.getBoundingClientRect();
	      side = "left";
	    }
	    if ((!rect || rect.left == rect.right) && offset) {
	      var child = node.childNodes[offset - 1];
	      rect = child.nodeType == 3 ? textRect(child, 0, child.nodeValue.length) : child.getBoundingClientRect();
	      side = "right";
	    }
	  } else {
	    rect = node.getBoundingClientRect();
	    side = "left";
	  }
	  var x = rect[side];
	  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
	}

	function setDOMSelectionToPos(pm, pos) {
	  var _DOMFromPos2 = DOMFromPos(pm.content, pos);

	  var node = _DOMFromPos2.node;
	  var offset = _DOMFromPos2.offset;

	  var range = document.createRange();
	  range.setEnd(node, offset);
	  range.setStart(node, offset);
	  var sel = window.getSelection();
	  sel.removeAllRanges();
	  sel.addRange(range);
	}

	// ;; #path=NodeType #kind=class #noAnchor
	// You can add several properties to [node types](#NodeType) to
	// influence the way the editor interacts with them.

	// :: (node: Node, path: [number], dom: DOMNode, coords: {left: number, top: number}) → ?Pos
	// #path=NodeType.prototype.countCoordsAsChild
	// Specifies that, if this node is clicked, a child node might
	// actually be meant. This is used to, for example, make clicking a
	// list marker (which, in the DOM, is part of the list node) select
	// the list item it belongs to. Should return null if the given
	// coordinates don't refer to a child node, or the [position](#Pos)
	// before the child otherwise.

	function selectableNodeAbove(pm, dom, coords, liberal) {
	  for (; dom && dom != pm.content; dom = dom.parentNode) {
	    if (dom.hasAttribute("pm-offset")) {
	      var path = pathFromDOM(pm, dom),
	          node = pm.doc.path(path);
	      if (node.type.countCoordsAsChild) {
	        var result = node.type.countCoordsAsChild(node, path, dom, coords);
	        if (result) return result;
	      }
	      // Leaf nodes are implicitly clickable
	      if ((liberal || node.type.contains == null) && node.type.selectable) return _model.Pos.from(path);
	      if (!liberal) return null;
	    }
	  }
	}

	// :: (pm: ProseMirror, event: MouseEvent, path: [number], node: Node) → bool
	// #path=NodeType.prototype.handleClick
	// If a node is directly clicked (that is, the click didn't land in a
	// DOM node belonging to a child node), and its type has a
	// `handleClick` method, that method is given a chance to handle the
	// click. The method is called, and should return `false` if it did
	// _not_ handle the click.
	//
	// The `event` passed is the event for `"mousedown"`, but calling
	// `preventDefault` on it has no effect, since this method is only
	// called after a corresponding `"mouseup"` has occurred and
	// ProseMirror has determined that this is not a drag or multi-click
	// event.

	// :: (pm: ProseMirror, event: MouseEvent, path: [number], node: Node) → bool
	// #path=NodeType.prototype.handleContextMenu
	//
	// When the [context
	// menu](https://developer.mozilla.org/en-US/docs/Web/Events/contextmenu)
	// is activated in the editable context, nodes that the clicked
	// position falls inside of get a chance to react to it. Node types
	// may define a `handleContextMenu` method, which will be called when
	// present, first on inner nodes and then up the document tree, until
	// one of the methods returns something other than `false`.
	//
	// The handlers can inspect `event.target` to figure out whether they
	// were directly clicked, and may call `event.preventDefault()` to
	// prevent the native context menu.

	function handleNodeClick(pm, type, event, direct) {
	  for (var dom = event.target; dom && dom != pm.content; dom = dom.parentNode) {
	    if (dom.hasAttribute("pm-offset")) {
	      var path = pathFromDOM(pm, dom),
	          node = pm.doc.path(path);
	      var handled = node.type[type] && node.type[type](pm, event, path, node) !== false;
	      if (direct || handled) return handled;
	    }
	  }
	}

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.draw = draw;
	exports.redraw = redraw;

	var _model = __webpack_require__(3);

	var _format = __webpack_require__(35);

	var _dom = __webpack_require__(14);

	var _main = __webpack_require__(19);

	var _dompos = __webpack_require__(46);

	// FIXME clean up threading of path and offset, maybe remove from DOM renderer entirely

	function options(path, ranges) {
	  return {
	    onRender: function onRender(node, dom, offset) {
	      if (!node.isText && node.type.contains == null) {
	        dom.contentEditable = false;
	        if (node.isBlock) dom.setAttribute("pm-leaf", "true");
	      }
	      if (node.isBlock && offset != null) dom.setAttribute("pm-offset", offset);
	      if (node.isTextblock) adjustTrailingHacks(dom, node);

	      return dom;
	    },
	    onContainer: function onContainer(node) {
	      node.setAttribute("pm-container", true);
	    },
	    renderInlineFlat: function renderInlineFlat(node, dom, offset) {
	      ranges.advanceTo(new _model.Pos(path, offset));
	      var end = new _model.Pos(path, offset + node.width);
	      var nextCut = ranges.nextChangeBefore(end);

	      var inner = dom,
	          wrapped = undefined;
	      for (var i = 0; i < node.marks.length; i++) {
	        inner = inner.firstChild;
	      }if (dom.nodeType != 1) {
	        dom = (0, _dom.elt)("span", null, dom);
	        if (!nextCut) wrapped = dom;
	      }
	      if (!wrapped && (nextCut || ranges.current.length)) {
	        wrapped = inner == dom ? dom = (0, _dom.elt)("span", null, inner) : inner.parentNode.appendChild((0, _dom.elt)("span", null, inner));
	      }

	      dom.setAttribute("pm-offset", offset);
	      if (node.type.contains == null) dom.setAttribute("pm-leaf", node.isText ? node.width : "true");

	      var inlineOffset = 0;
	      while (nextCut) {
	        var size = nextCut - offset;
	        var split = splitSpan(wrapped, size);
	        if (ranges.current.length) split.className = ranges.current.join(" ");
	        split.setAttribute("pm-inner-offset", inlineOffset);
	        inlineOffset += size;
	        offset += size;
	        ranges.advanceTo(new _model.Pos(path, offset));
	        if (!(nextCut = ranges.nextChangeBefore(end))) wrapped.setAttribute("pm-inner-offset", inlineOffset);
	      }

	      if (ranges.current.length) wrapped.className = ranges.current.join(" ");
	      return dom;
	    },

	    document: document, path: path
	  };
	}

	function splitSpan(span, at) {
	  var textNode = span.firstChild,
	      text = textNode.nodeValue;
	  var newNode = span.parentNode.insertBefore((0, _dom.elt)("span", null, text.slice(0, at)), span);
	  textNode.nodeValue = text.slice(at);
	  return newNode;
	}

	function draw(pm, doc) {
	  pm.content.textContent = "";
	  pm.content.appendChild((0, _format.toDOM)(doc, options([], pm.ranges.activeRangeTracker())));
	}

	function adjustTrailingHacks(dom, node) {
	  var needs = node.size == 0 || node.lastChild.type.isBR || node.type.isCode && node.lastChild.isText && /\n$/.test(node.lastChild.text) ? "br" : !node.lastChild.isText && node.lastChild.type.contains == null ? "text" : null;
	  var last = dom.lastChild;
	  var has = !last || last.nodeType != 1 || !last.hasAttribute("pm-ignore") ? null : last.nodeName == "BR" ? "br" : "text";
	  if (needs != has) {
	    if (has) dom.removeChild(last);
	    if (needs) dom.appendChild(needs == "br" ? (0, _dom.elt)("br", { "pm-ignore": "trailing-break" }) : (0, _dom.elt)("span", { "pm-ignore": "cursor-text" }, ""));
	  }
	}

	function findNodeIn(iter, node) {
	  var copy = iter.copy();
	  for (var child; child = copy.next().value;) {
	    if (child == node) return child;
	  }
	}

	function movePast(dom) {
	  var next = dom.nextSibling;
	  dom.parentNode.removeChild(dom);
	  return next;
	}

	function redraw(pm, dirty, doc, prev) {
	  if (dirty.get(prev) == _main.DIRTY_REDRAW) return draw(pm, doc);

	  var opts = options([], pm.ranges.activeRangeTracker());

	  function scan(dom, node, prev) {
	    var iNode = node.iter(),
	        iPrev = prev.iter(),
	        pChild = iPrev.next().value;
	    var domPos = dom.firstChild;

	    for (var child; child = iNode.next().value;) {
	      var offset = iNode.offset - child.width,
	          matching = undefined,
	          reuseDOM = undefined;
	      if (!node.isTextblock) opts.path.push(offset);

	      if (pChild == child) {
	        matching = pChild;
	      } else if (matching = findNodeIn(iPrev, child)) {
	        while (pChild != matching) {
	          pChild = iPrev.next().value;
	          domPos = movePast(domPos);
	        }
	      }

	      if (matching && !dirty.get(matching)) {
	        reuseDOM = true;
	      } else if (pChild && !child.isText && child.sameMarkup(pChild) && dirty.get(pChild) != _main.DIRTY_REDRAW) {
	        reuseDOM = true;
	        if (pChild.type.contains) scan((0, _dompos.childContainer)(domPos), child, pChild);
	      } else {
	        var rendered = (0, _format.nodeToDOM)(child, opts, offset);
	        dom.insertBefore(rendered, domPos);
	        reuseDOM = false;
	      }

	      if (reuseDOM) {
	        domPos.setAttribute("pm-offset", offset);
	        domPos = domPos.nextSibling;
	        pChild = iPrev.next().value;
	      }
	      if (!node.isTextblock) opts.path.pop();
	    }

	    while (pChild) {
	      domPos = movePast(domPos);
	      pChild = iPrev.next().value;
	    }
	    if (node.isTextblock) adjustTrailingHacks(dom, node);
	  }
	  scan(pm.content, doc, prev);
	}

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Input = undefined;
	exports.dispatchKey = dispatchKey;

	var _browserkeymap = __webpack_require__(21);

	var _browserkeymap2 = _interopRequireDefault(_browserkeymap);

	var _model = __webpack_require__(3);

	var _format = __webpack_require__(35);

	var _capturekeys = __webpack_require__(49);

	var _dom = __webpack_require__(14);

	var _domchange = __webpack_require__(50);

	var _selection = __webpack_require__(45);

	var _dompos = __webpack_require__(46);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var stopSeq = null;

	// A collection of DOM events that occur within the editor, and callback functions
	// to invoke when the event fires.
	var handlers = {};

	var Input = exports.Input = function () {
	  function Input(pm) {
	    var _this = this;

	    _classCallCheck(this, Input);

	    this.pm = pm;
	    this.baseKeymap = null;

	    this.keySeq = null;

	    // When the user is creating a composed character,
	    // this is set to a Composing instance.
	    this.composing = null;
	    this.mouseDown = null;
	    this.shiftKey = this.updatingComposition = false;
	    this.skipInput = 0;

	    this.draggingFrom = false;

	    this.keymaps = [];
	    this.defaultKeymap = null;

	    this.storedMarks = null;

	    this.dropTarget = pm.wrapper.appendChild((0, _dom.elt)("div", { class: "ProseMirror-drop-target" }));

	    var _loop = function _loop(event) {
	      var handler = handlers[event];
	      pm.content.addEventListener(event, function (e) {
	        return handler(pm, e);
	      });
	    };

	    for (var event in handlers) {
	      _loop(event);
	    }

	    pm.on("selectionChange", function () {
	      return _this.storedMarks = null;
	    });
	  }

	  _createClass(Input, [{
	    key: "maybeAbortComposition",
	    value: function maybeAbortComposition() {
	      if (this.composing && !this.updatingComposition) {
	        if (this.composing.finished) {
	          finishComposing(this.pm);
	        } else {
	          // Toggle selection to force end of composition
	          this.composing = null;
	          this.skipInput++;
	          var sel = window.getSelection();
	          if (sel.rangeCount) {
	            var range = sel.getRangeAt(0);
	            sel.removeAllRanges();
	            sel.addRange(range);
	          }
	        }
	        return true;
	      }
	    }
	  }]);

	  return Input;
	}();

	// Dispatch a key press to the internal keymaps, which will override the default
	// DOM behavior.

	function dispatchKey(pm, name, e) {
	  var seq = pm.input.keySeq;
	  // If the previous key should be used in sequence with this one, modify the name accordingly.
	  if (seq) {
	    if (_browserkeymap2.default.isModifierKey(name)) return true;
	    clearTimeout(stopSeq);
	    stopSeq = setTimeout(function () {
	      if (pm.input.keySeq == seq) pm.input.keySeq = null;
	    }, 50);
	    name = seq + " " + name;
	  }

	  var handle = function handle(bound) {
	    if (bound === false) return "nothing";
	    if (bound == "...") return "multi";
	    if (bound == null) return false;

	    var result = false;
	    if (Array.isArray(bound)) {
	      for (var i = 0; result === false && i < bound.length; i++) {
	        result = handle(bound[i]);
	      }
	    } else if (typeof bound == "string") {
	      result = pm.execCommand(bound);
	    } else {
	      result = bound(pm);
	    }
	    return result == false ? false : "handled";
	  };

	  var result = undefined;
	  for (var i = 0; !result && i < pm.input.keymaps.length; i++) {
	    result = handle(pm.input.keymaps[i].map.lookup(name, pm));
	  }if (!result) result = handle(pm.input.baseKeymap.lookup(name, pm)) || handle(_capturekeys.captureKeys.lookup(name));

	  // If the key should be used in sequence with the next key, store the keyname internally.
	  if (result == "multi") pm.input.keySeq = name;

	  if (result == "handled" || result == "multi") e.preventDefault();

	  if (seq && !result && /\'$/.test(name)) {
	    e.preventDefault();
	    return true;
	  }
	  return !!result;
	}

	handlers.keydown = function (pm, e) {
	  // :: () #path=ProseMirror#events#interaction
	  // Fired when the user interacts with the editor, for example by
	  // clicking on it or pressing a key while it is focused. Mostly
	  // useful for closing or resetting transient UI state such as open
	  // menus.
	  pm.signal("interaction");
	  if (e.keyCode == 16) pm.input.shiftKey = true;
	  if (pm.input.composing) return;
	  var name = _browserkeymap2.default.keyName(e);
	  if (name && dispatchKey(pm, name, e)) return;
	  pm.sel.fastPoll();
	};

	handlers.keyup = function (pm, e) {
	  if (e.keyCode == 16) pm.input.shiftKey = false;
	};

	// : (ProseMirror, TextSelection, string)
	// Insert text into a document.
	function inputText(pm, range, text) {
	  if (range.empty && !text) return false;
	  var marks = pm.input.storedMarks || pm.doc.marksAt(range.from);
	  pm.tr.replaceWith(range.from, range.to, pm.schema.text(text, marks)).apply({ scrollIntoView: true });
	  // :: () #path=ProseMirror#events#textInput
	  // Fired when the user types text into the editor.
	  pm.signal("textInput", text);
	}

	handlers.keypress = function (pm, e) {
	  if (pm.input.composing || !e.charCode || e.ctrlKey && !e.altKey || _dom.browser.mac && e.metaKey) return;
	  if (dispatchKey(pm, _browserkeymap2.default.keyName(e))) return;
	  var sel = pm.selection;
	  if (sel.node && sel.node.contains == null) {
	    pm.tr.delete(sel.from, sel.to).apply();
	    sel = pm.selection;
	  }
	  inputText(pm, sel, String.fromCharCode(e.charCode));
	  e.preventDefault();
	};

	function selectClickedNode(pm, e) {
	  var pos = (0, _dompos.selectableNodeAbove)(pm, e.target, { left: e.clientX, top: e.clientY }, true);
	  if (!pos) return pm.sel.fastPoll();

	  var _pm$selection = pm.selection;
	  var node = _pm$selection.node;
	  var from = _pm$selection.from;

	  if (node && pos.depth >= from.depth && pos.shorten(from.depth).cmp(from) == 0) {
	    if (from.depth == 0) return pm.sel.fastPoll();
	    pos = from.shorten();
	  }

	  pm.setNodeSelection(pos);
	  pm.focus();
	  e.preventDefault();
	}

	var lastClick = 0,
	    oneButLastClick = 0;

	function handleTripleClick(pm, e) {
	  e.preventDefault();
	  var pos = (0, _dompos.selectableNodeAbove)(pm, e.target, { left: e.clientX, top: e.clientY }, true);
	  if (pos) {
	    var node = pm.doc.nodeAfter(pos);
	    if (node.isBlock && !node.isTextblock) {
	      pm.setNodeSelection(pos);
	    } else {
	      var path = node.isInline ? pos.path : pos.toPath();
	      if (node.isInline) node = pm.doc.path(path);
	      pm.setTextSelection(new _model.Pos(path, 0), new _model.Pos(path, node.size));
	    }
	    pm.focus();
	  }
	}

	handlers.mousedown = function (pm, e) {
	  pm.signal("interaction");
	  var now = Date.now(),
	      doubleClick = now - lastClick < 500,
	      tripleClick = now - oneButLastClick < 600;
	  oneButLastClick = lastClick;
	  lastClick = now;

	  if (tripleClick) handleTripleClick(pm, e);else pm.input.mouseDown = new MouseDown(pm, e, doubleClick);
	};

	var MouseDown = function () {
	  function MouseDown(pm, event, doubleClick) {
	    _classCallCheck(this, MouseDown);

	    this.pm = pm;
	    this.event = event;
	    this.leaveToBrowser = pm.input.shiftKey || doubleClick;

	    var path = (0, _dompos.pathFromDOM)(pm, event.target),
	        node = pm.doc.path(path);
	    this.mightDrag = node.type.draggable || node == pm.sel.range.node ? path : null;
	    if (this.mightDrag) {
	      event.target.draggable = true;
	      if (_dom.browser.gecko && (this.setContentEditable = !event.target.hasAttribute("contentEditable"))) event.target.setAttribute("contentEditable", "false");
	    }

	    this.x = event.clientX;this.y = event.clientY;

	    addEventListener("mouseup", this.up = this.up.bind(this));
	    addEventListener("mousemove", this.move = this.move.bind(this));
	    pm.sel.fastPoll();
	  }

	  _createClass(MouseDown, [{
	    key: "done",
	    value: function done() {
	      removeEventListener("mouseup", this.up);
	      removeEventListener("mousemove", this.move);
	      if (this.mightDrag) {
	        this.event.target.draggable = false;
	        if (_dom.browser.gecko && this.setContentEditable) this.event.target.removeAttribute("contentEditable");
	      }
	    }
	  }, {
	    key: "up",
	    value: function up() {
	      this.done();

	      if (this.leaveToBrowser) {
	        this.pm.sel.fastPoll();
	      } else if (this.event.ctrlKey) {
	        selectClickedNode(this.pm, this.event);
	      } else if (!(0, _dompos.handleNodeClick)(this.pm, "handleClick", this.event, true)) {
	        var pos = (0, _dompos.selectableNodeAbove)(this.pm, this.event.target, { left: this.x, top: this.y });
	        if (pos) {
	          this.pm.setNodeSelection(pos);
	          this.pm.focus();
	        } else {
	          this.pm.sel.fastPoll();
	        }
	      }
	    }
	  }, {
	    key: "move",
	    value: function move(event) {
	      if (!this.leaveToBrowser && (Math.abs(this.x - event.clientX) > 4 || Math.abs(this.y - event.clientY) > 4)) this.leaveToBrowser = true;
	      this.pm.sel.fastPoll();
	    }
	  }]);

	  return MouseDown;
	}();

	handlers.touchdown = function (pm) {
	  pm.sel.fastPoll();
	};

	handlers.contextmenu = function (pm, e) {
	  (0, _dompos.handleNodeClick)(pm, "handleContextMenu", e, false);
	};

	// A class to track state while creating a composed character.

	var Composing = function Composing(pm, data) {
	  _classCallCheck(this, Composing);

	  this.finished = false;
	  this.context = (0, _domchange.textContext)(data);
	  this.data = data;
	  this.endData = null;
	  var range = pm.selection;
	  if (data) {
	    var path = range.head.path,
	        line = pm.doc.path(path).textContent;
	    var found = line.indexOf(data, range.head.offset - data.length);
	    if (found > -1 && found <= range.head.offset + data.length) range = new _selection.TextSelection(new _model.Pos(path, found), new _model.Pos(path, found + data.length));
	  }
	  this.range = range;
	};

	handlers.compositionstart = function (pm, e) {
	  if (pm.input.maybeAbortComposition()) return;

	  pm.flush();
	  pm.input.composing = new Composing(pm, e.data);
	  var above = pm.selection.head.shorten();
	  pm.markRangeDirty({ from: above, to: above.move(1) });
	};

	handlers.compositionupdate = function (pm, e) {
	  var info = pm.input.composing;
	  if (info && info.data != e.data) {
	    info.data = e.data;
	    pm.input.updatingComposition = true;
	    inputText(pm, info.range, info.data);
	    pm.input.updatingComposition = false;
	    info.range = new _selection.TextSelection(info.range.from, info.range.from.move(info.data.length));
	  }
	};

	handlers.compositionend = function (pm, e) {
	  var info = pm.input.composing;
	  if (info) {
	    pm.input.composing.finished = true;
	    pm.input.composing.endData = e.data;
	    setTimeout(function () {
	      if (pm.input.composing == info) finishComposing(pm);
	    }, 20);
	  }
	};

	function finishComposing(pm) {
	  var info = pm.input.composing;
	  var text = (0, _domchange.textInContext)(info.context, info.endData);
	  var range = (0, _selection.rangeFromDOMLoose)(pm);
	  pm.ensureOperation();
	  pm.input.composing = null;
	  if (text != info.data) inputText(pm, info.range, text);
	  if (range && !range.eq(pm.sel.range)) pm.setSelectionDirect(range);
	}

	handlers.input = function (pm) {
	  if (pm.input.skipInput) return --pm.input.skipInput;

	  if (pm.input.composing) {
	    if (pm.input.composing.finished) finishComposing(pm);
	    return;
	  }

	  pm.startOperation({ readSelection: false });
	  (0, _domchange.applyDOMChange)(pm);
	  pm.scrollIntoView();
	};

	var lastCopied = null;

	function setCopied(doc, from, to, dataTransfer) {
	  var fragment = doc.sliceBetween(from, to);
	  lastCopied = { doc: doc, from: from, to: to,
	    schema: doc.type.schema,
	    html: (0, _format.toHTML)(fragment),
	    text: (0, _format.toText)(fragment) };
	  if (dataTransfer) {
	    dataTransfer.clearData();
	    dataTransfer.setData("text/html", lastCopied.html);
	    dataTransfer.setData("text/plain", lastCopied.text);
	  }
	}

	function getCopied(pm, dataTransfer, plainText) {
	  var txt = dataTransfer.getData("text/plain");
	  var html = dataTransfer.getData("text/html");
	  if (!html && !txt) return null;
	  var doc = undefined;
	  if (plainText && txt) {
	    doc = (0, _format.fromText)(pm.schema, pm.signalPipelined("transformPastedText", txt));
	  } else if (lastCopied && lastCopied.html == html && lastCopied.schema == pm.schema) {
	    return lastCopied;
	  } else if (html) {
	    doc = (0, _format.fromHTML)(pm.schema, pm.signalPipelined("transformPastedHTML", html));
	  } else {
	    doc = (0, _format.parseFrom)(pm.schema, pm.signalPipelined("transformPastedText", txt), (0, _format.knownSource)("markdown") ? "markdown" : "text");
	  }
	  return { doc: doc, from: (0, _selection.findSelectionAtStart)(doc).from, to: (0, _selection.findSelectionAtEnd)(doc).to };
	}

	handlers.copy = handlers.cut = function (pm, e) {
	  var _pm$selection2 = pm.selection;
	  var from = _pm$selection2.from;
	  var to = _pm$selection2.to;
	  var empty = _pm$selection2.empty;

	  if (empty) return;
	  setCopied(pm.doc, from, to, e.clipboardData);
	  if (e.clipboardData) {
	    e.preventDefault();
	    if (e.type == "cut" && !empty) pm.tr.delete(from, to).apply();
	  }
	};

	// :: (text: string) → string #path=ProseMirror#events#transformPastedText
	// Fired when plain text is pasted. Handlers must return the given
	// string or a [transformed](#EventMixin.signalPipelined) version of
	// it.

	// :: (html: string) → string #path=ProseMirror#events#transformPastedHTML
	// Fired when html content is pasted. Handlers must return the given
	// string or a [transformed](#EventMixin.signalPipelined) version of
	// it.

	handlers.paste = function (pm, e) {
	  if (!e.clipboardData) return;
	  var sel = pm.selection;
	  var fragment = getCopied(pm, e.clipboardData, pm.input.shiftKey);
	  if (fragment) {
	    e.preventDefault();
	    pm.tr.replace(sel.from, sel.to, fragment.doc, fragment.from, fragment.to).apply();
	    pm.scrollIntoView();
	  }
	};

	handlers.dragstart = function (pm, e) {
	  var mouseDown = pm.input.mouseDown;
	  if (mouseDown) mouseDown.done();

	  if (!e.dataTransfer) return;

	  var _pm$selection3 = pm.selection;
	  var from = _pm$selection3.from;
	  var to = _pm$selection3.to;
	  var empty = _pm$selection3.empty;var fragment = undefined;
	  var pos = !empty && pm.posAtCoords({ left: e.clientX, top: e.clientY });
	  if (pos && pos.cmp(from) >= 0 && pos.cmp(to) <= 0) {
	    fragment = { from: from, to: to };
	  } else if (mouseDown && mouseDown.mightDrag) {
	    var _pos = _model.Pos.from(mouseDown.mightDrag);
	    fragment = { from: _pos, to: _pos.move(1) };
	  }

	  if (fragment) {
	    // FIXME the document could change during a drag, invalidating this range
	    pm.input.draggingFrom = fragment;
	    setCopied(pm.doc, fragment.from, fragment.to, e.dataTransfer);
	  }
	};

	handlers.dragend = function (pm) {
	  return window.setTimeout(function () {
	    return pm.input.draggingFrom = false;
	  }, 50);
	};

	handlers.dragover = handlers.dragenter = function (pm, e) {
	  e.preventDefault();
	  var cursorPos = pm.posAtCoords({ left: e.clientX, top: e.clientY });
	  if (!cursorPos) return;
	  var coords = (0, _dompos.coordsAtPos)(pm, cursorPos);
	  var rect = pm.wrapper.getBoundingClientRect();
	  coords.top -= rect.top;
	  coords.right -= rect.left;
	  coords.bottom -= rect.top;
	  coords.left -= rect.left;
	  var target = pm.input.dropTarget;
	  target.style.display = "block";
	  target.style.left = coords.left - 1 + "px";
	  target.style.top = coords.top + "px";
	  target.style.height = coords.bottom - coords.top + "px";
	};

	handlers.dragleave = function (pm) {
	  return pm.input.dropTarget.style.display = "";
	};

	handlers.drop = function (pm, e) {
	  pm.input.dropTarget.style.display = "";

	  if (!e.dataTransfer) return;

	  var fragment = getCopied(pm, e.dataTransfer);
	  if (fragment) {
	    e.preventDefault();
	    var insertPos = pm.posAtCoords({ left: e.clientX, top: e.clientY }),
	        origPos = insertPos;
	    if (!insertPos) return;
	    var tr = pm.tr;
	    if (pm.input.draggingFrom && !e.ctrlKey) {
	      tr.delete(pm.input.draggingFrom.from, pm.input.draggingFrom.to);
	      insertPos = tr.map(insertPos).pos;
	    }
	    tr.replace(insertPos, insertPos, fragment.doc, fragment.from, fragment.to).apply();
	    var posAfter = tr.map(origPos).pos;
	    if (_model.Pos.samePath(insertPos.path, posAfter.path) && posAfter.offset == insertPos.offset + 1 && pm.doc.nodeAfter(insertPos).type.selectable) pm.setNodeSelection(insertPos);else pm.setTextSelection(insertPos, posAfter);
	    pm.focus();
	  }
	};

	handlers.focus = function (pm) {
	  (0, _dom.addClass)(pm.wrapper, "ProseMirror-focused");
	  // :: () #path=ProseMirror#events#focus
	  // Fired when the editor gains focus.
	  pm.signal("focus");
	};

	handlers.blur = function (pm) {
	  (0, _dom.rmClass)(pm.wrapper, "ProseMirror-focused");
	  // :: () #path=ProseMirror#events#blur
	  // Fired when the editor loses focus.
	  pm.signal("blur");
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.captureKeys = undefined;

	var _browserkeymap = __webpack_require__(21);

	var _browserkeymap2 = _interopRequireDefault(_browserkeymap);

	var _selection = __webpack_require__(45);

	var _dompos = __webpack_require__(46);

	var _dom = __webpack_require__(14);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function nothing() {}

	function ensureSelection(pm) {
	  if (pm.selection.node) {
	    var found = (0, _selection.findSelectionNear)(pm.doc, pm.selection.from, 1, true);
	    if (found) (0, _dompos.setDOMSelectionToPos)(pm, found.head);
	  }
	  return false;
	}

	// A backdrop keymap used to make sure we always suppress keys that
	// have a dangerous default effect, even if the commands they are
	// bound to return false, and to make sure that cursor-motion keys
	// find a cursor (as opposed to a node selection) when pressed.

	var keys = {
	  "Esc": nothing,
	  "Enter": nothing,
	  "Mod-Enter": nothing,
	  "Shift-Enter": nothing,
	  "Backspace": nothing,
	  "Delete": nothing,
	  "Mod-B": nothing,
	  "Mod-I": nothing,
	  "Mod-Backspace": nothing,
	  "Mod-Delete": nothing,
	  "Shift-Backspace": nothing,
	  "Shift-Delete": nothing,
	  "Shift-Mod-Backspace": nothing,
	  "Shift-Mod-Delete": nothing,
	  "Mod-Z": nothing,
	  "Mod-Y": nothing,
	  "Shift-Mod-Z": nothing,
	  "Ctrl-D": nothing,
	  "Ctrl-H": nothing,
	  "Ctrl-Alt-Backspace": nothing,
	  "Alt-D": nothing,
	  "Alt-Delete": nothing,
	  "Alt-Backspace": nothing,

	  "Mod-A": ensureSelection
	};["Left", "Right", "Up", "Down", "Home", "End", "PageUp", "PageDown"].forEach(function (key) {
	  keys[key] = keys["Shift-" + key] = keys["Mod-" + key] = keys["Shift-Mod-" + key] = keys["Alt-" + key] = keys["Shift-Alt-" + key] = ensureSelection;
	});["Left", "Mod-Left", "Right", "Mod-Right", "Up", "Down"].forEach(function (key) {
	  return delete keys[key];
	});

	if (_dom.browser.mac) keys["Ctrl-F"] = keys["Ctrl-B"] = keys["Ctrl-P"] = keys["Ctrl-N"] = keys["Alt-F"] = keys["Alt-B"] = keys["Ctrl-A"] = keys["Ctrl-E"] = keys["Ctrl-V"] = keys["goPageUp"] = ensureSelection;

	var captureKeys = exports.captureKeys = new _browserkeymap2.default(keys);

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.applyDOMChange = applyDOMChange;
	exports.textContext = textContext;
	exports.textInContext = textInContext;

	var _model = __webpack_require__(3);

	var _format = __webpack_require__(35);

	var _tree = __webpack_require__(27);

	var _dompos = __webpack_require__(46);

	function isAtEnd(node, pos, depth) {
	  for (var i = depth || 0; i < pos.path.length; i++) {
	    var n = pos.path[depth];
	    if (n < node.size - 1) return false;
	    node = node.child(n);
	  }
	  return pos.offset == node.size;
	}
	function isAtStart(pos, depth) {
	  if (pos.offset > 0) return false;
	  for (var i = depth || 0; i < pos.path.length; i++) {
	    if (pos.path[depth] > 0) return false;
	  }return true;
	}

	function parseNearSelection(pm) {
	  var dom = pm.content,
	      node = pm.doc;
	  var _pm$selection = pm.selection;
	  var from = _pm$selection.from;
	  var to = _pm$selection.to;

	  for (var depth = 0;; depth++) {
	    var toNode = node.child(to.path[depth]);
	    var fromStart = isAtStart(from, depth + 1);
	    var toEnd = isAtEnd(toNode, to, depth + 1);
	    if (fromStart || toEnd || from.path[depth] != to.path[depth] || toNode.isTextblock) {
	      var startOffset = depth == from.depth ? from.offset : from.path[depth];
	      if (fromStart && startOffset > 0) startOffset--;
	      var endOffset = depth == to.depth ? to.offset : to.path[depth] + 1;
	      if (toEnd && endOffset < node.size - 1) endOffset++;
	      var parsed = (0, _format.fromDOM)(pm.schema, dom, { topNode: node.copy(),
	        from: startOffset,
	        to: dom.childNodes.length - (node.size - endOffset) });
	      parsed = parsed.copy(node.content.slice(0, startOffset).append(parsed.content).append(node.content.slice(endOffset)));
	      for (var i = depth - 1; i >= 0; i--) {
	        var wrap = pm.doc.path(from.path.slice(0, i));
	        parsed = wrap.replace(from.path[i], parsed);
	      }
	      return parsed;
	    }
	    node = toNode;
	    dom = (0, _dompos.findByPath)(dom, from.path[depth], false);
	  }
	}

	function applyDOMChange(pm) {
	  var updated = parseNearSelection(pm);
	  var changeStart = (0, _model.findDiffStart)(pm.doc.content, updated.content);
	  if (changeStart) {
	    var changeEnd = findDiffEndConstrained(pm.doc.content, updated.content, changeStart);
	    // Mark nodes touched by this change as 'to be redrawn'
	    markDirtyFor(pm, changeStart, changeEnd);

	    pm.tr.replace(changeStart, changeEnd.a, updated, changeStart, changeEnd.b).apply();
	    return true;
	  } else {
	    return false;
	  }
	}

	function offsetBy(first, second, pos) {
	  var same = (0, _tree.samePathDepth)(first, second);
	  var firstEnd = same == first.depth,
	      secondEnd = same == second.depth;
	  var off = (secondEnd ? second.offset : second.path[same]) - (firstEnd ? first.offset : first.path[same]);
	  var shorter = firstEnd ? pos.move(off) : pos.shorten(same, off);
	  if (secondEnd) return shorter;else return shorter.extend(new _model.Pos(second.path.slice(same), second.offset));
	}

	function findDiffEndConstrained(a, b, start) {
	  var end = (0, _model.findDiffEnd)(a, b);
	  if (!end) return end;
	  if (end.a.cmp(start) < 0) return { a: start, b: offsetBy(end.a, start, end.b) };
	  if (end.b.cmp(start) < 0) return { a: offsetBy(end.b, start, end.a), b: start };
	  return end;
	}

	function sameDepth(a, b) {
	  var max = Math.min(a.depth, b.depth);
	  for (var i = 0; i < max; i++) {
	    if (a.path[i] != b.path[i]) return i;
	  }return max;
	}

	function markDirtyFor(pm, start, end) {
	  var depth = Math.min(sameDepth(start, end.a), sameDepth(start, end.b));
	  if (depth == 0) {
	    pm.markAllDirty();
	  } else {
	    var pos = _model.Pos.from(start.path.slice(0, depth));
	    pm.markRangeDirty({ from: pos, to: pos.move(1) });
	  }
	}

	// Text-only queries for composition events

	function textContext(data) {
	  var range = window.getSelection().getRangeAt(0);
	  var start = range.startContainer,
	      end = range.endContainer;
	  if (start == end && start.nodeType == 3) {
	    var value = start.nodeValue,
	        lead = range.startOffset,
	        _end = range.endOffset;
	    if (data && _end >= data.length && value.slice(_end - data.length, _end) == data) lead = _end - data.length;
	    return { inside: start, lead: lead, trail: value.length - _end };
	  }

	  var sizeBefore = null,
	      sizeAfter = null;
	  var before = start.childNodes[range.startOffset - 1] || nodeBefore(start);
	  while (before.lastChild) {
	    before = before.lastChild;
	  }if (before && before.nodeType == 3) {
	    var value = before.nodeValue;
	    sizeBefore = value.length;
	    if (data && value.slice(value.length - data.length) == data) sizeBefore -= data.length;
	  }
	  var after = end.childNodes[range.endOffset] || nodeAfter(end);
	  while (after.firstChild) {
	    after = after.firstChild;
	  }if (after && after.nodeType == 3) sizeAfter = after.nodeValue.length;

	  return { before: before, sizeBefore: sizeBefore,
	    after: after, sizeAfter: sizeAfter };
	}

	function textInContext(context, deflt) {
	  if (context.inside) {
	    var _val = context.inside.nodeValue;
	    return _val.slice(context.lead, _val.length - context.trail);
	  } else {
	    var before = context.before,
	        after = context.after,
	        val = "";
	    if (!before) return deflt;
	    if (before.nodeType == 3) val = before.nodeValue.slice(context.sizeBefore);
	    var scan = scanText(before, after);
	    if (scan == null) return deflt;
	    val += scan;
	    if (after && after.nodeType == 3) {
	      var valAfter = after.nodeValue;
	      val += valAfter.slice(0, valAfter.length - context.sizeAfter);
	    }
	    return val;
	  }
	}

	function nodeAfter(node) {
	  for (;;) {
	    var next = node.nextSibling;
	    if (next) {
	      while (next.firstChild) {
	        next = next.firstChild;
	      }return next;
	    }
	    if (!(node = node.parentElement)) return null;
	  }
	}

	function nodeBefore(node) {
	  for (;;) {
	    var prev = node.previousSibling;
	    if (prev) {
	      while (prev.lastChild) {
	        prev = prev.lastChild;
	      }return prev;
	    }
	    if (!(node = node.parentElement)) return null;
	  }
	}

	function scanText(start, end) {
	  var text = "",
	      cur = nodeAfter(start);
	  for (;;) {
	    if (cur == end) return text;
	    if (!cur) return null;
	    if (cur.nodeType == 3) text += cur.nodeValue;
	    cur = cur.firstChild || nodeAfter(cur);
	  }
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.History = undefined;

	var _model = __webpack_require__(3);

	var _transform = __webpack_require__(22);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Steps are stored in inverted form (so that they can be applied to
	// undo the original).

	var InvertedStep = function InvertedStep(step, version, id) {
	  _classCallCheck(this, InvertedStep);

	  this.step = step;
	  this.version = version;
	  this.id = id;
	};

	var BranchRemapping = function () {
	  function BranchRemapping(branch) {
	    _classCallCheck(this, BranchRemapping);

	    this.branch = branch;
	    this.remap = new _transform.Remapping();
	    this.version = branch.version;
	    this.mirrorBuffer = Object.create(null);
	  }

	  _createClass(BranchRemapping, [{
	    key: "moveToVersion",
	    value: function moveToVersion(version) {
	      while (this.version > version) {
	        this.addNextMap();
	      }
	    }
	  }, {
	    key: "addNextMap",
	    value: function addNextMap() {
	      var found = this.branch.mirror[this.version];
	      var mapOffset = this.branch.maps.length - (this.branch.version - this.version) - 1;
	      var id = this.remap.addToFront(this.branch.maps[mapOffset], this.mirrorBuffer[this.version]);
	      --this.version;
	      if (found != null) this.mirrorBuffer[found] = id;
	      return id;
	    }
	  }, {
	    key: "movePastStep",
	    value: function movePastStep(result) {
	      var id = this.addNextMap();
	      if (result) this.remap.addToBack(result.map, id);
	    }
	  }]);

	  return BranchRemapping;
	}();

	var workTime = 100,
	    pauseTime = 150;

	var CompressionWorker = function () {
	  function CompressionWorker(doc, branch, callback) {
	    _classCallCheck(this, CompressionWorker);

	    this.branch = branch;
	    this.callback = callback;
	    this.remap = new BranchRemapping(branch);

	    this.doc = doc;
	    this.events = [];
	    this.maps = [];
	    this.version = this.startVersion = branch.version;

	    this.i = branch.events.length;
	    this.timeout = null;
	    this.aborted = false;
	  }

	  _createClass(CompressionWorker, [{
	    key: "work",
	    value: function work() {
	      var _this = this;

	      if (this.aborted) return;

	      var endTime = Date.now() + workTime;

	      for (;;) {
	        if (this.i == 0) return this.finish();
	        var event = this.branch.events[--this.i],
	            outEvent = [];
	        for (var j = event.length - 1; j >= 0; j--) {
	          var _event$j = event[j];
	          var step = _event$j.step;
	          var stepVersion = _event$j.version;
	          var stepID = _event$j.id;

	          this.remap.moveToVersion(stepVersion);

	          var mappedStep = step.map(this.remap.remap);
	          if (mappedStep && isDelStep(step)) {
	            var extra = 0,
	                start = step.from;
	            while (j > 0) {
	              var next = event[j - 1];
	              if (next.version != stepVersion - 1 || !isDelStep(next.step) || start.cmp(next.step.to)) break;
	              extra += next.step.to.offset - next.step.from.offset;
	              start = next.step.from;
	              stepVersion--;
	              j--;
	              this.remap.addNextMap();
	            }
	            if (extra > 0) {
	              var _start = mappedStep.from.move(-extra);
	              mappedStep = new _transform.Step("replace", _start, mappedStep.to, _start);
	            }
	          }
	          var result = mappedStep && mappedStep.apply(this.doc);
	          if (result) {
	            this.doc = result.doc;
	            this.maps.push(result.map.invert());
	            outEvent.push(new InvertedStep(mappedStep, this.version, stepID));
	            this.version--;
	          }
	          this.remap.movePastStep(result);
	        }
	        if (outEvent.length) {
	          outEvent.reverse();
	          this.events.push(outEvent);
	        }
	        if (Date.now() > endTime) {
	          this.timeout = window.setTimeout(function () {
	            return _this.work();
	          }, pauseTime);
	          return;
	        }
	      }
	    }
	  }, {
	    key: "finish",
	    value: function finish() {
	      if (this.aborted) return;

	      this.events.reverse();
	      this.maps.reverse();
	      this.callback(this.maps.concat(this.branch.maps.slice(this.branch.maps.length - (this.branch.version - this.startVersion))), this.events);
	    }
	  }, {
	    key: "abort",
	    value: function abort() {
	      this.aborted = true;
	      window.clearTimeout(this.timeout);
	    }
	  }]);

	  return CompressionWorker;
	}();

	function isDelStep(step) {
	  return step.type == "replace" && step.from.offset < step.to.offset && _model.Pos.samePath(step.from.path, step.to.path) && (!step.param || step.param.content.size == 0);
	}

	var compressStepCount = 150;

	// A branch is a history of steps. There'll be one for the undo and
	// one for the redo history.

	var Branch = function () {
	  function Branch(maxDepth) {
	    _classCallCheck(this, Branch);

	    this.maxDepth = maxDepth;
	    this.version = 0;
	    this.nextStepID = 1;

	    this.maps = [];
	    this.mirror = Object.create(null);
	    this.events = [];

	    this.stepsSinceCompress = 0;
	    this.compressing = null;
	    this.compressTimeout = null;
	  }

	  _createClass(Branch, [{
	    key: "clear",
	    value: function clear(force) {
	      if (force || !this.empty()) {
	        this.maps.length = this.events.length = this.stepsSinceCompress = 0;
	        this.mirror = Object.create(null);
	        this.abortCompression();
	      }
	    }
	  }, {
	    key: "newEvent",
	    value: function newEvent() {
	      this.abortCompression();
	      this.events.push([]);
	      while (this.events.length > this.maxDepth) {
	        this.events.shift();
	      }
	    }
	  }, {
	    key: "addMap",
	    value: function addMap(map) {
	      if (!this.empty()) {
	        this.maps.push(map);
	        this.version++;
	        this.stepsSinceCompress++;
	        return true;
	      }
	    }
	  }, {
	    key: "empty",
	    value: function empty() {
	      return this.events.length == 0;
	    }
	  }, {
	    key: "addStep",
	    value: function addStep(step, map, id) {
	      this.addMap(map);
	      if (id == null) id = this.nextStepID++;
	      this.events[this.events.length - 1].push(new InvertedStep(step, this.version, id));
	    }

	    // : (Transform, ?[number])
	    // Add a transform to the branch's history.

	  }, {
	    key: "addTransform",
	    value: function addTransform(transform, ids) {
	      this.abortCompression();
	      for (var i = 0; i < transform.steps.length; i++) {
	        var inverted = transform.steps[i].invert(transform.docs[i], transform.maps[i]);
	        this.addStep(inverted, transform.maps[i], ids && ids[i]);
	      }
	    }

	    // : (Node, bool) → {transform: Transform, ids: [number]}
	    // Pop the latest event off the branch's history and apply it
	    // to a document transform, returning the transform and the step ID.

	  }, {
	    key: "popEvent",
	    value: function popEvent(doc, allowCollapsing) {
	      this.abortCompression();
	      var event = this.events.pop();
	      if (!event) return null;

	      var remap = new BranchRemapping(this),
	          collapsing = allowCollapsing;
	      var tr = new _transform.Transform(doc);
	      var ids = [];

	      for (var i = event.length - 1; i >= 0; i--) {
	        var invertedStep = event[i],
	            step = invertedStep.step;
	        if (!collapsing || invertedStep.version != remap.version) {
	          collapsing = false;
	          remap.moveToVersion(invertedStep.version);

	          step = step.map(remap.remap);
	          var result = step && tr.step(step);
	          if (result) {
	            ids.push(invertedStep.id);
	            if (this.addMap(result.map)) this.mirror[this.version] = invertedStep.version;
	          }

	          if (i > 0) remap.movePastStep(result);
	        } else {
	          this.version--;
	          delete this.mirror[this.version];
	          this.maps.pop();
	          tr.step(step);
	          ids.push(invertedStep.id);
	          --remap.version;
	        }
	      }
	      if (this.empty()) this.clear(true);
	      return { transform: tr, ids: ids };
	    }
	  }, {
	    key: "lastStep",
	    value: function lastStep() {
	      for (var i = this.events.length - 1; i >= 0; i--) {
	        var event = this.events[i];
	        if (event.length) return event[event.length - 1];
	      }
	    }
	  }, {
	    key: "getVersion",
	    value: function getVersion() {
	      var step = this.lastStep();
	      return { lastID: step && step.id, version: this.version };
	    }
	  }, {
	    key: "isAtVersion",
	    value: function isAtVersion(version) {
	      var step = this.lastStep();
	      return this.version == version.version && (step && step.id) == version.lastID;
	    }
	  }, {
	    key: "findVersion",
	    value: function findVersion(version) {
	      for (var i = this.events.length - 1; i >= 0; i--) {
	        var event = this.events[i];
	        for (var j = event.length - 1; j >= 0; j--) {
	          if (event[j].id <= version.lastID) return { event: i, step: j + 1 };
	        }
	      }
	    }
	  }, {
	    key: "rebased",
	    value: function rebased(newMaps, rebasedTransform, positions) {
	      if (this.empty()) return;
	      this.abortCompression();

	      var startVersion = this.version - positions.length;

	      // Update and clean up the events
	      out: for (var i = this.events.length - 1; i >= 0; i--) {
	        var event = this.events[i];
	        for (var j = event.length - 1; j >= 0; j--) {
	          var step = event[j];
	          if (step.version <= startVersion) break out;
	          var off = positions[step.version - startVersion - 1];
	          if (off == -1) {
	            event.splice(j--, 1);
	          } else {
	            var inv = rebasedTransform.steps[off].invert(rebasedTransform.docs[off], rebasedTransform.maps[off]);
	            event[j] = new InvertedStep(inv, startVersion + newMaps.length + off + 1, step.id);
	          }
	        }
	      }

	      // Sync the array of maps
	      if (this.maps.length > positions.length) this.maps = this.maps.slice(0, this.maps.length - positions.length).concat(newMaps).concat(rebasedTransform.maps);else this.maps = rebasedTransform.maps.slice();

	      this.version = startVersion + newMaps.length + rebasedTransform.maps.length;

	      this.stepsSinceCompress += newMaps.length + rebasedTransform.steps.length - positions.length;
	    }
	  }, {
	    key: "abortCompression",
	    value: function abortCompression() {
	      if (this.compressing) {
	        this.compressing.abort();
	        this.compressing = null;
	      }
	    }
	  }, {
	    key: "needsCompression",
	    value: function needsCompression() {
	      return this.stepsSinceCompress > compressStepCount && !this.compressing;
	    }
	  }, {
	    key: "startCompression",
	    value: function startCompression(doc) {
	      var _this2 = this;

	      this.compressing = new CompressionWorker(doc, this, function (maps, events) {
	        _this2.maps = maps;
	        _this2.events = events;
	        _this2.mirror = Object.create(null);
	        _this2.compressing = null;
	        _this2.stepsSinceCompress = 0;
	      });
	      this.compressing.work();
	    }
	  }]);

	  return Branch;
	}();

	var compressDelay = 750;

	// ;; An undo/redo history manager for an editor instance.

	var History = exports.History = function () {
	  function History(pm) {
	    var _this3 = this;

	    _classCallCheck(this, History);

	    this.pm = pm;

	    this.done = new Branch(pm.options.historyDepth);
	    this.undone = new Branch(pm.options.historyDepth);

	    this.lastAddedAt = 0;
	    this.ignoreTransform = false;

	    this.allowCollapsing = true;

	    pm.on("transform", function (transform, options) {
	      return _this3.recordTransform(transform, options);
	    });
	  }

	  // : (Transform, Object)
	  // Record a transformation in undo history.

	  _createClass(History, [{
	    key: "recordTransform",
	    value: function recordTransform(transform, options) {
	      if (this.ignoreTransform) return;

	      if (options.addToHistory == false) {
	        for (var i = 0; i < transform.maps.length; i++) {
	          var map = transform.maps[i];
	          this.done.addMap(map);
	          this.undone.addMap(map);
	        }
	      } else {
	        this.undone.clear();
	        var now = Date.now();
	        if (now > this.lastAddedAt + this.pm.options.historyEventDelay) this.done.newEvent();

	        this.done.addTransform(transform);
	        this.lastAddedAt = now;
	      }
	      this.maybeScheduleCompression();
	    }

	    // :: () → bool
	    // Undo one history event. The return value indicates whether
	    // anything was actually undone. Note that in a collaborative
	    // context, or when changes are [applied](#ProseMirror.apply)
	    // without adding them to the history, it is possible for
	    // [`undoDepth`](#History.undoDepth) to have a positive value, but
	    // this method to still return `false`, when non-history changes
	    // overwrote all remaining changes in the history.

	  }, {
	    key: "undo",
	    value: function undo() {
	      return this.shift(this.done, this.undone);
	    }

	    // :: () → bool
	    // Redo one history event. The return value indicates whether
	    // anything was actually redone.

	  }, {
	    key: "redo",
	    value: function redo() {
	      return this.shift(this.undone, this.done);
	    }

	    // :: number
	    // The amount of undoable events available.

	  }, {
	    key: "shift",

	    // : (Branch, Branch) → bool
	    // Apply the latest event from one branch to the document and shift
	    // the event onto the other branch. Returns true when an event could
	    // be shifted.
	    value: function shift(from, to) {
	      var event = from.popEvent(this.pm.doc, this.allowCollapsing);
	      if (!event) return false;
	      var transform = event.transform;
	      var ids = event.ids;

	      this.ignoreTransform = true;
	      this.pm.apply(transform);
	      this.ignoreTransform = false;

	      if (!transform.steps.length) return this.shift(from, to);

	      if (to) {
	        to.newEvent();
	        to.addTransform(transform, ids);
	      }
	      this.lastAddedAt = 0;

	      return true;
	    }

	    // :: () → Object
	    // Get the current ‘version’ of the editor content. This can be used
	    // to later [check](#History.isAtVersion) whether anything changed, or
	    // to [roll back](#History.backToVersion) to this version.

	  }, {
	    key: "getVersion",
	    value: function getVersion() {
	      return this.done.getVersion();
	    }

	    // :: (Object) → bool
	    // Returns `true` when the editor history is in the state that it
	    // was when the given [version](#History.getVersion) was recorded.
	    // That means either no changes were made, or changes were
	    // done/undone and then undone/redone again.

	  }, {
	    key: "isAtVersion",
	    value: function isAtVersion(version) {
	      return this.done.isAtVersion(version);
	    }

	    // :: (Object) → bool
	    // Rolls back all changes made since the given
	    // [version](#History.getVersion) was recorded. Returns `false` if
	    // that version was no longer found in the history, and thus the
	    // action could not be completed.

	  }, {
	    key: "backToVersion",
	    value: function backToVersion(version) {
	      var found = this.done.findVersion(version);
	      if (!found) return false;
	      var event = this.done.events[found.event];
	      if (found.event == this.done.events.length - 1 && found.step == event.length) return true;
	      var combined = this.done.events.slice(found.event + 1).reduce(function (comb, arr) {
	        return comb.concat(arr);
	      }, event.slice(found.step));
	      this.done.events.length = found.event + ((event.length = found.step) ? 1 : 0);
	      this.done.events.push(combined);

	      this.shift(this.done);
	      return true;
	    }
	  }, {
	    key: "rebased",
	    value: function rebased(newMaps, rebasedTransform, positions) {
	      this.done.rebased(newMaps, rebasedTransform, positions);
	      this.undone.rebased(newMaps, rebasedTransform, positions);
	      this.maybeScheduleCompression();
	    }
	  }, {
	    key: "maybeScheduleCompression",
	    value: function maybeScheduleCompression() {
	      this.maybeScheduleCompressionForBranch(this.done);
	      this.maybeScheduleCompressionForBranch(this.undone);
	    }
	  }, {
	    key: "maybeScheduleCompressionForBranch",
	    value: function maybeScheduleCompressionForBranch(branch) {
	      var _this4 = this;

	      window.clearTimeout(branch.compressTimeout);
	      if (branch.needsCompression()) branch.compressTimeout = window.setTimeout(function () {
	        if (branch.needsCompression()) branch.startCompression(_this4.pm.doc);
	      }, compressDelay);
	    }
	  }, {
	    key: "undoDepth",
	    get: function get() {
	      return this.done.events.length;
	    }

	    // :: number
	    // The amount of redoable events available.

	  }, {
	    key: "redoDepth",
	    get: function get() {
	      return this.undone.events.length;
	    }
	  }]);

	  return History;
	}();

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RangeStore = exports.MarkedRange = undefined;

	var _event = __webpack_require__(34);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// ;; A [marked range](#ProseMirror.markRange). Includes the methods
	// from the [event mixin](#EventMixin).

	var MarkedRange = exports.MarkedRange = function () {
	  function MarkedRange(from, to, options) {
	    _classCallCheck(this, MarkedRange);

	    this.options = options || {};
	    // :: ?Pos
	    // The current start position of the range. Updated whenever the
	    // editor's document is changed. Set to `null` when the marked
	    // range is [removed](#ProseMirror.removeRange).
	    this.from = from;
	    // :: ?Pos
	    // The current end position of the range. Updated whenever the
	    // editor's document is changed. Set to `null` when the marked
	    // range is [removed](#ProseMirror.removeRange).
	    this.to = to;
	  }

	  _createClass(MarkedRange, [{
	    key: "remove",
	    value: function remove() {
	      // :: (from: Pos, to: Pos) #path=MarkedRange#events#removed
	      // Signalled when the marked range is removed from the editor.
	      this.signal("removed", this.from, this.to.max(this.from));
	      this.from = this.to = null;
	    }
	  }]);

	  return MarkedRange;
	}();

	(0, _event.eventMixin)(MarkedRange);

	var RangeSorter = function () {
	  function RangeSorter() {
	    _classCallCheck(this, RangeSorter);

	    this.sorted = [];
	  }

	  _createClass(RangeSorter, [{
	    key: "find",
	    value: function find(at) {
	      var min = 0,
	          max = this.sorted.length;
	      for (;;) {
	        if (max < min + 10) {
	          for (var i = min; i < max; i++) {
	            if (this.sorted[i].at.cmp(at) >= 0) return i;
	          }return max;
	        }
	        var mid = min + max >> 1;
	        if (this.sorted[mid].at.cmp(at) > 0) max = mid;else min = mid;
	      }
	    }
	  }, {
	    key: "insert",
	    value: function insert(obj) {
	      this.sorted.splice(this.find(obj.at), 0, obj);
	    }
	  }, {
	    key: "remove",
	    value: function remove(at, range) {
	      var pos = this.find(at);
	      for (var dist = 0;; dist++) {
	        var leftPos = pos - dist - 1,
	            rightPos = pos + dist;
	        if (leftPos >= 0 && this.sorted[leftPos].range == range) {
	          this.sorted.splice(leftPos, 1);
	          return;
	        } else if (rightPos < this.sorted.length && this.sorted[rightPos].range == range) {
	          this.sorted.splice(rightPos, 1);
	          return;
	        }
	      }
	    }
	  }, {
	    key: "resort",
	    value: function resort() {
	      for (var i = 0; i < this.sorted.length; i++) {
	        var cur = this.sorted[i];
	        var at = cur.at = cur.type == "open" ? cur.range.from : cur.range.to;
	        var pos = i;
	        while (pos > 0 && this.sorted[pos - 1].at.cmp(at) > 0) {
	          this.sorted[pos] = this.sorted[pos - 1];
	          this.sorted[--pos] = cur;
	        }
	      }
	    }
	  }]);

	  return RangeSorter;
	}();

	var RangeStore = exports.RangeStore = function () {
	  function RangeStore(pm) {
	    _classCallCheck(this, RangeStore);

	    this.pm = pm;
	    this.ranges = [];
	    this.sorted = new RangeSorter();
	  }

	  _createClass(RangeStore, [{
	    key: "addRange",
	    value: function addRange(range) {
	      this.ranges.push(range);
	      this.sorted.insert({ type: "open", at: range.from, range: range });
	      this.sorted.insert({ type: "close", at: range.to, range: range });
	      this.pm.markRangeDirty(range);
	    }
	  }, {
	    key: "removeRange",
	    value: function removeRange(range) {
	      var found = this.ranges.indexOf(range);
	      if (found > -1) {
	        this.ranges.splice(found, 1);
	        this.sorted.remove(range.from, range);
	        this.sorted.remove(range.to, range);
	        this.pm.markRangeDirty(range);
	        range.remove();
	      }
	    }
	  }, {
	    key: "transform",
	    value: function transform(mapping) {
	      for (var i = 0; i < this.ranges.length; i++) {
	        var range = this.ranges[i];
	        range.from = mapping.map(range.from, range.options.inclusiveLeft ? -1 : 1).pos;
	        range.to = mapping.map(range.to, range.options.inclusiveRight ? 1 : -1).pos;
	        var diff = range.from.cmp(range.to);
	        if (range.options.removeWhenEmpty !== false && diff >= 0) {
	          this.removeRange(range);
	          i--;
	        } else if (diff > 0) {
	          range.to = range.from;
	        }
	      }
	      this.sorted.resort();
	    }
	  }, {
	    key: "activeRangeTracker",
	    value: function activeRangeTracker() {
	      return new RangeTracker(this.sorted.sorted);
	    }
	  }]);

	  return RangeStore;
	}();

	var RangeTracker = function () {
	  function RangeTracker(sorted) {
	    _classCallCheck(this, RangeTracker);

	    this.sorted = sorted;
	    this.pos = 0;
	    this.current = [];
	  }

	  _createClass(RangeTracker, [{
	    key: "advanceTo",
	    value: function advanceTo(pos) {
	      var next = undefined;
	      while (this.pos < this.sorted.length && (next = this.sorted[this.pos]).at.cmp(pos) <= 0) {
	        var className = next.range.options.className;
	        if (className) {
	          if (next.type == "open") this.current.push(className);else this.current.splice(this.current.indexOf(className), 1);
	        }
	        this.pos++;
	      }
	    }
	  }, {
	    key: "nextChangeBefore",
	    value: function nextChangeBefore(pos) {
	      for (;;) {
	        if (this.pos == this.sorted.length) return null;
	        var next = this.sorted[this.pos];
	        if (!next.range.options.className) this.pos++;else if (next.at.cmp(pos) >= 0) return null;else return next.at.offset;
	      }
	    }
	  }]);

	  return RangeTracker;
	}();

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _model = __webpack_require__(3);

	var _command = __webpack_require__(42);

	var _format = __webpack_require__(35);

	// # Mark types

	// ;; #path="strong:set" #kind=command
	// Add the [strong](#StrongMark) mark to the selected content.
	_model.StrongMark.register("command", "set", { derive: true, label: "Set strong" });

	// ;; #path="strong:unset" #kind=command
	// Remove the [strong](#StrongMark) mark from the selected content.
	_model.StrongMark.register("command", "unset", { derive: true, label: "Unset strong" });

	// ;; #path="strong:toggle" #kind=command
	// Toggle the [strong](#StrongMark) mark. If there is any strong
	// content in the selection, or there is no selection and the [active
	// marks](#ProseMirror.activeMarks) contain the strong mark, this
	// counts as [active](#Command.active) and executing it removes the
	// mark. Otherwise, this does not count as active, and executing it
	// makes the selected content strong.
	//
	// **Keybindings:** Mod-B
	_model.StrongMark.register("command", "toggle", {
	  derive: true,
	  label: "Toggle strong",
	  menu: {
	    group: "inline", rank: 20,
	    display: {
	      type: "icon",
	      width: 805, height: 1024,
	      path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z"
	    }
	  },
	  keys: ["Mod-B"]
	});

	// ;; #path=em:set #kind=command
	// Add the [emphasis](#EmMark) mark to the selected content.
	_model.EmMark.register("command", "set", { derive: true, label: "Add emphasis" });

	// ;; #path=em:unset #kind=command
	// Remove the [emphasis](#EmMark) mark from the selected content.
	_model.EmMark.register("command", "unset", { derive: true, label: "Remove emphasis" });

	// ;; #path=em:toggle #kind=command
	// Toggle the [emphasis](#EmMark) mark. If there is any emphasized
	// content in the selection, or there is no selection and the [active
	// marks](#ProseMirror.activeMarks) contain the emphasis mark, this
	// counts as [active](#Command.active) and executing it removes the
	// mark. Otherwise, this does not count as active, and executing it
	// makes the selected content emphasized.
	//
	// **Keybindings:** Mod-I
	_model.EmMark.register("command", "toggle", {
	  derive: true,
	  label: "Toggle emphasis",
	  menu: {
	    group: "inline", rank: 21,
	    display: {
	      type: "icon",
	      width: 585, height: 1024,
	      path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z"
	    }
	  },
	  keys: ["Mod-I"]
	});

	// ;; #path=code:set #kind=command
	// Add the [code](#CodeMark) mark to the selected content.
	_model.CodeMark.register("command", "set", { derive: true, label: "Set code style" });

	// ;; #path=code:unset #kind=command
	// Remove the [code](#CodeMark) mark from the selected content.
	_model.CodeMark.register("command", "unset", { derive: true, label: "Remove code style" });

	// ;; #path=code:toggle #kind=command
	// Toggle the [code](#CodeMark) mark. If there is any code-styled
	// content in the selection, or there is no selection and the [active
	// marks](#ProseMirror.activeMarks) contain the code mark, this
	// counts as [active](#Command.active) and executing it removes the
	// mark. Otherwise, this does not count as active, and executing it
	// styles the selected content as code.
	//
	// **Keybindings:** Mod-`
	_model.CodeMark.register("command", "toggle", {
	  derive: true,
	  label: "Toggle code style",
	  menu: {
	    group: "inline", rank: 22,
	    display: {
	      type: "icon",
	      width: 896, height: 1024,
	      path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z"
	    }
	  },
	  keys: ["Mod-`"]
	});

	var linkIcon = {
	  type: "icon",
	  width: 951, height: 1024,
	  path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z"
	};

	// ;; #path=link:unset #kind=command
	// Removes all links for the selected content, or, if there is no
	// selection, from the [active marks](#ProseMirror.activeMarks). Will
	// only [select](#Command.select) itself when there is a link in the
	// selection or active marks.
	_model.LinkMark.register("command", "unset", {
	  derive: true,
	  label: "Unlink",
	  menu: { group: "inline", rank: 30, display: linkIcon },
	  active: function active() {
	    return true;
	  }
	});

	// ;; #path=link:set #kind=command
	// Adds a link mark to the selection or set of [active
	// marks](#ProseMirror.activeMarks). Takes parameters to determine the
	// attributes of the link:
	//
	// **`href`**`: string`
	//   : The link's target.
	//
	// **`title`**`: string`
	//   : The link's title.
	//
	// Only selects itself when `unlink` isn't selected, so that only one
	// of the two is visible in the menu at any time.
	_model.LinkMark.register("command", "set", {
	  derive: {
	    inverseSelect: true,
	    params: [{ label: "Target", attr: "href" }, { label: "Title", attr: "title" }]
	  },
	  label: "Add link",
	  menu: { group: "inline", rank: 30, display: linkIcon }
	});

	// Node types

	// ;; #path=image:insert #kind=command
	// Replace the selection with an [image](#Image) node. Takes paramers
	// that specify the image's attributes:
	//
	// **`src`**`: string`
	//   : The URL of the image.
	//
	// **`alt`**`: string`
	//   : The alt text for the image.
	//
	// **`title`**`: string`
	//   : A title for the image.
	_model.Image.register("command", "insert", {
	  derive: {
	    params: [{ label: "Image URL", attr: "src" }, { label: "Description / alternative text", attr: "alt",
	      prefill: function prefill(pm) {
	        return (0, _command.selectedNodeAttr)(pm, this, "alt") || (0, _format.toText)(pm.doc.sliceBetween(pm.selection.from, pm.selection.to));
	      } }, { label: "Title", attr: "title" }]
	  },
	  label: "Insert image",
	  menu: {
	    group: "insert", rank: 20,
	    display: { type: "label", label: "Image" }
	  }
	});

	// ;; #path=bullet_list:wrap #kind=command
	// Wrap the selection in a bullet list.
	//
	// **Keybindings:** Alt-Right '*', Alt-Right '-'
	_model.BulletList.register("command", "wrap", {
	  derive: { list: true },
	  label: "Wrap the selection in a bullet list",
	  menu: {
	    group: "block", rank: 40,
	    display: {
	      type: "icon",
	      width: 768, height: 896,
	      path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z"
	    }
	  },
	  keys: ["Alt-Right '*'", "Alt-Right '-'"]
	});

	// ;; #path=ordered_list:wrap #kind=command
	// Wrap the selection in an ordered list.
	//
	// **Keybindings:** Alt-Right '1'
	_model.OrderedList.register("command", "wrap", {
	  derive: { list: true },
	  label: "Wrap the selection in an ordered list",
	  menu: {
	    group: "block", rank: 41,
	    display: {
	      type: "icon",
	      width: 768, height: 896,
	      path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z"
	    }
	  },
	  keys: ["Alt-Right '1'"]
	});

	// ;; #path=blockquote:wrap #kind=command
	// Wrap the selection in a block quote.
	//
	// **Keybindings:** Alt-Right '>', Alt-Right '"'
	_model.BlockQuote.register("command", "wrap", {
	  derive: true,
	  label: "Wrap the selection in a block quote",
	  menu: {
	    group: "block", rank: 45,
	    display: {
	      type: "icon",
	      width: 640, height: 896,
	      path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z"
	    }
	  },
	  keys: ["Alt-Right '>'", "Alt-Right '\"'"]
	});

	// ;; #path=hard_break:insert #kind=command
	// Replace the selection with a hard break node. If the selection is
	// in a node whose [type](#NodeType) has a truthy `isCode` property
	// (such as `CodeBlock` in the default schema), a regular newline is
	// inserted instead.
	//
	// **Keybindings:** Mod-Enter, Shift-Enter
	_model.HardBreak.register("command", "insert", {
	  label: "Insert hard break",
	  run: function run(pm) {
	    var _pm$selection = pm.selection;
	    var node = _pm$selection.node;
	    var from = _pm$selection.from;

	    if (node && node.isBlock) return false;else if (pm.doc.path(from.path).type.isCode) return pm.tr.typeText("\n").apply(pm.apply.scroll);else return pm.tr.replaceSelection(this.create()).apply(pm.apply.scroll);
	  },

	  keys: ["Mod-Enter", "Shift-Enter"]
	});

	// ;; #path=list_item:split #kind=command
	// If the selection is a text selection inside of a child of a list
	// item, split that child and the list item, and delete the selection.
	//
	// **Keybindings:** Enter
	_model.ListItem.register("command", "split", {
	  label: "Split the current list item",
	  run: function run(pm) {
	    var _pm$selection2 = pm.selection;
	    var from = _pm$selection2.from;
	    var to = _pm$selection2.to;
	    var node = _pm$selection2.node;

	    if (node && node.isBlock || from.path.length < 2 || !_model.Pos.samePath(from.path, to.path)) return false;
	    var toParent = from.shorten(),
	        grandParent = pm.doc.path(toParent.path);
	    if (grandParent.type != this) return false;
	    var nextType = to.offset == grandParent.child(toParent.offset).size ? pm.schema.defaultTextblockType() : null;
	    return pm.tr.delete(from, to).split(from, 2, nextType).apply(pm.apply.scroll);
	  },

	  keys: ["Enter(50)"]
	});

	var _loop = function _loop(i) {
	  // ;; #path=:heading::make_ #kind=command
	  // The commands `make1` to `make6` set the textblocks in the
	  // selection to become headers with the given level.
	  //
	  // **Keybindings:** Mod-H '1' through Mod-H '6'
	  _model.Heading.registerComputed("command", "make" + i, function (type) {
	    if (i <= type.maxLevel) return {
	      derive: { name: "make", attrs: { level: i } },
	      label: "Change to heading " + i,
	      keys: ["Mod-H '" + i + "'"],
	      menu: {
	        group: "textblockHeading", rank: 30 + i,
	        display: { type: "label", label: "Level " + i },
	        activeDisplay: "Head " + i
	      }
	    };
	  });
	};

	for (var i = 1; i <= 10; i++) {
	  _loop(i);
	} // ;; #path=paragraph:make #kind=command
	// Set the textblocks in the selection to be regular paragraphs.
	//
	// **Keybindings:** Mod-P
	_model.Paragraph.register("command", "make", {
	  derive: true,
	  label: "Change to paragraph",
	  keys: ["Mod-P"],
	  menu: {
	    group: "textblock", rank: 10,
	    display: { type: "label", label: "Plain" },
	    activeDisplay: "Plain"
	  }
	});

	// ;; #path=code_block:make #kind=command
	// Set the textblocks in the selection to be code blocks.
	//
	// **Keybindings:** Mod-\
	_model.CodeBlock.register("command", "make", {
	  derive: true,
	  label: "Change to code block",
	  keys: ["Mod-\\"],
	  menu: {
	    group: "textblock", rank: 20,
	    display: { type: "label", label: "Code" },
	    activeDisplay: "Code"
	  }
	});

	// ;; #path=horizontal_rule:insert #kind=command
	// Replace the selection with a horizontal rule.
	//
	// **Keybindings:** Mod-Shift-Minus
	_model.HorizontalRule.register("command", "insert", {
	  derive: true,
	  label: "Insert horizontal rule",
	  keys: ["Mod-Shift--"],
	  menu: { group: "insert", rank: 70, display: { type: "label", label: "Horizontal rule" } }
	});

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.ShortAnswer = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _input = __webpack_require__(55);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ShortAnswer = exports.ShortAnswer = function (_Block) {
		_inherits(ShortAnswer, _Block);

		function ShortAnswer() {
			_classCallCheck(this, ShortAnswer);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		ShortAnswer.prototype.create = function create(attrs, content, marks) {
			return _Block.prototype.create.call(this, attrs, [this.schema.nodes.paragraph.create(null, "", marks), this.schema.nodes.textfield.create(attrs)], marks);
		};

		_createClass(ShortAnswer, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					type: new _model.Attribute({ default: "text" }),
					size: new _model.Attribute({ default: "20" }),
					class: new _model.Attribute({ default: "widgets-shortanswer widgets-edit" })
				};
			}
		}]);

		return ShortAnswer;
	}(_model.Block);

	ShortAnswer.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "div", node.attrs);
	};

	(0, _utils.defParser)(ShortAnswer, "div", "widgets-shortanswer");

	ShortAnswer.register("command", "insert", {
		label: "Short Answer",
		run: function run(pm, name, size) {
			return pm.tr.replaceSelection(this.create({ name: name, size: size })).apply(pm.apply.scroll);
		},

		menu: { group: "question", rank: 71, display: { type: "label", label: "Short Answer" } },
		params: [{ name: "Name", attr: "name", label: "Short ID", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "name");
			},
			options: {
				pattern: _utils.namePattern,
				size: 10,
				title: _utils.nameTitle } }, { name: "Size", attr: "size", label: "Size in characters", type: "number", default: "20",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "size");
			},
			options: { min: 1, max: 80 } }]
	});

	(0, _utils.defParamsClick)(ShortAnswer, "shortanswer:insert");

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-shortanswer p:hover {\n    cursor: text;\n}\n\n\n.ProseMirror .widgets-shortanswer {\n\tborder-top: 1px solid #AAA;\n\tpadding: 8px;\n}\n\n");

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _input = __webpack_require__(56);

	Object.defineProperty(exports, "Input", {
	  enumerable: true,
	  get: function get() {
	    return _input.Input;
	  }
	});

	var _checkbox = __webpack_require__(57);

	Object.defineProperty(exports, "CheckBox", {
	  enumerable: true,
	  get: function get() {
	    return _checkbox.CheckBox;
	  }
	});

	var _radiobutton = __webpack_require__(58);

	Object.defineProperty(exports, "RadioButton", {
	  enumerable: true,
	  get: function get() {
	    return _radiobutton.RadioButton;
	  }
	});

	var _select = __webpack_require__(59);

	Object.defineProperty(exports, "Select", {
	  enumerable: true,
	  get: function get() {
	    return _select.Select;
	  }
	});

	var _textfield = __webpack_require__(60);

	Object.defineProperty(exports, "TextField", {
	  enumerable: true,
	  get: function get() {
	    return _textfield.TextField;
	  }
	});

	var _textarea = __webpack_require__(61);

	Object.defineProperty(exports, "TextArea", {
	  enumerable: true,
	  get: function get() {
	    return _textarea.TextArea;
	  }
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.Input = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Input = exports.Input = function (_Block) {
		_inherits(Input, _Block);

		function Input() {
			_classCallCheck(this, Input);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		_createClass(Input, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					type: new _model.Attribute({ default: "text" }),
					value: new _model.Attribute()
				};
			}
		}, {
			key: "contains",
			get: function get() {
				return null;
			}
		}]);

		return Input;
	}(_model.Block);

	(0, _utils.defParser)(Input, "widgets-input");

	Input.prototype.serializeDOM = function (node) {
		return (0, _dom.elt)("input", node.attrs);
	};

	(0, _dom.insertCSS)("\n\t\t\n.widgets-input {}\n\n");

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.CheckBox = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _input = __webpack_require__(56);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CheckBox = exports.CheckBox = function (_Input) {
		_inherits(CheckBox, _Input);

		function CheckBox() {
			_classCallCheck(this, CheckBox);

			return _possibleConstructorReturn(this, _Input.apply(this, arguments));
		}

		_createClass(CheckBox, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					type: new _model.Attribute({ default: "checkbox" }),
					value: new _model.Attribute({ default: "1" }),
					class: new _model.Attribute({ default: "widgets-checkbox" })
				};
			}
		}]);

		return CheckBox;
	}(_input.Input);

	(0, _utils.defParser)(CheckBox, "input", "widgets-checkbox");

	CheckBox.register("command", "insert", {
		label: "CheckBox",
		run: function run(pm, name) {
			return pm.tr.replaceSelection(this.create({ name: name })).apply(pm.apply.scroll);
		},

		params: [{ name: "Name", label: "Short ID", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "name");
			},
			options: {
				pattern: _utils.namePattern,
				size: 10,
				title: _utils.nameTitle }
		}]
	});

	(0, _utils.defParamsClick)(CheckBox, "checkbox:insert", ["all"]);

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-checkbox:hover {\n\tcursor: pointer;\n}\n\n");

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.RadioButton = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	var _input = __webpack_require__(56);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var RadioButton = exports.RadioButton = function (_Input) {
		_inherits(RadioButton, _Input);

		function RadioButton() {
			_classCallCheck(this, RadioButton);

			return _possibleConstructorReturn(this, _Input.apply(this, arguments));
		}

		_createClass(RadioButton, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					type: new _model.Attribute({ default: "radio" }),
					value: new _model.Attribute(),
					class: new _model.Attribute({ default: "widgets-radiobutton" })
				};
			}
		}]);

		return RadioButton;
	}(_input.Input);

	(0, _utils.defParser)(RadioButton, "input", "widgets-radiobutton");

	RadioButton.prototype.serializeDOM = function (node) {
		return (0, _dom.elt)("input", node.attrs);
	};

	(0, _dom.insertCSS)("\n\n.widgets-radiobutton {}\n\n");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.Select = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Select = exports.Select = function (_Inline) {
		_inherits(Select, _Inline);

		function Select() {
			_classCallCheck(this, Select);

			return _possibleConstructorReturn(this, _Inline.apply(this, arguments));
		}

		_createClass(Select, [{
			key: "contains",
			get: function get() {
				return null;
			}
		}, {
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					options: new _model.Attribute(),
					size: new _model.Attribute({ default: 1 }),
					multiple: new _model.Attribute({ default: "single" })
				};
			}
		}]);

		return Select;
	}(_model.Inline);

	(0, _utils.defParser)(Select, "select", "widgets-select");

	Select.prototype.serializeDOM = function (node) {
		var selection = node.attrs.multiple == "multiple";
		var select = (0, _dom.elt)("select", node.attrs);
		node.attrs.options.split(",").map(function (option) {
			select.appendChild((0, _dom.elt)("option", { value: option.trim() }, option));
		});
		return select;
	};

	Select.register("command", "insert", {
		label: "Select",
		run: function run(pm, name, options, size, multiple) {
			return pm.tr.replaceSelection(this.create({ name: name, options: options, size: size, multiple: multiple })).apply(pm.apply.scroll);
		},

		params: [{ name: "Name", label: "Short ID", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "name");
			},
			options: {
				pattern: _utils.namePattern,
				size: 10,
				title: _utils.nameTitle } }, { name: "Options", label: "comma separated names", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "options");
			} }, { name: "Size", label: "options displayed", type: "range",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "options");
			},
			options: { min: 1, max: 10, default: 1 }
		}, { name: "Selection", label: "Selection (single or multiple)", type: "select",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "multiple");
			},
			options: [{ value: "multiple", label: "multiple" }, { value: "single", label: "single" }]
		}]
	});

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-select {}\n\n");

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.TextField = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _input = __webpack_require__(56);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var TextField = exports.TextField = function (_Input) {
	  _inherits(TextField, _Input);

	  function TextField() {
	    _classCallCheck(this, TextField);

	    return _possibleConstructorReturn(this, _Input.apply(this, arguments));
	  }

	  _createClass(TextField, [{
	    key: "attrs",
	    get: function get() {
	      return {
	        name: new _model.Attribute(),
	        type: new _model.Attribute({ default: "text" }),
	        size: new _model.Attribute({ default: "20" }),
	        class: new _model.Attribute({ default: "widgets-textfield" })
	      };
	    }
	  }]);

	  return TextField;
	}(_input.Input);

	(0, _utils.defParser)(TextField, "input", "widgets-textfield");

	TextField.register("command", "insert", {
	  label: "TextField",
	  run: function run(pm, name) {
	    return pm.tr.replaceSelection(this.create({ name: name })).apply(pm.apply.scroll);
	  },

	  params: [{ name: "Name", label: "Short ID", type: "text",
	    prefill: function prefill(pm) {
	      return (0, _utils.selectedNodeAttr)(pm, this, "name");
	    },
	    options: {
	      pattern: _utils.namePattern,
	      size: 10,
	      title: _utils.nameTitle } }, { name: "Size", label: "Size in characters", type: "number", default: "20",
	    prefill: function prefill(pm) {
	      return (0, _utils.selectedNodeAttr)(pm, this, "size");
	    },
	    options: { min: 1, max: 80 } }]
	});

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-textfield:hover {\n\tcursor: pointer;\n}\n\n");

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.TextArea = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _input = __webpack_require__(56);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var TextArea = exports.TextArea = function (_Block) {
	  _inherits(TextArea, _Block);

	  function TextArea() {
	    _classCallCheck(this, TextArea);

	    return _possibleConstructorReturn(this, _Block.apply(this, arguments));
	  }

	  _createClass(TextArea, [{
	    key: "attrs",
	    get: function get() {
	      return {
	        name: new _model.Attribute(),
	        rows: new _model.Attribute(),
	        cols: new _model.Attribute(),
	        class: new _model.Attribute({ default: "widgets-textarea" })
	      };
	    }
	  }]);

	  return TextArea;
	}(_model.Block);

	(0, _utils.defParser)(TextArea, "textarea", "widgets-textarea");

	TextArea.prototype.serializeDOM = function (node, s) {
	  return (0, _dom.elt)("textarea", node.attrs);
	};
	TextArea.register("command", "insert", {
	  label: "TextArea",
	  run: function run(pm, name, rows, cols) {
	    return pm.tr.replaceSelection(this.create({ name: name, rows: rows, cols: cols })).apply(pm.apply.scroll);
	  },

	  params: [{ name: "Name", label: "Short ID", type: "text",
	    prefill: function prefill(pm) {
	      return (0, _utils.selectedNodeAttr)(pm, this, "name");
	    },
	    options: {
	      pattern: _utils.namePattern,
	      size: 10,
	      title: _utils.nameTitle
	    } }, { name: "Rows", label: "In lines", type: "number", default: "4", options: { min: 2, max: 24 },
	    prefill: function prefill(pm) {
	      return (0, _utils.selectedNodeAttr)(pm, this, "rows");
	    }
	  }, { name: "Columns", label: "In characters", type: "number", default: "40",
	    prefill: function prefill(pm) {
	      return (0, _utils.selectedNodeAttr)(pm, this, "cols");
	    },
	    options: { min: 2, max: 80 }
	  }]
	});

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-textarea:hover {\n\tcursor: pointer;\n}\n\n");

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.Essay = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Essay = exports.Essay = function (_Block) {
		_inherits(Essay, _Block);

		function Essay() {
			_classCallCheck(this, Essay);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		Essay.prototype.create = function create(attrs, content, marks) {
			return _Block.prototype.create.call(this, attrs, [this.schema.nodes.paragraph.create(null, "", marks), this.schema.nodes.textarea.create(attrs, null, marks)], marks);
		};

		_createClass(Essay, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					rows: new _model.Attribute(),
					cols: new _model.Attribute(),
					class: new _model.Attribute({ default: "widgets-essay widgets-edit" })
				};
			}
		}]);

		return Essay;
	}(_model.Block);

	(0, _utils.defParser)(Essay, "div", "widgets-essay");

	Essay.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "div", node.attrs);
	};

	Essay.register("command", "insert", {
		label: "Essay",
		run: function run(pm, name, rows, cols) {
			var _pm$selection = pm.selection;
			var from = _pm$selection.from;
			var to = _pm$selection.to;
			var node = _pm$selection.node;

			if (node && node.type == this) {
				var tr = pm.tr.setNodeType(from, this, { name: name, rows: rows, cols: cols }).apply();
				return tr;
			} else return pm.tr.replaceSelection(this.create({ name: name, rows: rows, cols: cols })).apply(pm.apply.scroll);
		},
		select: function select(pm) {
			return pm.doc.path(pm.selection.from.path).type.canContainType(this);
		},

		menu: { group: "question", rank: 72, display: { type: "label", label: "Essay" }, select: "ignore" },
		params: [{ name: "Name", attr: "name", label: "Short ID", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "name");
			},
			options: {
				pattern: _utils.namePattern,
				size: 10,
				title: _utils.nameTitle
			} }, { name: "Rows", attr: "rows", label: "In lines lines", type: "number", default: "4", options: { min: 2, max: 24 },
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "rows");
			}
		}, { name: "Columns", attr: "cols", label: "In characters", type: "number", default: "40",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "cols");
			},
			options: { min: 2, max: 80 }
		}]
	});

	(0, _utils.defParamsClick)(Essay, "essay:insert");

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-essay p:hover {\n    cursor: text;\n}\n\n.ProseMirror .widgets-essay {\n\tborder-top: 1px solid #AAA;\n\tpadding: 8px;\n}\n\n");

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.MultipleChoice = exports.Choice = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Choice = exports.Choice = function (_Block) {
		_inherits(Choice, _Block);

		function Choice() {
			_classCallCheck(this, Choice);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		Choice.prototype.create = function create(attrs, content, marks) {
			content = content ? content.content[0] : this.schema.nodes.textbox.create(null, "", marks);
			return _Block.prototype.create.call(this, attrs, [this.schema.nodes.radiobutton.create(attrs), content], marks);
		};

		_createClass(Choice, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					value: new _model.Attribute(),
					class: new _model.Attribute({ default: "widgets-choice" })
				};
			}
		}]);

		return Choice;
	}(_model.Block);

	var MultipleChoice = exports.MultipleChoice = function (_Block2) {
		_inherits(MultipleChoice, _Block2);

		function MultipleChoice() {
			_classCallCheck(this, MultipleChoice);

			return _possibleConstructorReturn(this, _Block2.apply(this, arguments));
		}

		MultipleChoice.prototype.create = function create(attrs, content, marks) {
			return _Block2.prototype.create.call(this, attrs, [this.schema.nodes.paragraph.create(null, "", marks), this.schema.nodes.choice.create({ name: attrs.name, value: 1 })], marks);
		};

		_createClass(MultipleChoice, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					class: new _model.Attribute({ default: "widgets-multiplechoice widgets-edit" })
				};
			}
		}, {
			key: "isList",
			get: function get() {
				return true;
			}
		}]);

		return MultipleChoice;
	}(_model.Block);

	(0, _utils.defParser)(Choice, "div", "widgets-choice");
	(0, _utils.defParser)(MultipleChoice, "div", "widgets-multiplechoice");

	Choice.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "div", node.attrs);
	};

	MultipleChoice.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "div", node.attrs);
	};

	function renumber(pm, pos) {
		var cl = pm.doc.path(pos.path),
		    i = 1;
		cl.forEach(function (node, start) {
			if (start > 0) pm.tr.setNodeType(new _model.Pos(pos.path, start), node.type, { name: cl.attrs.name, value: i++ }).apply();
		});
	}

	Choice.register("command", "split", {
		label: "Split the current choice",
		run: function run(pm) {
			var _pm$selection = pm.selection;
			var from = _pm$selection.from;
			var to = _pm$selection.to;
			var node = _pm$selection.node;

			if (node && node.isBlock || from.path.length < 2 || !_model.Pos.samePath(from.path, to.path)) return false;
			var toParent = from.shorten(),
			    parent = pm.doc.path(toParent.path);
			if (parent.type != this) return false;
			var tr = pm.tr.delete(from, to).split(from, 2).apply(pm.apply.scroll);
			//renumber(pm, toParent.shorten())
			return tr;
		},

		keys: ["Enter(10)"]
	});

	Choice.register("command", "delete", {
		label: "delete text, this choice or choicelist",
		run: function run(pm) {
			var _pm$selection2 = pm.selection;
			var from = _pm$selection2.from;
			var to = _pm$selection2.to;
			var head = _pm$selection2.head;

			if (from.offset > 0) return pm.tr.delete(from, to).apply(pm.apply.scroll);
			var toCH = from.shorten(),
			    ch = pm.doc.path(toCH.path);
			var toMC = toCH.shorten(),
			    mc = pm.doc.path(toMC.path);
			// if more than one choice then delete choice otherwise delete whole multiplechoice
			if (mc.size > 1) {
				var cut = (0, _utils.getPosInParent)(pm, toMC, ch);
				pm.tr.lift(head).apply();
				return pm.tr.delete(cut, cut.move(1)).apply(pm.apply.scroll);
				//renumber(pm, toMC)
			} else {
					// don't delete if first choice has content
					if (pm.doc.path(from.path).size > 0) return true;
					var cut = (0, _utils.getPosInParent)(pm, toMC.shorten(), mc);
					return pm.tr.delete(cut, cut.move(1)).apply(pm.apply.scroll);
				}
		},

		keys: ["Backspace(20)", "Mod-Backspace(20)"]
	});

	MultipleChoice.register("command", "insert", {
		label: "MultipleChoice",
		run: function run(pm, name) {
			var _pm$selection3 = pm.selection;
			var from = _pm$selection3.from;
			var to = _pm$selection3.to;
			var node = _pm$selection3.node;

			if (node && node.type == this) {
				var tr = pm.tr.setNodeType(from, this, { name: name }).apply();
				//renumber(pm,Pos.from(from.toPath().concat(from.offset),0))
				return tr;
			} else return pm.tr.replaceSelection(this.create({ name: name })).apply(pm.apply.scroll);
		},
		select: function select(pm) {
			return true;
		},

		menu: { group: "question", rank: 70, display: { type: "label", label: "MultipleChoice" } },
		params: [{ name: "Name", attr: "name", label: "Short ID", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "name");
			},
			options: {
				pattern: _utils.namePattern,
				size: 10,
				title: _utils.nameTitle }
		}]
	});

	(0, _utils.defParamsClick)(MultipleChoice, "multiplechoice:insert");

	(0, _dom.insertCSS)("\n\n.widgets-choice input {\n\tfloat: left;\n}\n\n.widgets-multiplechoice {\n\tborder-top: 1px solid #DDD;\n\tpadding: 8px;\n}\n\n.ProseMirror .widgets-multiplechoice p:hover {\n    cursor: text;\n}\n\n.ProseMirror .widgets-choice:hover {\n\tcursor: text;\n}\n\n");

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.CheckList = exports.CheckItem = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _textbox = __webpack_require__(2);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CheckItem = exports.CheckItem = function (_Block) {
		_inherits(CheckItem, _Block);

		function CheckItem() {
			_classCallCheck(this, CheckItem);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		CheckItem.prototype.create = function create(attrs, content, marks) {
			content = content ? content.content[0] : this.schema.nodes.textbox.create(null, "", marks);
			return _Block.prototype.create.call(this, attrs, [this.schema.nodes.checkbox.create(attrs), content], marks);
		};

		_createClass(CheckItem, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					value: new _model.Attribute(),
					class: new _model.Attribute({ default: "widgets-checkitem" })
				};
			}
		}], [{
			key: "kinds",
			get: function get() {
				return "checkitem";
			}
		}]);

		return CheckItem;
	}(_model.Block);

	var CheckList = exports.CheckList = function (_Block2) {
		_inherits(CheckList, _Block2);

		function CheckList() {
			_classCallCheck(this, CheckList);

			return _possibleConstructorReturn(this, _Block2.apply(this, arguments));
		}

		CheckList.prototype.create = function create(attrs, content, marks) {
			return _Block2.prototype.create.call(this, attrs, [this.schema.nodes.paragraph.create(null, "", marks), this.schema.nodes.checkitem.create({ name: attrs.name, value: 1 }, content, marks)]);
		};

		_createClass(CheckList, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					class: new _model.Attribute({ default: "widgets-checklist widgets-edit" })
				};
			}
		}, {
			key: "isList",
			get: function get() {
				return true;
			}
		}], [{
			key: "kinds",
			get: function get() {
				return _Block2.kinds + " checklist";
			}
		}, {
			key: "contains",
			get: function get() {
				return "checkitem";
			}
		}]);

		return CheckList;
	}(_model.Block);

	(0, _utils.defParser)(CheckItem, "div", "widgets-checkitem");
	(0, _utils.defParser)(CheckList, "div", "widgets-checklist");

	CheckItem.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "div", node.attrs);
	};

	CheckList.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "div", node.attrs);
	};

	function renumber(pm, pos) {
		var cl = pm.doc.path(pos.path),
		    i = 1;
		cl.forEach(function (node, start) {
			pm.tr.setNodeType(new _model.Pos(pos.path, start), node.type, { name: node.attrs.name + "-" + i, value: i++ }).apply();
		});
	}

	CheckItem.register("command", "split", {
		label: "Split the current checkitem",
		run: function run(pm) {
			var _pm$selection = pm.selection;
			var from = _pm$selection.from;
			var to = _pm$selection.to;
			var node = _pm$selection.node;

			if (node && node.isBlock || from.path.length < 2 || !_model.Pos.samePath(from.path, to.path)) return false;
			var toParent = from.shorten(),
			    parent = pm.doc.path(toParent.path);
			if (parent.type != this) return false;
			var tr = pm.tr.delete(from, to).split(from, 2).apply(pm.apply.scroll);
			renumber(pm, toParent.shorten());
			return tr;
		},

		keys: ["Enter(10)"]
	});

	CheckItem.register("command", "delete", {
		label: "delete this checkitem or checklist",
		run: function run(pm) {
			var _pm$selection2 = pm.selection;
			var from = _pm$selection2.from;
			var to = _pm$selection2.to;
			var head = _pm$selection2.head;

			if (from.offset > 0) return pm.tr.delete(from, to).apply(pm.apply.scroll);
			var toCH = from.shorten(),
			    ch = pm.doc.path(toCH.path);
			var toMC = toCH.shorten(),
			    mc = pm.doc.path(toMC.path);
			// if more than one choice then delete choice otherwise delete whole multiplechoice
			if (mc.size > 1) {
				var cut = getPosInParent(pm, toMC, ch);
				pm.tr.lift(head).apply();
				return pm.tr.delete(cut, cut.move(1)).apply(pm.apply.scroll);
				//renumber(pm, toMC)
			} else {
					// don't delete if still content in first choice
					if (pm.doc.path(from.path).size > 0) return true;
					var cut = getPosInParent(pm, toMC.shorten(), mc);
					return pm.tr.delete(cut, cut.move(1)).apply(pm.apply.scroll);
				}
		},

		keys: ["Backspace(20)", "Mod-Backspace(20)"]
	});

	CheckList.register("command", "insert", {
		label: "Check List",
		run: function run(pm, name) {
			var _pm$selection3 = pm.selection;
			var from = _pm$selection3.from;
			var to = _pm$selection3.to;
			var node = _pm$selection3.node;

			if (node && node.type == this) {
				var tr = pm.tr.setNodeType(from, this, { name: name }).apply();
				renumber(pm, _model.Pos.from(from.toPath().concat(from.offset), 0));
				return tr;
			} else return pm.tr.replaceSelection(this.create({ name: name })).apply(pm.apply.scroll);
		},
		select: function select(pm) {
			return true;
		},

		menu: { group: "question", rank: 70, display: { type: "label", label: "CheckList" } },
		params: [{ name: "Name", attr: "name", label: "Short ID", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "name");
			},
			options: {
				pattern: _utils.namePattern,
				size: 10,
				title: _utils.nameTitle } }]
	});

	(0, _utils.defParamsClick)(CheckList, "checklist:insert");

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-checkitem input {\n\tfloat: left;\n}\n\n.widgets-checklist {\n\tborder-top: 1px solid #DDD;\n\tpadding-left: 8px;\n\tpadding-top: 8px;\n}\n.ProseMirror .widgets-checklist p {\n    cursor: text;\n}\n\n\n.ProseMirror .widgets-checkitem {\n\tcursor: text;\n}\n\n\n");

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.Scale = exports.ScaleDisplay = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ScaleDisplay = exports.ScaleDisplay = function (_Block) {
		_inherits(ScaleDisplay, _Block);

		function ScaleDisplay() {
			_classCallCheck(this, ScaleDisplay);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		_createClass(ScaleDisplay, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					startvalue: new _model.Attribute({ default: "1" }),
					startlabel: new _model.Attribute({ default: "low" }),
					endvalue: new _model.Attribute({ default: "10" }),
					endlabel: new _model.Attribute({ default: "high" })
				};
			}
		}]);

		return ScaleDisplay;
	}(_model.Block);

	ScaleDisplay.prototype.serializeDOM = function (node, s) {
		var para = (0, _dom.elt)("div", { contenteditable: false });
		para.appendChild((0, _dom.elt)("span", null, node.attrs.startlabel + " "));
		var startVal = Number(node.attrs.startvalue);
		var endVal = Number(node.attrs.endvalue);
		if (startVal < endVal) for (var i = startVal; i <= endVal; i++) {
			var _name = node.attrs.name + i;
			para.appendChild((0, _dom.elt)("span", { class: "widgets-scaleitem" }, (0, _dom.elt)("label", { for: _name }, i.toString()), (0, _dom.elt)("input", { id: _name, name: node.attrs.name, type: "radio", value: i })));
		} else for (var i = startVal; i >= endVal; i--) {
			para.appendChild((0, _dom.elt)("span", { class: "widgets-scaleitem" }, (0, _dom.elt)("label", { for: name }, i.toString()), (0, _dom.elt)("input", { id: name, name: node.attrs.name, type: "radio", value: i })));
		}
		para.appendChild((0, _dom.elt)("span", null, " " + node.attrs.endlabel));
		return para;
	};

	var Scale = exports.Scale = function (_Block2) {
		_inherits(Scale, _Block2);

		function Scale() {
			_classCallCheck(this, Scale);

			return _possibleConstructorReturn(this, _Block2.apply(this, arguments));
		}

		Scale.prototype.create = function create(attrs, content, marks) {
			return _Block2.prototype.create.call(this, attrs, [this.schema.nodes.paragraph.create(null, "", marks), this.schema.nodes.scaledisplay.create(attrs, null, marks)], marks);
		};

		_createClass(Scale, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					startvalue: new _model.Attribute({ default: "1" }),
					startlabel: new _model.Attribute({ default: "low" }),
					endvalue: new _model.Attribute({ default: "10" }),
					endlabel: new _model.Attribute({ default: "high" }),
					class: new _model.Attribute({ default: "widgets-scale widgets-edit" })
				};
			}
		}], [{
			key: "contains",
			get: function get() {
				return "text";
			}
		}]);

		return Scale;
	}(_model.Block);

	(0, _utils.defParser)(Scale, "div", "widgets-scale");

	Scale.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "div", node.attrs);
	};

	Scale.register("command", "insert", {
		label: "Scale",
		run: function run(pm, name, startvalue, startlabel, endvalue, endlabel) {
			var _pm$selection = pm.selection;
			var from = _pm$selection.from;
			var to = _pm$selection.to;
			var node = _pm$selection.node;

			if (node && node.type == this) {
				return pm.tr.setNodeType(from, this, { name: name, startvalue: startvalue, startlabel: startlabel, endvalue: endvalue, endlabel: endlabel }).apply(pm.apply.scroll);
			} else return pm.tr.replaceSelection(this.create({ name: name, startvalue: startvalue, startlabel: startlabel, endvalue: endvalue, endlabel: endlabel })).apply(pm.apply.scroll);
		},

		menu: { group: "question", rank: 74, display: { type: "label", label: "Scale" } },
		params: [{ name: "Name", attr: "name", label: "Short ID", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "name");
			},
			options: {
				pattern: _utils.namePattern,
				size: 10,
				title: _utils.nameTitle } }, { label: "Start value", attr: "startvalue", type: "number", default: 1,
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "startvalue");
			} }, { name: "Start Label", attr: "startlabel", label: "Text on left", type: "text", default: "low",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "startlabel");
			} }, { label: "End value", attr: "endvalue", type: "number", default: 10,
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "endvalue");
			} }, { name: "End Label", attr: "endlabel", label: "Text on right", type: "text", default: "high",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "endlabel");
			} }]
	});

	(0, _utils.defParamsClick)(Scale, "scale:insert");

	(0, _dom.insertCSS)("\n\n.widgets-scaleitem {\n\tdisplay: inline-block;\n\ttext-align: center;\n    padding: 4px;\n}\n\n.widgets-scaleitem input {\n\tdisplay: block;\n}\n\n.widgets-scale span {\n\tvertical-align: middle;\n\tfont-weight: normal;\n}\n\n.ProseMirror .widgets-scale p:hover {\n    cursor: text;\n}\n\n.widgets-scale {\n\tpadding: 8px;\n    border-top: 1px solid #AAA;\n}\n\n.widgets-scale div {\n\tdisplay: inline-block;\n\tpadding: 4px;\n\tbackground: #EEE;\n    border-radius: 6px;\n    border: 1px solid #AAA;\n}\n");

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.Selection = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _input = __webpack_require__(55);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Selection = exports.Selection = function (_Block) {
		_inherits(Selection, _Block);

		function Selection() {
			_classCallCheck(this, Selection);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		Selection.prototype.create = function create(attrs, content, marks) {
			return _Block.prototype.create.call(this, attrs, [this.schema.nodes.paragraph.create(null, "", marks), this.schema.nodes.select.create(attrs, null, marks)], marks);
		};

		_createClass(Selection, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					options: new _model.Attribute(),
					size: new _model.Attribute({ default: 1 }),
					multiple: new _model.Attribute({ default: "single" }),
					class: new _model.Attribute({ default: "widgets-selection widgets-edit" })
				};
			}
		}]);

		return Selection;
	}(_model.Block);

	(0, _utils.defParser)(Selection, "div", "widgets-selection");

	Selection.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "div", node.attrs);
	};

	Selection.register("command", "insert", {
		label: "Selection",
		run: function run(pm, name, options, size, multiple) {
			var _pm$selection = pm.selection;
			var from = _pm$selection.from;
			var to = _pm$selection.to;
			var node = _pm$selection.node;

			if (node && node.type == this) {
				var tr = pm.tr.setNodeType(from, this, { name: name, options: options, size: size, multiple: multiple }).apply();
				return tr;
			} else return pm.tr.replaceSelection(this.create({ name: name, options: options, size: size, multiple: multiple })).apply(pm.apply.scroll);
		},

		menu: { group: "question", rank: 75, display: { type: "label", label: "Selection" } },
		params: [{ name: "Name", attr: "name", label: "Short ID", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "name");
			},
			options: {
				pattern: _utils.namePattern,
				size: 10,
				title: _utils.nameTitle } }, { name: "Options", attr: "options", label: "comma separated names", type: "text",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "options");
			} }, { name: "Size", attr: "size", label: "options displayed", type: "number", default: 1,
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "size");
			},
			options: { min: 1, max: 10 }
		}, { name: "Selection", attr: "multiple", label: "Selection (single or multiple)", type: "select", default: "single",
			prefill: function prefill(pm) {
				return (0, _utils.selectedNodeAttr)(pm, this, "multiple");
			},
			options: [{ value: "multiple", label: "multiple" }, { value: "single", label: "single" }]
		}]
	});

	(0, _utils.defParamsClick)(Selection, "selection:insert");

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-selection p:hover {\n    cursor: text;\n}\n\n.ProseMirror .widgets-selection {\n\tborder-top: 1px solid #AAA;\n\tpadding: 8px;\n}\n\n");

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _blockmath = __webpack_require__(68);

	Object.defineProperty(exports, "BlockMath", {
	  enumerable: true,
	  get: function get() {
	    return _blockmath.BlockMath;
	  }
	});

	var _website = __webpack_require__(75);

	Object.defineProperty(exports, "Website", {
	  enumerable: true,
	  get: function get() {
	    return _website.Website;
	  }
	});

	var _inlinemath = __webpack_require__(76);

	Object.defineProperty(exports, "InlineMath", {
	  enumerable: true,
	  get: function get() {
	    return _inlinemath.InlineMath;
	  }
	});

	var _image = __webpack_require__(77);

	Object.defineProperty(exports, "Image", {
	  enumerable: true,
	  get: function get() {
	    return _image.Image;
	  }
	});

	var _spreadsheet = __webpack_require__(78);

	Object.defineProperty(exports, "SpreadSheet", {
	  enumerable: true,
	  get: function get() {
	    return _spreadsheet.SpreadSheet;
	  }
	});

	var _carryforward = __webpack_require__(79);

	Object.defineProperty(exports, "CarryForward", {
	  enumerable: true,
	  get: function get() {
	    return _carryforward.CarryForward;
	  }
	});

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.BlockMath = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(69);
	__webpack_require__(70);
	__webpack_require__(71);
	__webpack_require__(72);
	__webpack_require__(73);
	__webpack_require__(74);

	var BlockMath = exports.BlockMath = function (_Block) {
		_inherits(BlockMath, _Block);

		function BlockMath() {
			_classCallCheck(this, BlockMath);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		_createClass(BlockMath, [{
			key: "attrs",
			get: function get() {
				return {
					tex: new _model.Attribute({ default: "" })
				};
			}
		}, {
			key: "contains",
			get: function get() {
				return null;
			}
		}]);

		return BlockMath;
	}(_model.Block);

	(0, _utils.defParser)(BlockMath, "div", "widgets-blockmath");

	BlockMath.prototype.serializeDOM = function (node) {
		if (node.rendered) {
			node.rendered = node.rendered.cloneNode(true);
		} else {
			node.rendered = (0, _dom.elt)("div", { class: "widgets-blockmath widgets-edit" }, "\\[" + node.attrs.tex + "\\]");
			// wait until node is attached to document to render
			MathJax.Hub.Queue(["Delay", MathJax.Callback, 100], ["Typeset", MathJax.Hub, node.rendered]);
		}
		return node.rendered;
	};

	BlockMath.register("command", "insert", {
		derive: {
			params: [{ name: "Latex", attr: "tex", label: "Latex Expression", type: "text",
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "tex");
				} }]
		},
		label: "BlockMath",
		menu: { group: "content", rank: 73, display: { type: "label", label: "Block Math" } }
	});

	(0, _utils.defParamsClick)(BlockMath, "blockmath:insert");

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-blockmath {}\n\n");

/***/ },
/* 69 */
/***/ function(module, exports) {

	/*
	 *  /MathJax.js
	 *
	 *  Copyright (c) 2009-2015 The MathJax Consortium
	 *
	 *  Licensed under the Apache License, Version 2.0 (the "License");
	 *  you may not use this file except in compliance with the License.
	 *  You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 *  Unless required by applicable law or agreed to in writing, software
	 *  distributed under the License is distributed on an "AS IS" BASIS,
	 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *  See the License for the specific language governing permissions and
	 *  limitations under the License.
	 */

	if(document.getElementById&&document.childNodes&&document.createElement){if(!(window.MathJax&&MathJax.Hub)){if(window.MathJax){window.MathJax={AuthorConfig:window.MathJax}}else{window.MathJax={}}MathJax.isPacked=true;MathJax.version="2.6.1";MathJax.fileversion="2.6.1";MathJax.cdnVersion="2.6.1";MathJax.cdnFileVersions={};(function(d){var b=window[d];if(!b){b=window[d]={}}var e=[];var c=function(f){var g=f.constructor;if(!g){g=function(){}}for(var h in f){if(h!=="constructor"&&f.hasOwnProperty(h)){g[h]=f[h]}}return g};var a=function(){return function(){return arguments.callee.Init.call(this,arguments)}};b.Object=c({constructor:a(),Subclass:function(f,h){var g=a();g.SUPER=this;g.Init=this.Init;g.Subclass=this.Subclass;g.Augment=this.Augment;g.protoFunction=this.protoFunction;g.can=this.can;g.has=this.has;g.isa=this.isa;g.prototype=new this(e);g.prototype.constructor=g;g.Augment(f,h);return g},Init:function(f){var g=this;if(f.length===1&&f[0]===e){return g}if(!(g instanceof f.callee)){g=new f.callee(e)}return g.Init.apply(g,f)||g},Augment:function(f,g){var h;if(f!=null){for(h in f){if(f.hasOwnProperty(h)){this.protoFunction(h,f[h])}}if(f.toString!==this.prototype.toString&&f.toString!=={}.toString){this.protoFunction("toString",f.toString)}}if(g!=null){for(h in g){if(g.hasOwnProperty(h)){this[h]=g[h]}}}return this},protoFunction:function(g,f){this.prototype[g]=f;if(typeof f==="function"){f.SUPER=this.SUPER.prototype}},prototype:{Init:function(){},SUPER:function(f){return f.callee.SUPER},can:function(f){return typeof(this[f])==="function"},has:function(f){return typeof(this[f])!=="undefined"},isa:function(f){return(f instanceof Object)&&(this instanceof f)}},can:function(f){return this.prototype.can.call(this,f)},has:function(f){return this.prototype.has.call(this,f)},isa:function(g){var f=this;while(f){if(f===g){return true}else{f=f.SUPER}}return false},SimpleSUPER:c({constructor:function(f){return this.SimpleSUPER.define(f)},define:function(f){var h={};if(f!=null){for(var g in f){if(f.hasOwnProperty(g)){h[g]=this.wrap(g,f[g])}}if(f.toString!==this.prototype.toString&&f.toString!=={}.toString){h.toString=this.wrap("toString",f.toString)}}return h},wrap:function(i,h){if(typeof(h)!=="function"||!h.toString().match(/\.\s*SUPER\s*\(/)){return h}var g=function(){this.SUPER=g.SUPER[i];try{var f=h.apply(this,arguments)}catch(j){delete this.SUPER;throw j}delete this.SUPER;return f};g.toString=function(){return h.toString.apply(h,arguments)};return g}})})})("MathJax");(function(BASENAME){var BASE=window[BASENAME];if(!BASE){BASE=window[BASENAME]={}}var CALLBACK=function(data){var cb=function(){return arguments.callee.execute.apply(arguments.callee,arguments)};for(var id in CALLBACK.prototype){if(CALLBACK.prototype.hasOwnProperty(id)){if(typeof(data[id])!=="undefined"){cb[id]=data[id]}else{cb[id]=CALLBACK.prototype[id]}}}cb.toString=CALLBACK.prototype.toString;return cb};CALLBACK.prototype={isCallback:true,hook:function(){},data:[],object:window,execute:function(){if(!this.called||this.autoReset){this.called=!this.autoReset;return this.hook.apply(this.object,this.data.concat([].slice.call(arguments,0)))}},reset:function(){delete this.called},toString:function(){return this.hook.toString.apply(this.hook,arguments)}};var ISCALLBACK=function(f){return(typeof(f)==="function"&&f.isCallback)};var EVAL=function(code){return eval.call(window,code)};var TESTEVAL=function(){EVAL("var __TeSt_VaR__ = 1");if(window.__TeSt_VaR__){try{delete window.__TeSt_VaR__}catch(error){window.__TeSt_VaR__=null}}else{if(window.execScript){EVAL=function(code){BASE.__code=code;code="try {"+BASENAME+".__result = eval("+BASENAME+".__code)} catch(err) {"+BASENAME+".__result = err}";window.execScript(code);var result=BASE.__result;delete BASE.__result;delete BASE.__code;if(result instanceof Error){throw result}return result}}else{EVAL=function(code){BASE.__code=code;code="try {"+BASENAME+".__result = eval("+BASENAME+".__code)} catch(err) {"+BASENAME+".__result = err}";var head=(document.getElementsByTagName("head"))[0];if(!head){head=document.body}var script=document.createElement("script");script.appendChild(document.createTextNode(code));head.appendChild(script);head.removeChild(script);var result=BASE.__result;delete BASE.__result;delete BASE.__code;if(result instanceof Error){throw result}return result}}}TESTEVAL=null};var USING=function(args,i){if(arguments.length>1){if(arguments.length===2&&!(typeof arguments[0]==="function")&&arguments[0] instanceof Object&&typeof arguments[1]==="number"){args=[].slice.call(args,i)}else{args=[].slice.call(arguments,0)}}if(args instanceof Array&&args.length===1){args=args[0]}if(typeof args==="function"){if(args.execute===CALLBACK.prototype.execute){return args}return CALLBACK({hook:args})}else{if(args instanceof Array){if(typeof(args[0])==="string"&&args[1] instanceof Object&&typeof args[1][args[0]]==="function"){return CALLBACK({hook:args[1][args[0]],object:args[1],data:args.slice(2)})}else{if(typeof args[0]==="function"){return CALLBACK({hook:args[0],data:args.slice(1)})}else{if(typeof args[1]==="function"){return CALLBACK({hook:args[1],object:args[0],data:args.slice(2)})}}}}else{if(typeof(args)==="string"){if(TESTEVAL){TESTEVAL()}return CALLBACK({hook:EVAL,data:[args]})}else{if(args instanceof Object){return CALLBACK(args)}else{if(typeof(args)==="undefined"){return CALLBACK({})}}}}}throw Error("Can't make callback from given data")};var DELAY=function(time,callback){callback=USING(callback);callback.timeout=setTimeout(callback,time);return callback};var WAITFOR=function(callback,signal){callback=USING(callback);if(!callback.called){WAITSIGNAL(callback,signal);signal.pending++}};var WAITEXECUTE=function(){var signals=this.signal;delete this.signal;this.execute=this.oldExecute;delete this.oldExecute;var result=this.execute.apply(this,arguments);if(ISCALLBACK(result)&&!result.called){WAITSIGNAL(result,signals)}else{for(var i=0,m=signals.length;i<m;i++){signals[i].pending--;if(signals[i].pending<=0){signals[i].call()}}}};var WAITSIGNAL=function(callback,signals){if(!(signals instanceof Array)){signals=[signals]}if(!callback.signal){callback.oldExecute=callback.execute;callback.execute=WAITEXECUTE;callback.signal=signals}else{if(signals.length===1){callback.signal.push(signals[0])}else{callback.signal=callback.signal.concat(signals)}}};var AFTER=function(callback){callback=USING(callback);callback.pending=0;for(var i=1,m=arguments.length;i<m;i++){if(arguments[i]){WAITFOR(arguments[i],callback)}}if(callback.pending===0){var result=callback();if(ISCALLBACK(result)){callback=result}}return callback};var HOOKS=MathJax.Object.Subclass({Init:function(reset){this.hooks=[];this.remove=[];this.reset=reset;this.running=false},Add:function(hook,priority){if(priority==null){priority=10}if(!ISCALLBACK(hook)){hook=USING(hook)}hook.priority=priority;var i=this.hooks.length;while(i>0&&priority<this.hooks[i-1].priority){i--}this.hooks.splice(i,0,hook);return hook},Remove:function(hook){for(var i=0,m=this.hooks.length;i<m;i++){if(this.hooks[i]===hook){if(this.running){this.remove.push(i)}else{this.hooks.splice(i,1)}return}}},Execute:function(){var callbacks=[{}];this.running=true;for(var i=0,m=this.hooks.length;i<m;i++){if(this.reset){this.hooks[i].reset()}var result=this.hooks[i].apply(window,arguments);if(ISCALLBACK(result)&&!result.called){callbacks.push(result)}}this.running=false;if(this.remove.length){this.RemovePending()}if(callbacks.length===1){return null}if(callbacks.length===2){return callbacks[1]}return AFTER.apply({},callbacks)},RemovePending:function(){this.remove=this.remove.sort();for(var i=this.remove.length-1;i>=0;i--){this.hooks.splice(i,1)}this.remove=[]}});var EXECUTEHOOKS=function(hooks,data,reset){if(!hooks){return null}if(!(hooks instanceof Array)){hooks=[hooks]}if(!(data instanceof Array)){data=(data==null?[]:[data])}var handler=HOOKS(reset);for(var i=0,m=hooks.length;i<m;i++){handler.Add(hooks[i])}return handler.Execute.apply(handler,data)};var QUEUE=BASE.Object.Subclass({Init:function(){this.pending=this.running=0;this.queue=[];this.Push.apply(this,arguments)},Push:function(){var callback;for(var i=0,m=arguments.length;i<m;i++){callback=USING(arguments[i]);if(callback===arguments[i]&&!callback.called){callback=USING(["wait",this,callback])}this.queue.push(callback)}if(!this.running&&!this.pending){this.Process()}return callback},Process:function(queue){while(!this.running&&!this.pending&&this.queue.length){var callback=this.queue[0];queue=this.queue.slice(1);this.queue=[];this.Suspend();var result=callback();this.Resume();if(queue.length){this.queue=queue.concat(this.queue)}if(ISCALLBACK(result)&&!result.called){WAITFOR(result,this)}}},Suspend:function(){this.running++},Resume:function(){if(this.running){this.running--}},call:function(){this.Process.apply(this,arguments)},wait:function(callback){return callback}});var SIGNAL=QUEUE.Subclass({Init:function(name){QUEUE.prototype.Init.call(this);this.name=name;this.posted=[];this.listeners=HOOKS(true);this.posting=false;this.callback=null},Post:function(message,callback,forget){callback=USING(callback);if(this.posting||this.pending){this.Push(["Post",this,message,callback,forget])}else{this.callback=callback;callback.reset();if(!forget){this.posted.push(message)}this.Suspend();this.posting=true;var result=this.listeners.Execute(message);if(ISCALLBACK(result)&&!result.called){WAITFOR(result,this)}this.Resume();this.posting=false;if(!this.pending){this.call()}}return callback},Clear:function(callback){callback=USING(callback);if(this.posting||this.pending){callback=this.Push(["Clear",this,callback])}else{this.posted=[];callback()}return callback},call:function(){this.callback(this);this.Process()},Interest:function(callback,ignorePast,priority){callback=USING(callback);this.listeners.Add(callback,priority);if(!ignorePast){for(var i=0,m=this.posted.length;i<m;i++){callback.reset();var result=callback(this.posted[i]);if(ISCALLBACK(result)&&i===this.posted.length-1){WAITFOR(result,this)}}}return callback},NoInterest:function(callback){this.listeners.Remove(callback)},MessageHook:function(msg,callback,priority){callback=USING(callback);if(!this.hooks){this.hooks={};this.Interest(["ExecuteHooks",this])}if(!this.hooks[msg]){this.hooks[msg]=HOOKS(true)}this.hooks[msg].Add(callback,priority);for(var i=0,m=this.posted.length;i<m;i++){if(this.posted[i]==msg){callback.reset();callback(this.posted[i])}}callback.msg=msg;return callback},ExecuteHooks:function(msg){var type=((msg instanceof Array)?msg[0]:msg);if(!this.hooks[type]){return null}return this.hooks[type].Execute(msg)},RemoveHook:function(hook){this.hooks[hook.msg].Remove(hook)}},{signals:{},find:function(name){if(!SIGNAL.signals[name]){SIGNAL.signals[name]=new SIGNAL(name)}return SIGNAL.signals[name]}});BASE.Callback=BASE.CallBack=USING;BASE.Callback.Delay=DELAY;BASE.Callback.After=AFTER;BASE.Callback.Queue=QUEUE;BASE.Callback.Signal=SIGNAL.find;BASE.Callback.Hooks=HOOKS;BASE.Callback.ExecuteHooks=EXECUTEHOOKS})("MathJax");(function(e){var a=window[e];if(!a){a=window[e]={}}var d=(navigator.vendor==="Apple Computer, Inc."&&typeof navigator.vendorSub==="undefined");var g=0;var h=function(i){if(document.styleSheets&&document.styleSheets.length>g){g=document.styleSheets.length}if(!i){i=document.head||((document.getElementsByTagName("head"))[0]);if(!i){i=document.body}}return i};var f=[];var c=function(){for(var k=0,j=f.length;k<j;k++){a.Ajax.head.removeChild(f[k])}f=[]};var b={};b[e]="";a.Ajax={loaded:{},loading:{},loadHooks:{},timeout:15*1000,styleDelay:1,config:{root:"",path:b},STATUS:{OK:1,ERROR:-1},fileURL:function(j){var i=j.match(/^\[([-._a-z0-9]+)\]/i);if(i&&i[1] in b){j=(b[i[1]]||this.config.root)+j.substr(i[1].length+2)}return j},fileName:function(j){var i=this.config.root;if(j.substr(0,i.length)===i){j="["+e+"]"+j.substr(i.length)}else{for(var k in b){if(b.hasOwnProperty(k)&&b[k]){if(j.substr(0,b[k].length)===b[k]){j="["+k+"]"+j.substr(b[k].length);break}}}}return j},fileRev:function(j){var i=a.cdnFileVersions[name]||a.cdnVersion;if(i){i="?rev="+i}return i},urlRev:function(i){return this.fileURL(i)+this.fileRev(i)},Require:function(k,n){n=a.Callback(n);var l;if(k instanceof Object){for(var j in k){if(k.hasOwnProperty(j)){l=j.toUpperCase();k=k[j]}}}else{l=k.split(/\./).pop().toUpperCase()}k=this.fileURL(k);if(this.loaded[k]){n(this.loaded[k])}else{var m={};m[l]=k;this.Load(m,n)}return n},Load:function(k,m){m=a.Callback(m);var l;if(k instanceof Object){for(var j in k){if(k.hasOwnProperty(j)){l=j.toUpperCase();k=k[j]}}}else{l=k.split(/\./).pop().toUpperCase()}k=this.fileURL(k);if(this.loading[k]){this.addHook(k,m)}else{this.head=h(this.head);if(this.loader[l]){this.loader[l].call(this,k,m)}else{throw Error("Can't load files of type "+l)}}return m},LoadHook:function(l,m,k){m=a.Callback(m);if(l instanceof Object){for(var j in l){if(l.hasOwnProperty(j)){l=l[j]}}}l=this.fileURL(l);if(this.loaded[l]){m(this.loaded[l])}else{this.addHook(l,m,k)}return m},addHook:function(j,k,i){if(!this.loadHooks[j]){this.loadHooks[j]=MathJax.Callback.Hooks()}this.loadHooks[j].Add(k,i);k.file=j},removeHook:function(i){if(this.loadHooks[i.file]){this.loadHooks[i.file].Remove(i);if(!this.loadHooks[i.file].hooks.length){delete this.loadHooks[i.file]}}},Preloading:function(){for(var l=0,j=arguments.length;l<j;l++){var k=this.fileURL(arguments[l]);if(!this.loading[k]){this.loading[k]={preloaded:true}}}},loader:{JS:function(k,m){var j=this.fileName(k);var i=document.createElement("script");var l=a.Callback(["loadTimeout",this,k]);this.loading[k]={callback:m,timeout:setTimeout(l,this.timeout),status:this.STATUS.OK,script:i};this.loading[k].message=a.Message.File(j);i.onerror=l;i.type="text/javascript";i.src=k+this.fileRev(j);this.head.appendChild(i)},CSS:function(j,l){var i=this.fileName(j);var k=document.createElement("link");k.rel="stylesheet";k.type="text/css";k.href=j+this.fileRev(i);this.loading[j]={callback:l,message:a.Message.File(i),status:this.STATUS.OK};this.head.appendChild(k);this.timer.create.call(this,[this.timer.file,j],k)}},timer:{create:function(j,i){j=a.Callback(j);if(i.nodeName==="STYLE"&&i.styleSheet&&typeof(i.styleSheet.cssText)!=="undefined"){j(this.STATUS.OK)}else{if(window.chrome&&i.nodeName==="LINK"){j(this.STATUS.OK)}else{if(d){this.timer.start(this,[this.timer.checkSafari2,g++,j],this.styleDelay)}else{this.timer.start(this,[this.timer.checkLength,i,j],this.styleDelay)}}}return j},start:function(j,i,k,l){i=a.Callback(i);i.execute=this.execute;i.time=this.time;i.STATUS=j.STATUS;i.timeout=l||j.timeout;i.delay=i.total=k||0;if(k){setTimeout(i,k)}else{i()}},time:function(i){this.total+=this.delay;this.delay=Math.floor(this.delay*1.05+5);if(this.total>=this.timeout){i(this.STATUS.ERROR);return 1}return 0},file:function(j,i){if(i<0){a.Ajax.loadTimeout(j)}else{a.Ajax.loadComplete(j)}},execute:function(){this.hook.call(this.object,this,this.data[0],this.data[1])},checkSafari2:function(i,j,k){if(i.time(k)){return}if(document.styleSheets.length>j&&document.styleSheets[j].cssRules&&document.styleSheets[j].cssRules.length){k(i.STATUS.OK)}else{setTimeout(i,i.delay)}},checkLength:function(i,l,n){if(i.time(n)){return}var m=0;var j=(l.sheet||l.styleSheet);try{if((j.cssRules||j.rules||[]).length>0){m=1}}catch(k){if(k.message.match(/protected variable|restricted URI/)){m=1}else{if(k.message.match(/Security error/)){m=1}}}if(m){setTimeout(a.Callback([n,i.STATUS.OK]),0)}else{setTimeout(i,i.delay)}}},loadComplete:function(i){i=this.fileURL(i);var j=this.loading[i];if(j&&!j.preloaded){a.Message.Clear(j.message);clearTimeout(j.timeout);if(j.script){if(f.length===0){setTimeout(c,0)}f.push(j.script)}this.loaded[i]=j.status;delete this.loading[i];this.addHook(i,j.callback)}else{if(j){delete this.loading[i]}this.loaded[i]=this.STATUS.OK;j={status:this.STATUS.OK}}if(!this.loadHooks[i]){return null}return this.loadHooks[i].Execute(j.status)},loadTimeout:function(i){if(this.loading[i].timeout){clearTimeout(this.loading[i].timeout)}this.loading[i].status=this.STATUS.ERROR;this.loadError(i);this.loadComplete(i)},loadError:function(i){a.Message.Set(["LoadFailed","File failed to load: %1",i],null,2000);a.Hub.signal.Post(["file load error",i])},Styles:function(k,l){var i=this.StyleString(k);if(i===""){l=a.Callback(l);l()}else{var j=document.createElement("style");j.type="text/css";this.head=h(this.head);this.head.appendChild(j);if(j.styleSheet&&typeof(j.styleSheet.cssText)!=="undefined"){j.styleSheet.cssText=i}else{j.appendChild(document.createTextNode(i))}l=this.timer.create.call(this,l,j)}return l},StyleString:function(n){if(typeof(n)==="string"){return n}var k="",o,m;for(o in n){if(n.hasOwnProperty(o)){if(typeof n[o]==="string"){k+=o+" {"+n[o]+"}\n"}else{if(n[o] instanceof Array){for(var l=0;l<n[o].length;l++){m={};m[o]=n[o][l];k+=this.StyleString(m)}}else{if(o.substr(0,6)==="@media"){k+=o+" {"+this.StyleString(n[o])+"}\n"}else{if(n[o]!=null){m=[];for(var j in n[o]){if(n[o].hasOwnProperty(j)){if(n[o][j]!=null){m[m.length]=j+": "+n[o][j]}}}k+=o+" {"+m.join("; ")+"}\n"}}}}}}return k}}})("MathJax");MathJax.HTML={Element:function(d,f,e){var g=document.createElement(d),h;if(f){if(f.hasOwnProperty("style")){var c=f.style;f.style={};for(h in c){if(c.hasOwnProperty(h)){f.style[h.replace(/-([a-z])/g,this.ucMatch)]=c[h]}}}MathJax.Hub.Insert(g,f);for(h in f){if(h==="role"||h.substr(0,5)==="aria-"){g.setAttribute(h,f[h])}}}if(e){if(!(e instanceof Array)){e=[e]}for(var b=0,a=e.length;b<a;b++){if(e[b] instanceof Array){g.appendChild(this.Element(e[b][0],e[b][1],e[b][2]))}else{if(d==="script"){this.setScript(g,e[b])}else{g.appendChild(document.createTextNode(e[b]))}}}}return g},ucMatch:function(a,b){return b.toUpperCase()},addElement:function(b,a,d,c){return b.appendChild(this.Element(a,d,c))},TextNode:function(a){return document.createTextNode(a)},addText:function(a,b){return a.appendChild(this.TextNode(b))},setScript:function(a,b){if(this.setScriptBug){a.text=b}else{while(a.firstChild){a.removeChild(a.firstChild)}this.addText(a,b)}},getScript:function(a){var b=(a.text===""?a.innerHTML:a.text);return b.replace(/^\s+/,"").replace(/\s+$/,"")},Cookie:{prefix:"mjx",expires:365,Set:function(a,e){var d=[];if(e){for(var g in e){if(e.hasOwnProperty(g)){d.push(g+":"+e[g].toString().replace(/&/g,"&&"))}}}var b=this.prefix+"."+a+"="+escape(d.join("&;"));if(this.expires){var f=new Date();f.setDate(f.getDate()+this.expires);b+="; expires="+f.toGMTString()}try{document.cookie=b+"; path=/"}catch(c){}},Get:function(a,d){if(!d){d={}}var g=new RegExp("(?:^|;\\s*)"+this.prefix+"\\."+a+"=([^;]*)(?:;|$)");var f;try{f=g.exec(document.cookie)}catch(c){}if(f&&f[1]!==""){var j=unescape(f[1]).split("&;");for(var e=0,b=j.length;e<b;e++){f=j[e].match(/([^:]+):(.*)/);var h=f[2].replace(/&&/g,"&");if(h==="true"){h=true}else{if(h==="false"){h=false}else{if(h.match(/^-?(\d+(\.\d+)?|\.\d+)$/)){h=parseFloat(h)}}}d[f[1]]=h}}return d}}};MathJax.Localization={locale:"en",directory:"[MathJax]/localization",strings:{ast:{menuTitle:"asturianu"},bg:{menuTitle:"\u0431\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438"},bcc:{menuTitle:"\u0628\u0644\u0648\u0686\u06CC"},br:{menuTitle:"brezhoneg"},ca:{menuTitle:"catal\u00E0"},cdo:{menuTitle:"M\u00ECng-d\u0115\u0324ng-ng\u1E73\u0304"},cs:{menuTitle:"\u010De\u0161tina"},da:{menuTitle:"dansk"},de:{menuTitle:"Deutsch"},en:{menuTitle:"English",isLoaded:true},eo:{menuTitle:"Esperanto"},es:{menuTitle:"espa\u00F1ol"},fa:{menuTitle:"\u0641\u0627\u0631\u0633\u06CC"},fi:{menuTitle:"suomi"},fr:{menuTitle:"fran\u00E7ais"},gl:{menuTitle:"galego"},he:{menuTitle:"\u05E2\u05D1\u05E8\u05D9\u05EA"},ia:{menuTitle:"interlingua"},it:{menuTitle:"italiano"},ja:{menuTitle:"\u65E5\u672C\u8A9E"},kn:{menuTitle:"\u0C95\u0CA8\u0CCD\u0CA8\u0CA1"},ko:{menuTitle:"\uD55C\uAD6D\uC5B4"},lb:{menuTitle:"L\u00EBtzebuergesch"},lt:{menuTitle:"lietuvi\u0173"},mk:{menuTitle:"\u043C\u0430\u043A\u0435\u0434\u043E\u043D\u0441\u043A\u0438"},nl:{menuTitle:"Nederlands"},oc:{menuTitle:"occitan"},pl:{menuTitle:"polski"},pt:{menuTitle:"portugus\u00EA"},"pt-br":{menuTitle:"portugu\u00EAs do Brasil"},ru:{menuTitle:"\u0440\u0443\u0441\u0441\u043A\u0438\u0439"},sco:{menuTitle:"Scots"},scn:{menuTitle:"sicilianu"},sl:{menuTitle:"sloven\u0161\u010Dina"},sv:{menuTitle:"svenska"},tr:{menuTitle:"T\u00FCrk\u00E7e"},uk:{menuTitle:"\u0443\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430"},vi:{menuTitle:"Ti\u1EBFng Vi\u1EC7t"},"zh-hans":{menuTitle:"\u4E2D\u6587\uFF08\u7B80\u4F53\uFF09"}},pattern:/%(\d+|\{\d+\}|\{[a-z]+:\%\d+(?:\|(?:%\{\d+\}|%.|[^\}])*)+\}|.)/g,SPLIT:("axb".split(/(x)/).length===3?function(a,b){return a.split(b)}:function(c,e){var a=[],b,d=0;e.lastIndex=0;while((b=e.exec(c))){a.push(c.substr(d,b.index-d));a.push.apply(a,b.slice(1));d=b.index+b[0].length}a.push(c.substr(d));return a}),_:function(b,a){if(a instanceof Array){return this.processSnippet(b,a)}return this.processString(this.lookupPhrase(b,a),[].slice.call(arguments,2))},processString:function(l,o,g){var j,e;for(j=0,e=o.length;j<e;j++){if(g&&o[j] instanceof Array){o[j]=this.processSnippet(g,o[j])}}var f=this.SPLIT(l,this.pattern);for(j=1,e=f.length;j<e;j+=2){var p=f[j].charAt(0);if(p>="0"&&p<="9"){f[j]=o[f[j]-1];if(typeof f[j]==="number"){f[j]=this.number(f[j])}}else{if(p==="{"){p=f[j].substr(1);if(p>="0"&&p<="9"){f[j]=o[f[j].substr(1,f[j].length-2)-1];if(typeof f[j]==="number"){f[j]=this.number(f[j])}}else{var k=f[j].match(/^\{([a-z]+):%(\d+)\|(.*)\}$/);if(k){if(k[1]==="plural"){var d=o[k[2]-1];if(typeof d==="undefined"){f[j]="???"}else{d=this.plural(d)-1;var h=k[3].replace(/(^|[^%])(%%)*%\|/g,"$1$2%\uEFEF").split(/\|/);if(d>=0&&d<h.length){f[j]=this.processString(h[d].replace(/\uEFEF/g,"|"),o,g)}else{f[j]="???"}}}else{f[j]="%"+f[j]}}}}}if(f[j]==null){f[j]="???"}}if(!g){return f.join("")}var a=[],b="";for(j=0;j<e;j++){b+=f[j];j++;if(j<e){if(f[j] instanceof Array){a.push(b);a=a.concat(f[j]);b=""}else{b+=f[j]}}}if(b!==""){a.push(b)}return a},processSnippet:function(g,e){var c=[];for(var d=0,b=e.length;d<b;d++){if(e[d] instanceof Array){var f=e[d];if(typeof f[1]==="string"){var h=f[0];if(!(h instanceof Array)){h=[g,h]}var a=this.lookupPhrase(h,f[1]);c=c.concat(this.processMarkdown(a,f.slice(2),g))}else{if(f[1] instanceof Array){c=c.concat(this.processSnippet.apply(this,f))}else{if(f.length>=3){c.push([f[0],f[1],this.processSnippet(g,f[2])])}else{c.push(e[d])}}}}else{c.push(e[d])}}return c},markdownPattern:/(%.)|(\*{1,3})((?:%.|.)+?)\2|(`+)((?:%.|.)+?)\4|\[((?:%.|.)+?)\]\(([^\s\)]+)\)/,processMarkdown:function(b,h,d){var j=[],e;var c=b.split(this.markdownPattern);var g=c[0];for(var f=1,a=c.length;f<a;f+=8){if(c[f+1]){e=this.processString(c[f+2],h,d);if(!(e instanceof Array)){e=[e]}e=[["b","i","i"][c[f+1].length-1],{},e];if(c[f+1].length===3){e=["b",{},e]}}else{if(c[f+3]){e=this.processString(c[f+4].replace(/^\s/,"").replace(/\s$/,""),h,d);if(!(e instanceof Array)){e=[e]}e=["code",{},e]}else{if(c[f+5]){e=this.processString(c[f+5],h,d);if(!(e instanceof Array)){e=[e]}e=["a",{href:this.processString(c[f+6],h),target:"_blank"},e]}else{g+=c[f];e=null}}}if(e){j=this.concatString(j,g,h,d);j.push(e);g=""}if(c[f+7]!==""){g+=c[f+7]}}j=this.concatString(j,g,h,d);return j},concatString:function(a,c,b,d){if(c!=""){c=this.processString(c,b,d);if(!(c instanceof Array)){c=[c]}a=a.concat(c)}return a},lookupPhrase:function(f,a,d){if(!d){d="_"}if(f instanceof Array){d=(f[0]||"_");f=(f[1]||"")}var c=this.loadDomain(d);if(c){MathJax.Hub.RestartAfter(c)}var b=this.strings[this.locale];if(b){if(b.domains&&d in b.domains){var e=b.domains[d];if(e.strings&&f in e.strings){a=e.strings[f]}}}return a},loadFile:function(b,d,e){e=MathJax.Callback(e);b=(d.file||b);if(!b.match(/\.js$/)){b+=".js"}if(!b.match(/^([a-z]+:|\[MathJax\])/)){var a=(this.strings[this.locale].directory||this.directory+"/"+this.locale||"[MathJax]/localization/"+this.locale);b=a+"/"+b}var c=MathJax.Ajax.Require(b,function(){d.isLoaded=true;return e()});return(c.called?null:c)},loadDomain:function(c,e){var b,a=this.strings[this.locale];if(a){if(!a.isLoaded){b=this.loadFile(this.locale,a);if(b){return MathJax.Callback.Queue(b,["loadDomain",this,c]).Push(e||{})}}if(a.domains&&c in a.domains){var d=a.domains[c];if(!d.isLoaded){b=this.loadFile(c,d);if(b){return MathJax.Callback.Queue(b).Push(e)}}}}return MathJax.Callback(e)()},Try:function(a){a=MathJax.Callback(a);a.autoReset=true;try{a()}catch(b){if(!b.restart){throw b}MathJax.Callback.After(["Try",this,a],b.restart)}},resetLocale:function(a){if(!a){return}a=a.toLowerCase();while(!this.strings[a]){var c=a.lastIndexOf("-");if(c===-1){return}a=a.substring(0,c)}var b=this.strings[a].remap;this.locale=b?b:a},setLocale:function(a){this.resetLocale(a);if(MathJax.Menu){this.loadDomain("MathMenu")}},addTranslation:function(b,e,c){var d=this.strings[b],a=false;if(!d){d=this.strings[b]={};a=true}if(!d.domains){d.domains={}}if(e){if(!d.domains[e]){d.domains[e]={}}d=d.domains[e]}MathJax.Hub.Insert(d,c);if(a&&MathJax.Menu.menu){MathJax.Menu.CreateLocaleMenu()}},setCSS:function(b){var a=this.strings[this.locale];if(a){if(a.fontFamily){b.style.fontFamily=a.fontFamily}if(a.fontDirection){b.style.direction=a.fontDirection;if(a.fontDirection==="rtl"){b.style.textAlign="right"}}}return b},fontFamily:function(){var a=this.strings[this.locale];return(a?a.fontFamily:null)},fontDirection:function(){var a=this.strings[this.locale];return(a?a.fontDirection:null)},plural:function(b){var a=this.strings[this.locale];if(a&&a.plural){return a.plural(b)}if(b==1){return 1}return 2},number:function(b){var a=this.strings[this.locale];if(a&&a.number){return a.number(b)}return b}};MathJax.Message={ready:false,log:[{}],current:null,textNodeBug:(navigator.vendor==="Apple Computer, Inc."&&typeof navigator.vendorSub==="undefined")||(window.hasOwnProperty&&window.hasOwnProperty("konqueror")),styles:{"#MathJax_Message":{position:"fixed",left:"1px",bottom:"2px","background-color":"#E6E6E6",border:"1px solid #959595",margin:"0px",padding:"2px 8px","z-index":"102",color:"black","font-size":"80%",width:"auto","white-space":"nowrap"},"#MathJax_MSIE_Frame":{position:"absolute",top:0,left:0,width:"0px","z-index":101,border:"0px",margin:"0px",padding:"0px"}},browsers:{MSIE:function(a){MathJax.Message.msieFixedPositionBug=((document.documentMode||0)<7);if(MathJax.Message.msieFixedPositionBug){MathJax.Hub.config.styles["#MathJax_Message"].position="absolute"}MathJax.Message.quirks=(document.compatMode==="BackCompat")},Chrome:function(a){MathJax.Hub.config.styles["#MathJax_Message"].bottom="1.5em";MathJax.Hub.config.styles["#MathJax_Message"].left="1em"}},Init:function(a){if(a){this.ready=true}if(!document.body||!this.ready){return false}if(this.div&&this.div.parentNode==null){this.div=document.getElementById("MathJax_Message");if(this.div){this.text=this.div.firstChild}}if(!this.div){var b=document.body;if(this.msieFixedPositionBug&&window.attachEvent){b=this.frame=this.addDiv(document.body);b.removeAttribute("id");b.style.position="absolute";b.style.border=b.style.margin=b.style.padding="0px";b.style.zIndex="101";b.style.height="0px";b=this.addDiv(b);b.id="MathJax_MSIE_Frame";window.attachEvent("onscroll",this.MoveFrame);window.attachEvent("onresize",this.MoveFrame);this.MoveFrame()}this.div=this.addDiv(b);this.div.style.display="none";this.text=this.div.appendChild(document.createTextNode(""))}return true},addDiv:function(a){var b=document.createElement("div");b.id="MathJax_Message";if(a.firstChild){a.insertBefore(b,a.firstChild)}else{a.appendChild(b)}return b},MoveFrame:function(){var a=(MathJax.Message.quirks?document.body:document.documentElement);var b=MathJax.Message.frame;b.style.left=a.scrollLeft+"px";b.style.top=a.scrollTop+"px";b.style.width=a.clientWidth+"px";b=b.firstChild;b.style.height=a.clientHeight+"px"},localize:function(a){return MathJax.Localization._(a,a)},filterText:function(a,c,b){if(MathJax.Hub.config.messageStyle==="simple"){if(b==="LoadFile"){if(!this.loading){this.loading=this.localize("Loading")+" "}a=this.loading;this.loading+="."}else{if(b==="ProcessMath"){if(!this.processing){this.processing=this.localize("Processing")+" "}a=this.processing;this.processing+="."}else{if(b==="TypesetMath"){if(!this.typesetting){this.typesetting=this.localize("Typesetting")+" "}a=this.typesetting;this.typesetting+="."}}}}return a},Set:function(c,e,b){if(e==null){e=this.log.length;this.log[e]={}}var d="";if(c instanceof Array){d=c[0];if(d instanceof Array){d=d[1]}try{c=MathJax.Localization._.apply(MathJax.Localization,c)}catch(a){if(!a.restart){throw a}if(!a.restart.called){if(this.log[e].restarted==null){this.log[e].restarted=0}this.log[e].restarted++;delete this.log[e].cleared;MathJax.Callback.After(["Set",this,c,e,b],a.restart);return e}}}if(this.timer){clearTimeout(this.timer);delete this.timer}this.log[e].text=c;this.log[e].filteredText=c=this.filterText(c,e,d);if(typeof(this.log[e].next)==="undefined"){this.log[e].next=this.current;if(this.current!=null){this.log[this.current].prev=e}this.current=e}if(this.current===e&&MathJax.Hub.config.messageStyle!=="none"){if(this.Init()){if(this.textNodeBug){this.div.innerHTML=c}else{this.text.nodeValue=c}this.div.style.display="";if(this.status){window.status="";delete this.status}}else{window.status=c;this.status=true}}if(this.log[e].restarted){if(this.log[e].cleared){b=0}if(--this.log[e].restarted===0){delete this.log[e].cleared}}if(b){setTimeout(MathJax.Callback(["Clear",this,e]),b)}else{if(b==0){this.Clear(e,0)}}return e},Clear:function(b,a){if(this.log[b].prev!=null){this.log[this.log[b].prev].next=this.log[b].next}if(this.log[b].next!=null){this.log[this.log[b].next].prev=this.log[b].prev}if(this.current===b){this.current=this.log[b].next;if(this.text){if(this.div.parentNode==null){this.Init()}if(this.current==null){if(this.timer){clearTimeout(this.timer);delete this.timer}if(a==null){a=600}if(a===0){this.Remove()}else{this.timer=setTimeout(MathJax.Callback(["Remove",this]),a)}}else{if(MathJax.Hub.config.messageStyle!=="none"){if(this.textNodeBug){this.div.innerHTML=this.log[this.current].filteredText}else{this.text.nodeValue=this.log[this.current].filteredText}}}if(this.status){window.status="";delete this.status}}else{if(this.status){window.status=(this.current==null?"":this.log[this.current].text)}}}delete this.log[b].next;delete this.log[b].prev;delete this.log[b].filteredText;if(this.log[b].restarted){this.log[b].cleared=true}},Remove:function(){this.text.nodeValue="";this.div.style.display="none"},File:function(a){return this.Set(["LoadFile","Loading %1",a],null,null)},Log:function(){var b=[];for(var c=1,a=this.log.length;c<a;c++){b[c]=this.log[c].text}return b.join("\n")}};MathJax.Hub={config:{root:"",config:[],styleSheets:[],styles:{".MathJax_Preview":{color:"#888"}},jax:[],extensions:[],preJax:null,postJax:null,displayAlign:"center",displayIndent:"0",preRemoveClass:"MathJax_Preview",showProcessingMessages:true,messageStyle:"normal",delayStartupUntil:"none",skipStartupTypeset:false,elements:[],positionToHash:true,showMathMenu:true,showMathMenuMSIE:true,menuSettings:{zoom:"None",CTRL:false,ALT:false,CMD:false,Shift:false,discoverable:false,zscale:"200%",renderer:null,font:"Auto",context:"MathJax",locale:null,mpContext:false,mpMouse:false,texHints:true,FastPreview:null,assistiveMML:null,inTabOrder:true,semantics:false},errorSettings:{message:["[",["MathProcessingError","Math Processing Error"],"]"],style:{color:"#CC0000","font-style":"italic"}},ignoreMMLattributes:{}},preProcessors:MathJax.Callback.Hooks(true),inputJax:{},outputJax:{order:{}},processSectionDelay:50,processUpdateTime:250,processUpdateDelay:10,signal:MathJax.Callback.Signal("Hub"),Config:function(a){this.Insert(this.config,a);if(this.config.Augment){this.Augment(this.config.Augment)}},CombineConfig:function(c,f){var b=this.config,g,e;c=c.split(/\./);for(var d=0,a=c.length;d<a;d++){g=c[d];if(!b[g]){b[g]={}}e=b;b=b[g]}e[g]=b=this.Insert(f,b);return b},Register:{PreProcessor:function(){return MathJax.Hub.preProcessors.Add.apply(MathJax.Hub.preProcessors,arguments)},MessageHook:function(){return MathJax.Hub.signal.MessageHook.apply(MathJax.Hub.signal,arguments)},StartupHook:function(){return MathJax.Hub.Startup.signal.MessageHook.apply(MathJax.Hub.Startup.signal,arguments)},LoadHook:function(){return MathJax.Ajax.LoadHook.apply(MathJax.Ajax,arguments)}},UnRegister:{PreProcessor:function(a){MathJax.Hub.preProcessors.Remove(a)},MessageHook:function(a){MathJax.Hub.signal.RemoveHook(a)},StartupHook:function(a){MathJax.Hub.Startup.signal.RemoveHook(a)},LoadHook:function(a){MathJax.Ajax.removeHook(a)}},getAllJax:function(e){var c=[],b=this.elementScripts(e);for(var d=0,a=b.length;d<a;d++){if(b[d].MathJax&&b[d].MathJax.elementJax){c.push(b[d].MathJax.elementJax)}}return c},getJaxByType:function(f,e){var c=[],b=this.elementScripts(e);for(var d=0,a=b.length;d<a;d++){if(b[d].MathJax&&b[d].MathJax.elementJax&&b[d].MathJax.elementJax.mimeType===f){c.push(b[d].MathJax.elementJax)}}return c},getJaxByInputType:function(f,e){var c=[],b=this.elementScripts(e);for(var d=0,a=b.length;d<a;d++){if(b[d].MathJax&&b[d].MathJax.elementJax&&b[d].type&&b[d].type.replace(/ *;(.|\s)*/,"")===f){c.push(b[d].MathJax.elementJax)}}return c},getJaxFor:function(a){if(typeof(a)==="string"){a=document.getElementById(a)}if(a&&a.MathJax){return a.MathJax.elementJax}if(this.isMathJaxNode(a)){if(!a.isMathJax){a=a.firstChild}while(a&&!a.jaxID){a=a.parentNode}if(a){return MathJax.OutputJax[a.jaxID].getJaxFromMath(a)}}return null},isJax:function(a){if(typeof(a)==="string"){a=document.getElementById(a)}if(this.isMathJaxNode(a)){return 1}if(a&&(a.tagName||"").toLowerCase()==="script"){if(a.MathJax){return(a.MathJax.state===MathJax.ElementJax.STATE.PROCESSED?1:-1)}if(a.type&&this.inputJax[a.type.replace(/ *;(.|\s)*/,"")]){return -1}}return 0},isMathJaxNode:function(a){return !!a&&(a.isMathJax||(a.className||"")==="MathJax_MathML")},setRenderer:function(d,c){if(!d){return}if(!MathJax.OutputJax[d]){this.config.menuSettings.renderer="";var b="[MathJax]/jax/output/"+d+"/config.js";return MathJax.Ajax.Require(b,["setRenderer",this,d,c])}else{this.config.menuSettings.renderer=d;if(c==null){c="jax/mml"}var a=this.outputJax;if(a[c]&&a[c].length){if(d!==a[c][0].id){a[c].unshift(MathJax.OutputJax[d]);return this.signal.Post(["Renderer Selected",d])}}return null}},Queue:function(){return this.queue.Push.apply(this.queue,arguments)},Typeset:function(c,d){if(!MathJax.isReady){return null}var b=this.elementCallback(c,d);if(b.count){var a=MathJax.Callback.Queue(["PreProcess",this,b.elements],["Process",this,b.elements])}return a.Push(b.callback)},PreProcess:function(e,g){var c=this.elementCallback(e,g);var b=MathJax.Callback.Queue();if(c.count){var f=(c.count===1?[c.elements]:c.elements);b.Push(["Post",this.signal,["Begin PreProcess",c.elements]]);for(var d=0,a=f.length;d<a;d++){if(f[d]){b.Push(["Execute",this.preProcessors,f[d]])}}b.Push(["Post",this.signal,["End PreProcess",c.elements]])}return b.Push(c.callback)},Process:function(a,b){return this.takeAction("Process",a,b)},Update:function(a,b){return this.takeAction("Update",a,b)},Reprocess:function(a,b){return this.takeAction("Reprocess",a,b)},Rerender:function(a,b){return this.takeAction("Rerender",a,b)},takeAction:function(g,d,h){var c=this.elementCallback(d,h);var f=c.elements;var a=MathJax.Callback.Queue(["Clear",this.signal]);var e={scripts:[],start:new Date().getTime(),i:0,j:0,jax:{},jaxIDs:[]};if(c.count){var b=["Delay",MathJax.Callback,this.processSectionDelay];if(!b[2]){b={}}a.Push(["Post",this.signal,["Begin "+g,f]],["Post",this.signal,["Begin Math",f,g]],["prepareScripts",this,g,f,e],["Post",this.signal,["Begin Math Input",f,g]],["processInput",this,e],["Post",this.signal,["End Math Input",f,g]],b,["prepareOutput",this,e,"preProcess"],b,["Post",this.signal,["Begin Math Output",f,g]],["processOutput",this,e],["Post",this.signal,["End Math Output",f,g]],b,["prepareOutput",this,e,"postProcess"],b,["Post",this.signal,["End Math",f,g]],["Post",this.signal,["End "+g,f]])}return a.Push(c.callback)},scriptAction:{Process:function(a){},Update:function(b){var a=b.MathJax.elementJax;if(a&&a.needsUpdate()){a.Remove(true);b.MathJax.state=a.STATE.UPDATE}else{b.MathJax.state=a.STATE.PROCESSED}},Reprocess:function(b){var a=b.MathJax.elementJax;if(a){a.Remove(true);b.MathJax.state=a.STATE.UPDATE}},Rerender:function(b){var a=b.MathJax.elementJax;if(a){a.Remove(true);b.MathJax.state=a.STATE.OUTPUT}}},prepareScripts:function(h,e,g){if(arguments.callee.disabled){return}var b=this.elementScripts(e);var f=MathJax.ElementJax.STATE;for(var d=0,a=b.length;d<a;d++){var c=b[d];if(c.type&&this.inputJax[c.type.replace(/ *;(.|\n)*/,"")]){if(c.MathJax){if(c.MathJax.elementJax&&c.MathJax.elementJax.hover){MathJax.Extension.MathEvents.Hover.ClearHover(c.MathJax.elementJax)}if(c.MathJax.state!==f.PENDING){this.scriptAction[h](c)}}if(!c.MathJax){c.MathJax={state:f.PENDING}}if(c.MathJax.error){delete c.MathJax.error}if(c.MathJax.state!==f.PROCESSED){g.scripts.push(c)}}}},checkScriptSiblings:function(a){if(a.MathJax.checked){return}var b=this.config,f=a.previousSibling;if(f&&f.nodeName==="#text"){var d,e,c=a.nextSibling;if(c&&c.nodeName!=="#text"){c=null}if(b.preJax){if(typeof(b.preJax)==="string"){b.preJax=new RegExp(b.preJax+"$")}d=f.nodeValue.match(b.preJax)}if(b.postJax&&c){if(typeof(b.postJax)==="string"){b.postJax=new RegExp("^"+b.postJax)}e=c.nodeValue.match(b.postJax)}if(d&&(!b.postJax||e)){f.nodeValue=f.nodeValue.replace(b.preJax,(d.length>1?d[1]:""));f=null}if(e&&(!b.preJax||d)){c.nodeValue=c.nodeValue.replace(b.postJax,(e.length>1?e[1]:""))}if(f&&!f.nodeValue.match(/\S/)){f=f.previousSibling}}if(b.preRemoveClass&&f&&f.className===b.preRemoveClass){a.MathJax.preview=f}a.MathJax.checked=1},processInput:function(a){var b,i=MathJax.ElementJax.STATE;var h,e,d=a.scripts.length;try{while(a.i<d){h=a.scripts[a.i];if(!h){a.i++;continue}e=h.previousSibling;if(e&&e.className==="MathJax_Error"){e.parentNode.removeChild(e)}if(!h.MathJax||h.MathJax.state===i.PROCESSED){a.i++;continue}if(!h.MathJax.elementJax||h.MathJax.state===i.UPDATE){this.checkScriptSiblings(h);var g=h.type.replace(/ *;(.|\s)*/,"");var j=this.inputJax[g];b=j.Process(h,a);if(typeof b==="function"){if(b.called){continue}this.RestartAfter(b)}b=b.Attach(h,j.id);this.saveScript(b,a,h,i);this.postInputHooks.Execute(b,j.id,h)}else{if(h.MathJax.state===i.OUTPUT){this.saveScript(h.MathJax.elementJax,a,h,i)}}a.i++;var c=new Date().getTime();if(c-a.start>this.processUpdateTime&&a.i<a.scripts.length){a.start=c;this.RestartAfter(MathJax.Callback.Delay(1))}}}catch(f){return this.processError(f,a,"Input")}if(a.scripts.length&&this.config.showProcessingMessages){MathJax.Message.Set(["ProcessMath","Processing math: %1%%",100],0)}a.start=new Date().getTime();a.i=a.j=0;return null},postInputHooks:MathJax.Callback.Hooks(true),saveScript:function(a,d,b,c){if(!this.outputJax[a.mimeType]){b.MathJax.state=c.UPDATE;throw Error("No output jax registered for "+a.mimeType)}a.outputJax=this.outputJax[a.mimeType][0].id;if(!d.jax[a.outputJax]){if(d.jaxIDs.length===0){d.jax[a.outputJax]=d.scripts}else{if(d.jaxIDs.length===1){d.jax[d.jaxIDs[0]]=d.scripts.slice(0,d.i)}d.jax[a.outputJax]=[]}d.jaxIDs.push(a.outputJax)}if(d.jaxIDs.length>1){d.jax[a.outputJax].push(b)}b.MathJax.state=c.OUTPUT},prepareOutput:function(c,f){while(c.j<c.jaxIDs.length){var e=c.jaxIDs[c.j],d=MathJax.OutputJax[e];if(d[f]){try{var a=d[f](c);if(typeof a==="function"){if(a.called){continue}this.RestartAfter(a)}}catch(b){if(!b.restart){MathJax.Message.Set(["PrepError","Error preparing %1 output (%2)",e,f],null,600);MathJax.Hub.lastPrepError=b;c.j++}return MathJax.Callback.After(["prepareOutput",this,c,f],b.restart)}}c.j++}return null},processOutput:function(h){var b,g=MathJax.ElementJax.STATE,d,a=h.scripts.length;try{while(h.i<a){d=h.scripts[h.i];if(!d||!d.MathJax||d.MathJax.error){h.i++;continue}var c=d.MathJax.elementJax;if(!c){h.i++;continue}b=MathJax.OutputJax[c.outputJax].Process(d,h);if(b!==false){d.MathJax.state=g.PROCESSED;if(d.MathJax.preview){d.MathJax.preview.innerHTML=""}this.signal.Post(["New Math",c.inputID])}h.i++;var e=new Date().getTime();if(e-h.start>this.processUpdateTime&&h.i<h.scripts.length){h.start=e;this.RestartAfter(MathJax.Callback.Delay(this.processUpdateDelay))}}}catch(f){return this.processError(f,h,"Output")}if(h.scripts.length&&this.config.showProcessingMessages){MathJax.Message.Set(["TypesetMath","Typesetting math: %1%%",100],0);MathJax.Message.Clear(0)}h.i=h.j=0;return null},processMessage:function(d,b){var a=Math.floor(d.i/(d.scripts.length)*100);var c=(b==="Output"?["TypesetMath","Typesetting math: %1%%"]:["ProcessMath","Processing math: %1%%"]);if(this.config.showProcessingMessages){MathJax.Message.Set(c.concat(a),0)}},processError:function(b,c,a){if(!b.restart){if(!this.config.errorSettings.message){throw b}this.formatError(c.scripts[c.i],b);c.i++}this.processMessage(c,a);return MathJax.Callback.After(["process"+a,this,c],b.restart)},formatError:function(b,f){var h=function(l,k,j,i){return MathJax.Localization._(l,k,j,i)};var e=h("ErrorMessage","Error: %1",f.message)+"\n";if(f.sourceURL||f.fileName){e+="\n"+h("ErrorFile","file: %1",f.sourceURL||f.fileName)}if(f.line||f.lineNumber){e+="\n"+h("ErrorLine","line: %1",f.line||f.lineNumber)}e+="\n\n"+h("ErrorTips","Debugging tips: use %1, inspect %2 in the browser console","'unpacked/MathJax.js'","'MathJax.Hub.lastError'");b.MathJax.error=MathJax.OutputJax.Error.Jax(e,b);if(b.MathJax.elementJax){b.MathJax.error.inputID=b.MathJax.elementJax.inputID}var g=this.config.errorSettings;var a=h(g.messageId,g.message);var c=MathJax.HTML.Element("span",{className:"MathJax_Error",jaxID:"Error",isMathJax:true,id:b.MathJax.error.inputID+"-Frame"},[["span",null,a]]);MathJax.Ajax.Require("[MathJax]/extensions/MathEvents.js",function(){var j=MathJax.Extension.MathEvents.Event,i=MathJax.Hub;c.oncontextmenu=j.Menu;c.onmousedown=j.Mousedown;c.onkeydown=j.Keydown;c.tabIndex=i.getTabOrder(i.getJaxFor(b))});var d=document.getElementById(c.id);if(d){d.parentNode.removeChild(d)}b.parentNode.insertBefore(c,b);if(b.MathJax.preview){b.MathJax.preview.innerHTML=""}this.lastError=f;this.signal.Post(["Math Processing Error",b,f])},RestartAfter:function(a){throw this.Insert(Error("restart"),{restart:MathJax.Callback(a)})},elementCallback:function(c,f){if(f==null&&(c instanceof Array||typeof c==="function")){try{MathJax.Callback(c);f=c;c=null}catch(d){}}if(c==null){c=this.config.elements||[]}if(this.isHTMLCollection(c)){c=this.HTMLCollection2Array(c)}if(!(c instanceof Array)){c=[c]}c=[].concat(c);for(var b=0,a=c.length;b<a;b++){if(typeof(c[b])==="string"){c[b]=document.getElementById(c[b])}}if(!document.body){document.body=document.getElementsByTagName("body")[0]}if(c.length==0){c.push(document.body)}if(!f){f={}}return{count:c.length,elements:(c.length===1?c[0]:c),callback:f}},elementScripts:function(e){var b=[];if(e instanceof Array||this.isHTMLCollection(e)){for(var d=0,a=e.length;d<a;d++){var f=0;for(var c=0;c<d&&!f;c++){f=e[c].contains(e[d])}if(!f){b.push.apply(b,this.elementScripts(e[d]))}}return b}if(typeof(e)==="string"){e=document.getElementById(e)}if(!document.body){document.body=document.getElementsByTagName("body")[0]}if(e==null){e=document.body}if(e.tagName!=null&&e.tagName.toLowerCase()==="script"){return[e]}b=e.getElementsByTagName("script");if(this.msieHTMLCollectionBug){b=this.HTMLCollection2Array(b)}return b},isHTMLCollection:function(a){return("HTMLCollection" in window&&typeof(a)==="object"&&a instanceof HTMLCollection)},HTMLCollection2Array:function(c){if(!this.msieHTMLCollectionBug){return[].slice.call(c)}var b=[];for(var d=0,a=c.length;d<a;d++){b[d]=c[d]}return b},Insert:function(c,a){for(var b in a){if(a.hasOwnProperty(b)){if(typeof a[b]==="object"&&!(a[b] instanceof Array)&&(typeof c[b]==="object"||typeof c[b]==="function")){this.Insert(c[b],a[b])}else{c[b]=a[b]}}}return c},getTabOrder:function(a){return this.config.menuSettings.inTabOrder?0:-1},SplitList:("trim" in String.prototype?function(a){return a.trim().split(/\s+/)}:function(a){return a.replace(/^\s+/,"").replace(/\s+$/,"").split(/\s+/)})};MathJax.Hub.Insert(MathJax.Hub.config.styles,MathJax.Message.styles);MathJax.Hub.Insert(MathJax.Hub.config.styles,{".MathJax_Error":MathJax.Hub.config.errorSettings.style});MathJax.Extension={};MathJax.Hub.Configured=MathJax.Callback({});MathJax.Hub.Startup={script:"",queue:MathJax.Callback.Queue(),signal:MathJax.Callback.Signal("Startup"),params:{},Config:function(){this.queue.Push(["Post",this.signal,"Begin Config"]);if(this.params.locale){MathJax.Localization.resetLocale(this.params.locale);MathJax.Hub.config.menuSettings.locale=this.params.locale}if(this.params.config){var c=this.params.config.split(/,/);for(var b=0,a=c.length;b<a;b++){if(!c[b].match(/\.js$/)){c[b]+=".js"}this.queue.Push(["Require",MathJax.Ajax,this.URL("config",c[b])])}}this.queue.Push(["Config",MathJax.Hub,MathJax.AuthorConfig]);if(this.script.match(/\S/)){this.queue.Push(this.script+";\n1;")}this.queue.Push(["ConfigDelay",this],["ConfigBlocks",this],[function(d){return d.loadArray(MathJax.Hub.config.config,"config",null,true)},this],["Post",this.signal,"End Config"])},ConfigDelay:function(){var a=this.params.delayStartupUntil||MathJax.Hub.config.delayStartupUntil;if(a==="onload"){return this.onload}if(a==="configured"){return MathJax.Hub.Configured}return a},ConfigBlocks:function(){var c=document.getElementsByTagName("script");var f=null,b=MathJax.Callback.Queue();for(var d=0,a=c.length;d<a;d++){var e=String(c[d].type).replace(/ /g,"");if(e.match(/^text\/x-mathjax-config(;.*)?$/)&&!e.match(/;executed=true/)){c[d].type+=";executed=true";f=b.Push(c[d].innerHTML+";\n1;")}}return f},Cookie:function(){return this.queue.Push(["Post",this.signal,"Begin Cookie"],["Get",MathJax.HTML.Cookie,"menu",MathJax.Hub.config.menuSettings],[function(e){var d=e.menuSettings;if(d.locale){MathJax.Localization.resetLocale(d.locale)}var g=e.menuSettings.renderer,b=e.jax;if(g){var c="output/"+g;b.sort();for(var f=0,a=b.length;f<a;f++){if(b[f].substr(0,7)==="output/"){break}}if(f==a-1){b.pop()}else{while(f<a){if(b[f]===c){b.splice(f,1);break}f++}}b.unshift(c)}if(d.CHTMLpreview!=null){if(d.FastPreview==null){d.FastPreview=d.CHTMLpreview}delete d.CHTMLpreview}if(d.FastPreview&&!MathJax.Extension["fast-preview"]){MathJax.Hub.config.extensions.push("fast-preview.js")}if(e.menuSettings.assistiveMML&&!MathJax.Extension.AssistiveMML){MathJax.Hub.config.extensions.push("AssistiveMML.js")}},MathJax.Hub.config],["Post",this.signal,"End Cookie"])},Styles:function(){return this.queue.Push(["Post",this.signal,"Begin Styles"],["loadArray",this,MathJax.Hub.config.styleSheets,"config"],["Styles",MathJax.Ajax,MathJax.Hub.config.styles],["Post",this.signal,"End Styles"])},Jax:function(){var f=MathJax.Hub.config,c=MathJax.Hub.outputJax;for(var g=0,b=f.jax.length,d=0;g<b;g++){var e=f.jax[g].substr(7);if(f.jax[g].substr(0,7)==="output/"&&c.order[e]==null){c.order[e]=d;d++}}var a=MathJax.Callback.Queue();return a.Push(["Post",this.signal,"Begin Jax"],["loadArray",this,f.jax,"jax","config.js"],["Post",this.signal,"End Jax"])},Extensions:function(){var a=MathJax.Callback.Queue();return a.Push(["Post",this.signal,"Begin Extensions"],["loadArray",this,MathJax.Hub.config.extensions,"extensions"],["Post",this.signal,"End Extensions"])},Message:function(){MathJax.Message.Init(true)},Menu:function(){var b=MathJax.Hub.config.menuSettings,a=MathJax.Hub.outputJax,d;for(var c in a){if(a.hasOwnProperty(c)){if(a[c].length){d=a[c];break}}}if(d&&d.length){if(b.renderer&&b.renderer!==d[0].id){d.unshift(MathJax.OutputJax[b.renderer])}b.renderer=d[0].id}},Hash:function(){if(MathJax.Hub.config.positionToHash&&document.location.hash&&document.body&&document.body.scrollIntoView){var d=document.location.hash.substr(1);var f=document.getElementById(d);if(!f){var c=document.getElementsByTagName("a");for(var e=0,b=c.length;e<b;e++){if(c[e].name===d){f=c[e];break}}}if(f){while(!f.scrollIntoView){f=f.parentNode}f=this.HashCheck(f);if(f&&f.scrollIntoView){setTimeout(function(){f.scrollIntoView(true)},1)}}}},HashCheck:function(b){var a=MathJax.Hub.getJaxFor(b);if(a&&MathJax.OutputJax[a.outputJax].hashCheck){b=MathJax.OutputJax[a.outputJax].hashCheck(b)}return b},MenuZoom:function(){if(MathJax.Hub.config.showMathMenu){if(!MathJax.Extension.MathMenu){setTimeout(function(){MathJax.Callback.Queue(["Require",MathJax.Ajax,"[MathJax]/extensions/MathMenu.js",{}],["loadDomain",MathJax.Localization,"MathMenu"])},1000)}else{setTimeout(MathJax.Callback(["loadDomain",MathJax.Localization,"MathMenu"]),1000)}if(!MathJax.Extension.MathZoom){setTimeout(MathJax.Callback(["Require",MathJax.Ajax,"[MathJax]/extensions/MathZoom.js",{}]),2000)}}},onLoad:function(){var a=this.onload=MathJax.Callback(function(){MathJax.Hub.Startup.signal.Post("onLoad")});if(document.body&&document.readyState){if(MathJax.Hub.Browser.isMSIE){if(document.readyState==="complete"){return[a]}}else{if(document.readyState!=="loading"){return[a]}}}if(window.addEventListener){window.addEventListener("load",a,false);if(!this.params.noDOMContentEvent){window.addEventListener("DOMContentLoaded",a,false)}}else{if(window.attachEvent){window.attachEvent("onload",a)}else{window.onload=a}}return a},Typeset:function(a,b){if(MathJax.Hub.config.skipStartupTypeset){return function(){}}return this.queue.Push(["Post",this.signal,"Begin Typeset"],["Typeset",MathJax.Hub,a,b],["Post",this.signal,"End Typeset"])},URL:function(b,a){if(!a.match(/^([a-z]+:\/\/|\[|\/)/)){a="[MathJax]/"+b+"/"+a}return a},loadArray:function(b,f,c,a){if(b){if(!(b instanceof Array)){b=[b]}if(b.length){var h=MathJax.Callback.Queue(),j={},e;for(var g=0,d=b.length;g<d;g++){e=this.URL(f,b[g]);if(c){e+="/"+c}if(a){h.Push(["Require",MathJax.Ajax,e,j])}else{h.Push(MathJax.Ajax.Require(e,j))}}return h.Push({})}}return null}};(function(d){var b=window[d],e="["+d+"]";var c=b.Hub,a=b.Ajax,f=b.Callback;var g=MathJax.Object.Subclass({JAXFILE:"jax.js",require:null,config:{},Init:function(i,h){if(arguments.length===0){return this}return(this.constructor.Subclass(i,h))()},Augment:function(k,j){var i=this.constructor,h={};if(k!=null){for(var l in k){if(k.hasOwnProperty(l)){if(typeof k[l]==="function"){i.protoFunction(l,k[l])}else{h[l]=k[l]}}}if(k.toString!==i.prototype.toString&&k.toString!=={}.toString){i.protoFunction("toString",k.toString)}}c.Insert(i.prototype,h);i.Augment(null,j);return this},Translate:function(h,i){throw Error(this.directory+"/"+this.JAXFILE+" failed to define the Translate() method")},Register:function(h){},Config:function(){this.config=c.CombineConfig(this.id,this.config);if(this.config.Augment){this.Augment(this.config.Augment)}},Startup:function(){},loadComplete:function(i){if(i==="config.js"){return a.loadComplete(this.directory+"/"+i)}else{var h=f.Queue();h.Push(c.Register.StartupHook("End Config",{}),["Post",c.Startup.signal,this.id+" Jax Config"],["Config",this],["Post",c.Startup.signal,this.id+" Jax Require"],[function(j){return MathJax.Hub.Startup.loadArray(j.require,this.directory)},this],[function(j,k){return MathJax.Hub.Startup.loadArray(j.extensions,"extensions/"+k)},this.config||{},this.id],["Post",c.Startup.signal,this.id+" Jax Startup"],["Startup",this],["Post",c.Startup.signal,this.id+" Jax Ready"]);if(this.copyTranslate){h.Push([function(j){j.preProcess=j.preTranslate;j.Process=j.Translate;j.postProcess=j.postTranslate},this.constructor.prototype])}return h.Push(["loadComplete",a,this.directory+"/"+i])}}},{id:"Jax",version:"2.6.0",directory:e+"/jax",extensionDir:e+"/extensions"});b.InputJax=g.Subclass({elementJax:"mml",sourceMenuTitle:["Original","Original Form"],copyTranslate:true,Process:function(l,q){var j=f.Queue(),o;var k=this.elementJax;if(!(k instanceof Array)){k=[k]}for(var n=0,h=k.length;n<h;n++){o=b.ElementJax.directory+"/"+k[n]+"/"+this.JAXFILE;if(!this.require){this.require=[]}else{if(!(this.require instanceof Array)){this.require=[this.require]}}this.require.push(o);j.Push(a.Require(o))}o=this.directory+"/"+this.JAXFILE;var p=j.Push(a.Require(o));if(!p.called){this.constructor.prototype.Process=function(){if(!p.called){return p}throw Error(o+" failed to load properly")}}k=c.outputJax["jax/"+k[0]];if(k){j.Push(a.Require(k[0].directory+"/"+this.JAXFILE))}return j.Push({})},needsUpdate:function(h){var i=h.SourceElement();return(h.originalText!==b.HTML.getScript(i))},Register:function(h){if(!c.inputJax){c.inputJax={}}c.inputJax[h]=this}},{id:"InputJax",version:"2.6.0",directory:g.directory+"/input",extensionDir:g.extensionDir});b.OutputJax=g.Subclass({copyTranslate:true,preProcess:function(j){var i,h=this.directory+"/"+this.JAXFILE;this.constructor.prototype.preProcess=function(k){if(!i.called){return i}throw Error(h+" failed to load properly")};i=a.Require(h);return i},Register:function(i){var h=c.outputJax;if(!h[i]){h[i]=[]}if(h[i].length&&(this.id===c.config.menuSettings.renderer||(h.order[this.id]||0)<(h.order[h[i][0].id]||0))){h[i].unshift(this)}else{h[i].push(this)}if(!this.require){this.require=[]}else{if(!(this.require instanceof Array)){this.require=[this.require]}}this.require.push(b.ElementJax.directory+"/"+(i.split(/\//)[1])+"/"+this.JAXFILE)},Remove:function(h){}},{id:"OutputJax",version:"2.6.0",directory:g.directory+"/output",extensionDir:g.extensionDir,fontDir:e+(b.isPacked?"":"/..")+"/fonts",imageDir:e+(b.isPacked?"":"/..")+"/images"});b.ElementJax=g.Subclass({Init:function(i,h){return this.constructor.Subclass(i,h)},inputJax:null,outputJax:null,inputID:null,originalText:"",mimeType:"",sourceMenuTitle:["MathMLcode","MathML Code"],Text:function(i,j){var h=this.SourceElement();b.HTML.setScript(h,i);h.MathJax.state=this.STATE.UPDATE;return c.Update(h,j)},Reprocess:function(i){var h=this.SourceElement();h.MathJax.state=this.STATE.UPDATE;return c.Reprocess(h,i)},Update:function(h){return this.Rerender(h)},Rerender:function(i){var h=this.SourceElement();h.MathJax.state=this.STATE.OUTPUT;return c.Process(h,i)},Remove:function(h){if(this.hover){this.hover.clear(this)}b.OutputJax[this.outputJax].Remove(this);if(!h){c.signal.Post(["Remove Math",this.inputID]);this.Detach()}},needsUpdate:function(){return b.InputJax[this.inputJax].needsUpdate(this)},SourceElement:function(){return document.getElementById(this.inputID)},Attach:function(i,j){var h=i.MathJax.elementJax;if(i.MathJax.state===this.STATE.UPDATE){h.Clone(this)}else{h=i.MathJax.elementJax=this;if(i.id){this.inputID=i.id}else{i.id=this.inputID=b.ElementJax.GetID();this.newID=1}}h.originalText=b.HTML.getScript(i);h.inputJax=j;if(h.root){h.root.inputID=h.inputID}return h},Detach:function(){var h=this.SourceElement();if(!h){return}try{delete h.MathJax}catch(i){h.MathJax=null}if(this.newID){h.id=""}},Clone:function(h){var i;for(i in this){if(!this.hasOwnProperty(i)){continue}if(typeof(h[i])==="undefined"&&i!=="newID"){delete this[i]}}for(i in h){if(!h.hasOwnProperty(i)){continue}if(typeof(this[i])==="undefined"||(this[i]!==h[i]&&i!=="inputID")){this[i]=h[i]}}}},{id:"ElementJax",version:"2.6.0",directory:g.directory+"/element",extensionDir:g.extensionDir,ID:0,STATE:{PENDING:1,PROCESSED:2,UPDATE:3,OUTPUT:4},GetID:function(){this.ID++;return"MathJax-Element-"+this.ID},Subclass:function(){var h=g.Subclass.apply(this,arguments);h.loadComplete=this.prototype.loadComplete;return h}});b.ElementJax.prototype.STATE=b.ElementJax.STATE;b.OutputJax.Error={id:"Error",version:"2.6.0",config:{},errors:0,ContextMenu:function(){return b.Extension.MathEvents.Event.ContextMenu.apply(b.Extension.MathEvents.Event,arguments)},Mousedown:function(){return b.Extension.MathEvents.Event.AltContextMenu.apply(b.Extension.MathEvents.Event,arguments)},getJaxFromMath:function(h){return(h.nextSibling.MathJax||{}).error},Jax:function(j,i){var h=MathJax.Hub.inputJax[i.type.replace(/ *;(.|\s)*/,"")];this.errors++;return{inputJax:(h||{id:"Error"}).id,outputJax:"Error",inputID:"MathJax-Error-"+this.errors,sourceMenuTitle:["ErrorMessage","Error Message"],sourceMenuFormat:"Error",originalText:MathJax.HTML.getScript(i),errorText:j}}};b.InputJax.Error={id:"Error",version:"2.6.0",config:{},sourceMenuTitle:["Original","Original Form"]}})("MathJax");(function(o){var h=window[o];if(!h){h=window[o]={}}var d=h.Hub;var s=d.Startup;var w=d.config;var g=document.head||(document.getElementsByTagName("head")[0]);if(!g){g=document.childNodes[0]}var b=(document.documentElement||document).getElementsByTagName("script");if(b.length===0&&g.namespaceURI){b=document.getElementsByTagNameNS(g.namespaceURI,"script")}var f=new RegExp("(^|/)"+o+"\\.js(\\?.*)?$");for(var q=b.length-1;q>=0;q--){if((b[q].src||"").match(f)){s.script=b[q].innerHTML;if(RegExp.$2){var t=RegExp.$2.substr(1).split(/\&/);for(var p=0,l=t.length;p<l;p++){var n=t[p].match(/(.*)=(.*)/);if(n){s.params[unescape(n[1])]=unescape(n[2])}}}w.root=b[q].src.replace(/(^|\/)[^\/]*(\?.*)?$/,"").replace(/^(https?:\/\/cdn.mathjax.org\/mathjax\/)(latest)/,"$1"+h.version.split(/\./).slice(0,2).join(".")+"-$2");h.Ajax.config.root=w.root;break}}var k=navigator.userAgent;var a={isMac:(navigator.platform.substr(0,3)==="Mac"),isPC:(navigator.platform.substr(0,3)==="Win"),isMSIE:("ActiveXObject" in window&&"clipboardData" in window),isEdge:("MSGestureEvent" in window&&"chrome" in window&&window.chrome.loadTimes==null),isFirefox:(!!k.match(/Gecko\//)&&!k.match(/like Gecko/)),isSafari:(!!k.match(/ (Apple)?WebKit\//)&&!k.match(/ like iPhone /)&&(!window.chrome||window.chrome.app==null)),isChrome:("chrome" in window&&window.chrome.loadTimes!=null),isOpera:("opera" in window&&window.opera.version!=null),isKonqueror:("konqueror" in window&&navigator.vendor=="KDE"),versionAtLeast:function(y){var x=(this.version).split(".");y=(new String(y)).split(".");for(var z=0,j=y.length;z<j;z++){if(x[z]!=y[z]){return parseInt(x[z]||"0")>=parseInt(y[z])}}return true},Select:function(j){var i=j[d.Browser];if(i){return i(d.Browser)}return null}};var e=k.replace(/^Mozilla\/(\d+\.)+\d+ /,"").replace(/[a-z][-a-z0-9._: ]+\/\d+[^ ]*-[^ ]*\.([a-z][a-z])?\d+ /i,"").replace(/Gentoo |Ubuntu\/(\d+\.)*\d+ (\([^)]*\) )?/,"");d.Browser=d.Insert(d.Insert(new String("Unknown"),{version:"0.0"}),a);for(var v in a){if(a.hasOwnProperty(v)){if(a[v]&&v.substr(0,2)==="is"){v=v.slice(2);if(v==="Mac"||v==="PC"){continue}d.Browser=d.Insert(new String(v),a);var r=new RegExp(".*(Version/| Trident/.*; rv:)((?:\\d+\\.)+\\d+)|.*("+v+")"+(v=="MSIE"?" ":"/")+"((?:\\d+\\.)*\\d+)|(?:^|\\(| )([a-z][-a-z0-9._: ]+|(?:Apple)?WebKit)/((?:\\d+\\.)+\\d+)");var u=r.exec(e)||["","","","unknown","0.0"];d.Browser.name=(u[1]!=""?v:(u[3]||u[5]));d.Browser.version=u[2]||u[4]||u[6];break}}}try{d.Browser.Select({Safari:function(j){var i=parseInt((String(j.version).split("."))[0]);if(i>85){j.webkit=j.version}if(i>=538){j.version="8.0"}else{if(i>=537){j.version="7.0"}else{if(i>=536){j.version="6.0"}else{if(i>=534){j.version="5.1"}else{if(i>=533){j.version="5.0"}else{if(i>=526){j.version="4.0"}else{if(i>=525){j.version="3.1"}else{if(i>500){j.version="3.0"}else{if(i>400){j.version="2.0"}else{if(i>85){j.version="1.0"}}}}}}}}}}j.webkit=(navigator.appVersion.match(/WebKit\/(\d+)\./))[1];j.isMobile=(navigator.appVersion.match(/Mobile/i)!=null);j.noContextMenu=j.isMobile},Firefox:function(j){if((j.version==="0.0"||k.match(/Firefox/)==null)&&navigator.product==="Gecko"){var m=k.match(/[\/ ]rv:(\d+\.\d.*?)[\) ]/);if(m){j.version=m[1]}else{var i=(navigator.buildID||navigator.productSub||"0").substr(0,8);if(i>="20111220"){j.version="9.0"}else{if(i>="20111120"){j.version="8.0"}else{if(i>="20110927"){j.version="7.0"}else{if(i>="20110816"){j.version="6.0"}else{if(i>="20110621"){j.version="5.0"}else{if(i>="20110320"){j.version="4.0"}else{if(i>="20100121"){j.version="3.6"}else{if(i>="20090630"){j.version="3.5"}else{if(i>="20080617"){j.version="3.0"}else{if(i>="20061024"){j.version="2.0"}}}}}}}}}}}}j.isMobile=(navigator.appVersion.match(/Android/i)!=null||k.match(/ Fennec\//)!=null||k.match(/Mobile/)!=null)},Chrome:function(i){i.noContextMenu=i.isMobile=!!navigator.userAgent.match(/ Mobile[ \/]/)},Opera:function(i){i.version=opera.version()},Edge:function(i){i.isMobile=!!navigator.userAgent.match(/ Phone/)},MSIE:function(j){j.isMobile=!!navigator.userAgent.match(/ Phone/);j.isIE9=!!(document.documentMode&&(window.performance||window.msPerformance));MathJax.HTML.setScriptBug=!j.isIE9||document.documentMode<9;MathJax.Hub.msieHTMLCollectionBug=(document.documentMode<9);if(document.documentMode<10&&!s.params.NoMathPlayer){try{new ActiveXObject("MathPlayer.Factory.1");j.hasMathPlayer=true}catch(m){}try{if(j.hasMathPlayer){var i=document.createElement("object");i.id="mathplayer";i.classid="clsid:32F66A20-7614-11D4-BD11-00104BD3F987";g.appendChild(i);document.namespaces.add("m","http://www.w3.org/1998/Math/MathML");j.mpNamespace=true;if(document.readyState&&(document.readyState==="loading"||document.readyState==="interactive")){document.write('<?import namespace="m" implementation="#MathPlayer">');j.mpImported=true}}else{document.namespaces.add("mjx_IE_fix","http://www.w3.org/1999/xlink")}}catch(m){}}}})}catch(c){console.error(c.message)}d.Browser.Select(MathJax.Message.browsers);if(h.AuthorConfig&&typeof h.AuthorConfig.AuthorInit==="function"){h.AuthorConfig.AuthorInit()}d.queue=h.Callback.Queue();d.queue.Push(["Post",s.signal,"Begin"],["Config",s],["Cookie",s],["Styles",s],["Message",s],function(){var i=h.Callback.Queue(s.Jax(),s.Extensions());return i.Push({})},["Menu",s],s.onLoad(),function(){MathJax.isReady=true},["Typeset",s],["Hash",s],["MenuZoom",s],["Post",s.signal,"End"])})("MathJax")}};


/***/ },
/* 70 */
/***/ function(module, exports) {

	/*
	 *  /MathJax/config/TeX-AMS-MML_HTMLorMML.js
	 *  
	 *  Copyright (c) 2010-2015 The MathJax Consortium
	 *
	 *  Part of the MathJax library.
	 *  See http://www.mathjax.org for details.
	 * 
	 *  Licensed under the Apache License, Version 2.0;
	 *  you may not use this file except in compliance with the License.
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 */

	MathJax.Hub.Config({delayJaxRegistration: true});

	MathJax.Ajax.Preloading(
	  "[MathJax]/jax/input/TeX/config.js",
	  "[MathJax]/jax/input/MathML/config.js",
	  "[MathJax]/jax/output/HTML-CSS/config.js",
	  "[MathJax]/jax/output/NativeMML/config.js",
	  "[MathJax]/jax/output/PreviewHTML/config.js",
	  "[MathJax]/config/MMLorHTML.js",
	  "[MathJax]/extensions/tex2jax.js",
	  "[MathJax]/extensions/mml2jax.js",
	  "[MathJax]/extensions/MathEvents.js",
	  "[MathJax]/extensions/MathZoom.js",
	  "[MathJax]/extensions/MathMenu.js",
	  "[MathJax]/jax/element/mml/jax.js",
	  "[MathJax]/extensions/toMathML.js",
	  "[MathJax]/extensions/TeX/noErrors.js",
	  "[MathJax]/extensions/TeX/noUndefined.js",
	  "[MathJax]/jax/input/TeX/jax.js",
	  "[MathJax]/extensions/TeX/AMSmath.js",
	  "[MathJax]/extensions/TeX/AMSsymbols.js",
	  "[MathJax]/jax/input/MathML/jax.js",
	  "[MathJax]/jax/output/PreviewHTML/jax.js",
	  "[MathJax]/extensions/fast-preview.js",
	  "[MathJax]/extensions/AssistiveMML.js"
	);

	MathJax.Hub.Config({"v1.0-compatible":false});

	MathJax.InputJax.TeX=MathJax.InputJax({id:"TeX",version:"2.6.1",directory:MathJax.InputJax.directory+"/TeX",extensionDir:MathJax.InputJax.extensionDir+"/TeX",config:{TagSide:"right",TagIndent:"0.8em",MultLineWidth:"85%",equationNumbers:{autoNumber:"none",formatNumber:function(a){return a},formatTag:function(a){return"("+a+")"},formatID:function(a){return"mjx-eqn-"+String(a).replace(/[:"'<>&]/g,"")},formatURL:function(a){return"#"+escape(a)},useLabelIds:true}}});MathJax.InputJax.TeX.Register("math/tex");MathJax.InputJax.TeX.loadComplete("config.js");
	MathJax.InputJax.MathML=MathJax.InputJax({id:"MathML",version:"2.6.1",directory:MathJax.InputJax.directory+"/MathML",extensionDir:MathJax.InputJax.extensionDir+"/MathML",entityDir:MathJax.InputJax.directory+"/MathML/entities",config:{useMathMLspacing:false}});MathJax.InputJax.MathML.Register("math/mml");MathJax.InputJax.MathML.loadComplete("config.js");
	MathJax.OutputJax["HTML-CSS"]=MathJax.OutputJax({id:"HTML-CSS",version:"2.6.1",directory:MathJax.OutputJax.directory+"/HTML-CSS",extensionDir:MathJax.OutputJax.extensionDir+"/HTML-CSS",autoloadDir:MathJax.OutputJax.directory+"/HTML-CSS/autoload",fontDir:MathJax.OutputJax.directory+"/HTML-CSS/fonts",webfontDir:MathJax.OutputJax.fontDir+"/HTML-CSS",config:{noReflows:true,matchFontHeight:true,scale:100,minScaleAdjust:50,availableFonts:["STIX","TeX"],preferredFont:"TeX",webFont:"TeX",imageFont:"TeX",undefinedFamily:"STIXGeneral,'Arial Unicode MS',serif",mtextFontInherit:false,EqnChunk:(MathJax.Hub.Browser.isMobile?10:50),EqnChunkFactor:1.5,EqnChunkDelay:100,linebreaks:{automatic:false,width:"container"},styles:{".MathJax_Display":{"text-align":"center",margin:"1em 0em"},".MathJax .merror":{"background-color":"#FFFF88",color:"#CC0000",border:"1px solid #CC0000",padding:"1px 3px","font-style":"normal","font-size":"90%"},".MathJax .MJX-monospace":{"font-family":"monospace"},".MathJax .MJX-sans-serif":{"font-family":"sans-serif"},"#MathJax_Tooltip":{"background-color":"InfoBackground",color:"InfoText",border:"1px solid black","box-shadow":"2px 2px 5px #AAAAAA","-webkit-box-shadow":"2px 2px 5px #AAAAAA","-moz-box-shadow":"2px 2px 5px #AAAAAA","-khtml-box-shadow":"2px 2px 5px #AAAAAA",filter:"progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')",padding:"3px 4px","z-index":401}}}});if(MathJax.Hub.Browser.isMSIE&&document.documentMode>=9){delete MathJax.OutputJax["HTML-CSS"].config.styles["#MathJax_Tooltip"].filter}if(!MathJax.Hub.config.delayJaxRegistration){MathJax.OutputJax["HTML-CSS"].Register("jax/mml")}MathJax.Hub.Register.StartupHook("End Config",[function(b,c){var a=b.Insert({minBrowserVersion:{Firefox:3,Opera:9.52,MSIE:6,Chrome:0.3,Safari:2,Konqueror:4},inlineMathDelimiters:["$","$"],displayMathDelimiters:["$$","$$"],multilineDisplay:true,minBrowserTranslate:function(f){var e=b.getJaxFor(f),k=["[Math]"],j;var h=document.createElement("span",{className:"MathJax_Preview"});if(e.inputJax==="TeX"){if(e.root.Get("displaystyle")){j=a.displayMathDelimiters;k=[j[0]+e.originalText+j[1]];if(a.multilineDisplay){k=k[0].split(/\n/)}}else{j=a.inlineMathDelimiters;k=[j[0]+e.originalText.replace(/^\s+/,"").replace(/\s+$/,"")+j[1]]}}for(var g=0,d=k.length;g<d;g++){h.appendChild(document.createTextNode(k[g]));if(g<d-1){h.appendChild(document.createElement("br"))}}f.parentNode.insertBefore(h,f)}},(b.config["HTML-CSS"]||{}));if(b.Browser.version!=="0.0"&&!b.Browser.versionAtLeast(a.minBrowserVersion[b.Browser]||0)){c.Translate=a.minBrowserTranslate;b.Config({showProcessingMessages:false});MathJax.Message.Set(["MathJaxNotSupported","Your browser does not support MathJax"],null,4000);b.Startup.signal.Post("MathJax not supported")}},MathJax.Hub,MathJax.OutputJax["HTML-CSS"]]);MathJax.OutputJax["HTML-CSS"].loadComplete("config.js");
	MathJax.OutputJax.NativeMML=MathJax.OutputJax({id:"NativeMML",version:"2.6.1",directory:MathJax.OutputJax.directory+"/NativeMML",extensionDir:MathJax.OutputJax.extensionDir+"/NativeMML",config:{matchFontHeight:true,scale:100,minScaleAdjust:50,styles:{"div.MathJax_MathML":{"text-align":"center",margin:".75em 0px"}}}});if(!MathJax.Hub.config.delayJaxRegistration){MathJax.OutputJax.NativeMML.Register("jax/mml")}MathJax.OutputJax.NativeMML.loadComplete("config.js");
	MathJax.OutputJax.PreviewHTML=MathJax.OutputJax({id:"PreviewHTML",version:"2.6.1",directory:MathJax.OutputJax.directory+"/PreviewHTML",extensionDir:MathJax.OutputJax.extensionDir+"/PreviewHTML",noFastPreview:true,config:{scale:100,minScaleAdjust:50,mtextFontInherit:false,linebreaks:{automatic:false,width:"container"}}});if(!MathJax.Hub.config.delayJaxRegistration){MathJax.OutputJax.PreviewHTML.Register("jax/mml")}MathJax.OutputJax.PreviewHTML.loadComplete("config.js");
	(function(c,g){var f="2.6.0";var a=MathJax.Hub.CombineConfig("MMLorHTML",{prefer:{MSIE:"MML",Firefox:"HTML",Opera:"HTML",Chrome:"HTML",Safari:"HTML",other:"HTML"}});var e={Firefox:3,Opera:9.52,MSIE:6,Chrome:0.3,Safari:2,Konqueror:4};var b=(g.version==="0.0"||g.versionAtLeast(e[g]||0));var d=(g.isFirefox&&g.versionAtLeast("1.5"))||(g.isMSIE&&g.hasMathPlayer)||(g.isSafari&&g.versionAtLeast("5.0"))||(g.isOpera&&g.versionAtLeast("9.52"));c.Register.StartupHook("End Config",function(){var h=(a.prefer&&typeof(a.prefer)==="object"?a.prefer[MathJax.Hub.Browser]||a.prefer.other||"HTML":a.prefer);if(b||d){if(d&&(h==="MML"||!b)){if(MathJax.OutputJax.NativeMML){MathJax.OutputJax.NativeMML.Register("jax/mml")}else{c.config.jax.unshift("output/NativeMML")}c.Startup.signal.Post("NativeMML output selected")}else{if(MathJax.OutputJax["HTML-CSS"]){MathJax.OutputJax["HTML-CSS"].Register("jax/mml")}else{c.config.jax.unshift("output/HTML-CSS")}c.Startup.signal.Post("HTML-CSS output selected")}}else{c.PreProcess.disabled=true;c.prepareScripts.disabled=true;MathJax.Message.Set(["MathJaxNotSupported","Your browser does not support MathJax"],null,4000);c.Startup.signal.Post("MathJax not supported")}})})(MathJax.Hub,MathJax.Hub.Browser);MathJax.Ajax.loadComplete("[MathJax]/config/MMLorHTML.js");
	MathJax.Extension.tex2jax={version:"2.6.0",config:{inlineMath:[["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],balanceBraces:true,skipTags:["script","noscript","style","textarea","pre","code","annotation","annotation-xml"],ignoreClass:"tex2jax_ignore",processClass:"tex2jax_process",processEscapes:false,processEnvironments:true,processRefs:true,preview:"TeX"},PreProcess:function(a){if(!this.configured){this.config=MathJax.Hub.CombineConfig("tex2jax",this.config);if(this.config.Augment){MathJax.Hub.Insert(this,this.config.Augment)}if(typeof(this.config.previewTeX)!=="undefined"&&!this.config.previewTeX){this.config.preview="none"}this.configured=true}if(typeof(a)==="string"){a=document.getElementById(a)}if(!a){a=document.body}if(this.createPatterns()){this.scanElement(a,a.nextSibling)}},createPatterns:function(){var d=[],e=[],c,a,b=this.config;this.match={};for(c=0,a=b.inlineMath.length;c<a;c++){d.push(this.patternQuote(b.inlineMath[c][0]));this.match[b.inlineMath[c][0]]={mode:"",end:b.inlineMath[c][1],pattern:this.endPattern(b.inlineMath[c][1])}}for(c=0,a=b.displayMath.length;c<a;c++){d.push(this.patternQuote(b.displayMath[c][0]));this.match[b.displayMath[c][0]]={mode:"; mode=display",end:b.displayMath[c][1],pattern:this.endPattern(b.displayMath[c][1])}}if(d.length){e.push(d.sort(this.sortLength).join("|"))}if(b.processEnvironments){e.push("\\\\begin\\{([^}]*)\\}")}if(b.processEscapes){e.push("\\\\*\\\\\\$")}if(b.processRefs){e.push("\\\\(eq)?ref\\{[^}]*\\}")}this.start=new RegExp(e.join("|"),"g");this.skipTags=new RegExp("^("+b.skipTags.join("|")+")$","i");var f=[];if(MathJax.Hub.config.preRemoveClass){f.push(MathJax.Hub.config.preRemoveClass)}if(b.ignoreClass){f.push(b.ignoreClass)}this.ignoreClass=(f.length?new RegExp("(^| )("+f.join("|")+")( |$)"):/^$/);this.processClass=new RegExp("(^| )("+b.processClass+")( |$)");return(e.length>0)},patternQuote:function(a){return a.replace(/([\^$(){}+*?\-|\[\]\:\\])/g,"\\$1")},endPattern:function(a){return new RegExp(this.patternQuote(a)+"|\\\\.|[{}]","g")},sortLength:function(d,c){if(d.length!==c.length){return c.length-d.length}return(d==c?0:(d<c?-1:1))},scanElement:function(c,b,g){var a,e,d,f;while(c&&c!=b){if(c.nodeName.toLowerCase()==="#text"){if(!g){c=this.scanText(c)}}else{a=(typeof(c.className)==="undefined"?"":c.className);e=(typeof(c.tagName)==="undefined"?"":c.tagName);if(typeof(a)!=="string"){a=String(a)}f=this.processClass.exec(a);if(c.firstChild&&!a.match(/(^| )MathJax/)&&(f||!this.skipTags.exec(e))){d=(g||this.ignoreClass.exec(a))&&!f;this.scanElement(c.firstChild,b,d)}}if(c){c=c.nextSibling}}},scanText:function(b){if(b.nodeValue.replace(/\s+/,"")==""){return b}var a,c;this.search={start:true};this.pattern=this.start;while(b){this.pattern.lastIndex=0;while(b&&b.nodeName.toLowerCase()==="#text"&&(a=this.pattern.exec(b.nodeValue))){if(this.search.start){b=this.startMatch(a,b)}else{b=this.endMatch(a,b)}}if(this.search.matched){b=this.encloseMath(b)}if(b){do{c=b;b=b.nextSibling}while(b&&(b.nodeName.toLowerCase()==="br"||b.nodeName.toLowerCase()==="#comment"));if(!b||b.nodeName!=="#text"){return(this.search.close?this.prevEndMatch():c)}}}return b},startMatch:function(a,b){var f=this.match[a[0]];if(f!=null){this.search={end:f.end,mode:f.mode,pcount:0,open:b,olen:a[0].length,opos:this.pattern.lastIndex-a[0].length};this.switchPattern(f.pattern)}else{if(a[0].substr(0,6)==="\\begin"){this.search={end:"\\end{"+a[1]+"}",mode:"; mode=display",pcount:0,open:b,olen:0,opos:this.pattern.lastIndex-a[0].length,isBeginEnd:true};this.switchPattern(this.endPattern(this.search.end))}else{if(a[0].substr(0,4)==="\\ref"||a[0].substr(0,6)==="\\eqref"){this.search={mode:"",end:"",open:b,pcount:0,olen:0,opos:this.pattern.lastIndex-a[0].length};return this.endMatch([""],b)}else{var d=a[0].substr(0,a[0].length-1),g,c;if(d.length%2===0){c=[d.replace(/\\\\/g,"\\")];g=1}else{c=[d.substr(1).replace(/\\\\/g,"\\"),"$"];g=0}c=MathJax.HTML.Element("span",null,c);var e=MathJax.HTML.TextNode(b.nodeValue.substr(0,a.index));b.nodeValue=b.nodeValue.substr(a.index+a[0].length-g);b.parentNode.insertBefore(c,b);b.parentNode.insertBefore(e,c);this.pattern.lastIndex=g}}}return b},endMatch:function(a,c){var b=this.search;if(a[0]==b.end){if(!b.close||b.pcount===0){b.close=c;b.cpos=this.pattern.lastIndex;b.clen=(b.isBeginEnd?0:a[0].length)}if(b.pcount===0){b.matched=true;c=this.encloseMath(c);this.switchPattern(this.start)}}else{if(a[0]==="{"){b.pcount++}else{if(a[0]==="}"&&b.pcount){b.pcount--}}}return c},prevEndMatch:function(){this.search.matched=true;var a=this.encloseMath(this.search.close);this.switchPattern(this.start);return a},switchPattern:function(a){a.lastIndex=this.pattern.lastIndex;this.pattern=a;this.search.start=(a===this.start)},encloseMath:function(b){var a=this.search,f=a.close,e,c;if(a.cpos===f.length){f=f.nextSibling}else{f=f.splitText(a.cpos)}if(!f){e=f=MathJax.HTML.addText(a.close.parentNode,"")}a.close=f;c=(a.opos?a.open.splitText(a.opos):a.open);while(c.nextSibling&&c.nextSibling!==f){if(c.nextSibling.nodeValue!==null){if(c.nextSibling.nodeName==="#comment"){c.nodeValue+=c.nextSibling.nodeValue.replace(/^\[CDATA\[((.|\n|\r)*)\]\]$/,"$1")}else{c.nodeValue+=c.nextSibling.nodeValue}}else{if(this.msieNewlineBug){c.nodeValue+=(c.nextSibling.nodeName.toLowerCase()==="br"?"\n":" ")}else{c.nodeValue+=" "}}c.parentNode.removeChild(c.nextSibling)}var d=c.nodeValue.substr(a.olen,c.nodeValue.length-a.olen-a.clen);c.parentNode.removeChild(c);if(this.config.preview!=="none"){this.createPreview(a.mode,d)}c=this.createMathTag(a.mode,d);this.search={};this.pattern.lastIndex=0;if(e){e.parentNode.removeChild(e)}return c},insertNode:function(b){var a=this.search;a.close.parentNode.insertBefore(b,a.close)},createPreview:function(c,a){var b=this.config.preview;if(b==="none"){return}if(b==="TeX"){b=[this.filterPreview(a)]}if(b){b=MathJax.HTML.Element("span",{className:MathJax.Hub.config.preRemoveClass},b);this.insertNode(b)}},createMathTag:function(c,b){var a=document.createElement("script");a.type="math/tex"+c;MathJax.HTML.setScript(a,b);this.insertNode(a);return a},filterPreview:function(a){return a},msieNewlineBug:(MathJax.Hub.Browser.isMSIE&&document.documentMode<9)};MathJax.Hub.Register.PreProcessor(["PreProcess",MathJax.Extension.tex2jax]);MathJax.Ajax.loadComplete("[MathJax]/extensions/tex2jax.js");
	MathJax.Extension.mml2jax={version:"2.6.0",config:{preview:"mathml"},MMLnamespace:"http://www.w3.org/1998/Math/MathML",PreProcess:function(e){if(!this.configured){this.config=MathJax.Hub.CombineConfig("mml2jax",this.config);if(this.config.Augment){MathJax.Hub.Insert(this,this.config.Augment)}this.InitBrowser();this.configured=true}if(typeof(e)==="string"){e=document.getElementById(e)}if(!e){e=document.body}var h=[];this.PushMathElements(h,e,"math");this.PushMathElements(h,e,"math",this.MMLnamespace);var d,b;if(typeof(document.namespaces)!=="undefined"){try{for(d=0,b=document.namespaces.length;d<b;d++){var f=document.namespaces[d];if(f.urn===this.MMLnamespace){this.PushMathElements(h,e,f.name+":math")}}}catch(g){}}else{var c=document.getElementsByTagName("html")[0];if(c){for(d=0,b=c.attributes.length;d<b;d++){var a=c.attributes[d];if(a.nodeName.substr(0,6)==="xmlns:"&&a.nodeValue===this.MMLnamespace){this.PushMathElements(h,e,a.nodeName.substr(6)+":math")}}}}this.ProcessMathArray(h)},PushMathElements:function(f,d,a,c){var h,g=MathJax.Hub.config.preRemoveClass;if(c){if(!d.getElementsByTagNameNS){return}h=d.getElementsByTagNameNS(c,a)}else{h=d.getElementsByTagName(a)}for(var e=0,b=h.length;e<b;e++){var j=h[e].parentNode;if(j&&j.className!==g&&!j.isMathJax&&!h[e].prefix===!c){f.push(h[e])}}},ProcessMathArray:function(c){var b,a=c.length;if(a){if(this.MathTagBug){for(b=0;b<a;b++){if(c[b].nodeName==="MATH"){this.ProcessMathFlattened(c[b])}else{this.ProcessMath(c[b])}}}else{for(b=0;b<a;b++){this.ProcessMath(c[b])}}}},ProcessMath:function(e){var d=e.parentNode;if(!d||d.className===MathJax.Hub.config.preRemoveClass){return}var a=document.createElement("script");a.type="math/mml";d.insertBefore(a,e);if(this.AttributeBug){var b=this.OuterHTML(e);if(this.CleanupHTML){b=b.replace(/<\?import .*?>/i,"").replace(/<\?xml:namespace .*?\/>/i,"");b=b.replace(/&nbsp;/g,"&#xA0;")}MathJax.HTML.setScript(a,b);d.removeChild(e)}else{var c=MathJax.HTML.Element("span");c.appendChild(e);MathJax.HTML.setScript(a,c.innerHTML)}if(this.config.preview!=="none"){this.createPreview(e,a)}},ProcessMathFlattened:function(f){var d=f.parentNode;if(!d||d.className===MathJax.Hub.config.preRemoveClass){return}var b=document.createElement("script");b.type="math/mml";d.insertBefore(b,f);var c="",e,a=f;while(f&&f.nodeName!=="/MATH"){e=f;f=f.nextSibling;c+=this.NodeHTML(e);e.parentNode.removeChild(e)}if(f&&f.nodeName==="/MATH"){f.parentNode.removeChild(f)}b.text=c+"</math>";if(this.config.preview!=="none"){this.createPreview(a,b)}},NodeHTML:function(e){var c,b,a;if(e.nodeName==="#text"){c=this.quoteHTML(e.nodeValue)}else{if(e.nodeName==="#comment"){c="<!--"+e.nodeValue+"-->"}else{c="<"+e.nodeName.toLowerCase();for(b=0,a=e.attributes.length;b<a;b++){var d=e.attributes[b];if(d.specified&&d.nodeName.substr(0,10)!=="_moz-math-"){c+=" "+d.nodeName.toLowerCase().replace(/xmlns:xmlns/,"xmlns")+"=";var f=d.nodeValue;if(f==null&&d.nodeName==="style"&&e.style){f=e.style.cssText}c+='"'+this.quoteHTML(f)+'"'}}c+=">";if(e.outerHTML!=null&&e.outerHTML.match(/(.<\/[A-Z]+>|\/>)$/)){for(b=0,a=e.childNodes.length;b<a;b++){c+=this.OuterHTML(e.childNodes[b])}c+="</"+e.nodeName.toLowerCase()+">"}}}return c},OuterHTML:function(d){if(d.nodeName.charAt(0)==="#"){return this.NodeHTML(d)}if(!this.AttributeBug){return d.outerHTML}var c=this.NodeHTML(d);for(var b=0,a=d.childNodes.length;b<a;b++){c+=this.OuterHTML(d.childNodes[b])}c+="</"+d.nodeName.toLowerCase()+">";return c},quoteHTML:function(a){if(a==null){a=""}return a.replace(/&/g,"&#x26;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\"/g,"&quot;")},createPreview:function(f,b){var g=this.config.preview;if(g==="none"){return}var a=false;if(g==="mathml"){a=true;if(this.MathTagBug){g="alttext"}else{g=f.cloneNode(true)}}if(g==="alttext"||g==="altimg"){a=true;var c=this.filterPreview(f.getAttribute("alttext"));if(g==="alttext"){if(c!=null){g=MathJax.HTML.TextNode(c)}else{g=null}}else{var h=f.getAttribute("altimg");if(h!=null){var e={width:f.getAttribute("altimg-width"),height:f.getAttribute("altimg-height")};g=MathJax.HTML.Element("img",{src:h,alt:c,style:e})}else{g=null}}}if(g){var d;if(a){d=MathJax.HTML.Element("span",{className:MathJax.Hub.config.preRemoveClass});d.appendChild(g)}else{d=MathJax.HTML.Element("span",{className:MathJax.Hub.config.preRemoveClass},g)}b.parentNode.insertBefore(d,b)}},filterPreview:function(a){return a},InitBrowser:function(){var b=MathJax.HTML.Element("span",{id:"<",className:"mathjax",innerHTML:"<math><mi>x</mi><mspace /></math>"});var a=b.outerHTML||"";this.AttributeBug=a!==""&&!(a.match(/id="&lt;"/)&&a.match(/class="mathjax"/)&&a.match(/<\/math>/));this.MathTagBug=b.childNodes.length>1;this.CleanupHTML=MathJax.Hub.Browser.isMSIE}};MathJax.Hub.Register.PreProcessor(["PreProcess",MathJax.Extension.mml2jax],5);MathJax.Ajax.loadComplete("[MathJax]/extensions/mml2jax.js");
	(function(d,h,l,g,m,b,j){var p="2.6.0";var i=MathJax.Extension;var c=i.MathEvents={version:p};var k=d.config.menuSettings;var o={hover:500,frame:{x:3.5,y:5,bwidth:1,bcolor:"#A6D",hwidth:"15px",hcolor:"#83A"},button:{x:-6,y:-3,wx:-2},fadeinInc:0.2,fadeoutInc:0.05,fadeDelay:50,fadeoutStart:400,fadeoutDelay:15*1000,styles:{".MathJax_Hover_Frame":{"border-radius":".25em","-webkit-border-radius":".25em","-moz-border-radius":".25em","-khtml-border-radius":".25em","box-shadow":"0px 0px 15px #83A","-webkit-box-shadow":"0px 0px 15px #83A","-moz-box-shadow":"0px 0px 15px #83A","-khtml-box-shadow":"0px 0px 15px #83A",border:"1px solid #A6D ! important",display:"inline-block",position:"absolute"},".MathJax_Menu_Button .MathJax_Hover_Arrow":{position:"absolute",cursor:"pointer",display:"inline-block",border:"2px solid #AAA","border-radius":"4px","-webkit-border-radius":"4px","-moz-border-radius":"4px","-khtml-border-radius":"4px","font-family":"'Courier New',Courier","font-size":"9px",color:"#F0F0F0"},".MathJax_Menu_Button .MathJax_Hover_Arrow span":{display:"block","background-color":"#AAA",border:"1px solid","border-radius":"3px","line-height":0,padding:"4px"},".MathJax_Hover_Arrow:hover":{color:"white!important",border:"2px solid #CCC!important"},".MathJax_Hover_Arrow:hover span":{"background-color":"#CCC!important"}}};var n=c.Event={LEFTBUTTON:0,RIGHTBUTTON:2,MENUKEY:"altKey",KEY:{RETURN:13,ESCAPE:27,SPACE:32,LEFT:37,UP:38,RIGHT:39,DOWN:40},Mousedown:function(q){return n.Handler(q,"Mousedown",this)},Mouseup:function(q){return n.Handler(q,"Mouseup",this)},Mousemove:function(q){return n.Handler(q,"Mousemove",this)},Mouseover:function(q){return n.Handler(q,"Mouseover",this)},Mouseout:function(q){return n.Handler(q,"Mouseout",this)},Click:function(q){return n.Handler(q,"Click",this)},DblClick:function(q){return n.Handler(q,"DblClick",this)},Menu:function(q){return n.Handler(q,"ContextMenu",this)},Handler:function(t,r,s){if(l.loadingMathMenu){return n.False(t)}var q=b[s.jaxID];if(!t){t=window.event}t.isContextMenu=(r==="ContextMenu");if(q[r]){return q[r](t,s)}if(i.MathZoom){return i.MathZoom.HandleEvent(t,r,s)}},False:function(q){if(!q){q=window.event}if(q){if(q.preventDefault){q.preventDefault()}else{q.returnValue=false}if(q.stopPropagation){q.stopPropagation()}q.cancelBubble=true}return false},Keydown:function(r,q){if(!r){r=window.event}if(r.keyCode===n.KEY.SPACE){n.ContextMenu(r,this)}},ContextMenu:function(t,E,w){var B=b[E.jaxID],v=B.getJaxFromMath(E);var F=(B.config.showMathMenu!=null?B:d).config.showMathMenu;if(!F||(k.context!=="MathJax"&&!w)){return}if(c.msieEventBug){t=window.event||t}n.ClearSelection();f.ClearHoverTimer();if(v.hover){if(v.hover.remove){clearTimeout(v.hover.remove);delete v.hover.remove}v.hover.nofade=true}var u=MathJax.Menu;var G,D;if(u){if(u.loadingDomain){return n.False(t)}G=m.loadDomain("MathMenu");if(!G){u.jax=v;var r=u.menu.Find("Show Math As").submenu;r.items[0].name=v.sourceMenuTitle;r.items[0].format=(v.sourceMenuFormat||"MathML");r.items[1].name=j[v.inputJax].sourceMenuTitle;r.items[5].disabled=!j[v.inputJax].annotationEncoding;var A=r.items[2];A.disabled=true;var q=A.submenu.items;annotationList=MathJax.Hub.Config.semanticsAnnotations;for(var z=0,y=q.length;z<y;z++){var s=q[z].name[1];if(v.root&&v.root.getAnnotation(s)!==null){A.disabled=false;q[z].hidden=false}else{q[z].hidden=true}}var x=u.menu.Find("Math Settings","MathPlayer");x.hidden=!(v.outputJax==="NativeMML"&&d.Browser.hasMathPlayer);return u.menu.Post(t)}u.loadingDomain=true;D=function(){delete u.loadingDomain}}else{if(l.loadingMathMenu){return n.False(t)}l.loadingMathMenu=true;G=l.Require("[MathJax]/extensions/MathMenu.js");D=function(){delete l.loadingMathMenu;if(!MathJax.Menu){MathJax.Menu={}}}}var C={pageX:t.pageX,pageY:t.pageY,clientX:t.clientX,clientY:t.clientY};g.Queue(G,D,["ContextMenu",n,C,E,w]);return n.False(t)},AltContextMenu:function(s,r){var t=b[r.jaxID];var q=(t.config.showMathMenu!=null?t:d).config.showMathMenu;if(q){q=(t.config.showMathMenuMSIE!=null?t:d).config.showMathMenuMSIE;if(k.context==="MathJax"&&!k.mpContext&&q){if(!c.noContextMenuBug||s.button!==n.RIGHTBUTTON){return}}else{if(!s[n.MENUKEY]||s.button!==n.LEFTBUTTON){return}}return t.ContextMenu(s,r,true)}},ClearSelection:function(){if(c.safariContextMenuBug){setTimeout("window.getSelection().empty()",0)}if(document.selection){setTimeout("document.selection.empty()",0)}},getBBox:function(s){s.appendChild(c.topImg);var r=c.topImg.offsetTop,t=s.offsetHeight-r,q=s.offsetWidth;s.removeChild(c.topImg);return{w:q,h:r,d:t}}};var f=c.Hover={Mouseover:function(s,r){if(k.discoverable||k.zoom==="Hover"){var u=s.fromElement||s.relatedTarget,t=s.toElement||s.target;if(u&&t&&(d.isMathJaxNode(u)!==d.isMathJaxNode(t)||d.getJaxFor(u)!==d.getJaxFor(t))){var q=this.getJaxFromMath(r);if(q.hover){f.ReHover(q)}else{f.HoverTimer(q,r)}return n.False(s)}}},Mouseout:function(s,r){if(k.discoverable||k.zoom==="Hover"){var u=s.fromElement||s.relatedTarget,t=s.toElement||s.target;if(u&&t&&(d.isMathJaxNode(u)!==d.isMathJaxNode(t)||d.getJaxFor(u)!==d.getJaxFor(t))){var q=this.getJaxFromMath(r);if(q.hover){f.UnHover(q)}else{f.ClearHoverTimer()}return n.False(s)}}},Mousemove:function(s,r){if(k.discoverable||k.zoom==="Hover"){var q=this.getJaxFromMath(r);if(q.hover){return}if(f.lastX==s.clientX&&f.lastY==s.clientY){return}f.lastX=s.clientX;f.lastY=s.clientY;f.HoverTimer(q,r);return n.False(s)}},HoverTimer:function(q,r){this.ClearHoverTimer();this.hoverTimer=setTimeout(g(["Hover",this,q,r]),o.hover)},ClearHoverTimer:function(){if(this.hoverTimer){clearTimeout(this.hoverTimer);delete this.hoverTimer}},Hover:function(q,u){if(i.MathZoom&&i.MathZoom.Hover({},u)){return}var t=b[q.outputJax],v=t.getHoverSpan(q,u),y=t.getHoverBBox(q,v,u),w=(t.config.showMathMenu!=null?t:d).config.showMathMenu;var A=o.frame.x,z=o.frame.y,x=o.frame.bwidth;if(c.msieBorderWidthBug){x=0}q.hover={opacity:0,id:q.inputID+"-Hover"};var r=h.Element("span",{id:q.hover.id,isMathJax:true,style:{display:"inline-block",width:0,height:0,position:"relative"}},[["span",{className:"MathJax_Hover_Frame",isMathJax:true,style:{display:"inline-block",position:"absolute",top:this.Px(-y.h-z-x-(y.y||0)),left:this.Px(-A-x+(y.x||0)),width:this.Px(y.w+2*A),height:this.Px(y.h+y.d+2*z),opacity:0,filter:"alpha(opacity=0)"}}]]);var s=h.Element("span",{isMathJax:true,id:q.hover.id+"Menu",className:"MathJax_Menu_Button",style:{display:"inline-block","z-index":1,width:0,height:0,position:"relative"}},[["span",{className:"MathJax_Hover_Arrow",isMathJax:true,math:u,onclick:this.HoverMenu,jax:t.id,style:{left:this.Px(y.w+A+x+(y.x||0)+o.button.x),top:this.Px(-y.h-z-x-(y.y||0)-o.button.y),opacity:0,filter:"alpha(opacity=0)"}},[["span",{isMathJax:true},"\u25BC"]]]]);if(y.width){r.style.width=s.style.width=y.width;r.style.marginRight=s.style.marginRight="-"+y.width;r.firstChild.style.width=y.width;s.firstChild.style.left="";s.firstChild.style.right=this.Px(o.button.wx)}v.parentNode.insertBefore(r,v);if(w){v.parentNode.insertBefore(s,v)}if(v.style){v.style.position="relative"}this.ReHover(q)},ReHover:function(q){if(q.hover.remove){clearTimeout(q.hover.remove)}q.hover.remove=setTimeout(g(["UnHover",this,q]),o.fadeoutDelay);this.HoverFadeTimer(q,o.fadeinInc)},UnHover:function(q){if(!q.hover.nofade){this.HoverFadeTimer(q,-o.fadeoutInc,o.fadeoutStart)}},HoverFade:function(q){delete q.hover.timer;q.hover.opacity=Math.max(0,Math.min(1,q.hover.opacity+q.hover.inc));q.hover.opacity=Math.floor(1000*q.hover.opacity)/1000;var s=document.getElementById(q.hover.id),r=document.getElementById(q.hover.id+"Menu");s.firstChild.style.opacity=q.hover.opacity;s.firstChild.style.filter="alpha(opacity="+Math.floor(100*q.hover.opacity)+")";if(r){r.firstChild.style.opacity=q.hover.opacity;r.firstChild.style.filter=s.style.filter}if(q.hover.opacity===1){return}if(q.hover.opacity>0){this.HoverFadeTimer(q,q.hover.inc);return}s.parentNode.removeChild(s);if(r){r.parentNode.removeChild(r)}if(q.hover.remove){clearTimeout(q.hover.remove)}delete q.hover},HoverFadeTimer:function(q,s,r){q.hover.inc=s;if(!q.hover.timer){q.hover.timer=setTimeout(g(["HoverFade",this,q]),(r||o.fadeDelay))}},HoverMenu:function(q){if(!q){q=window.event}return b[this.jax].ContextMenu(q,this.math,true)},ClearHover:function(q){if(q.hover.remove){clearTimeout(q.hover.remove)}if(q.hover.timer){clearTimeout(q.hover.timer)}f.ClearHoverTimer();delete q.hover},Px:function(q){if(Math.abs(q)<0.006){return"0px"}return q.toFixed(2).replace(/\.?0+$/,"")+"px"},getImages:function(){if(k.discoverable){var q=new Image();q.src=o.button.src}}};var a=c.Touch={last:0,delay:500,start:function(r){var q=new Date().getTime();var s=(q-a.last<a.delay&&a.up);a.last=q;a.up=false;if(s){a.timeout=setTimeout(a.menu,a.delay,r,this);r.preventDefault()}},end:function(r){var q=new Date().getTime();a.up=(q-a.last<a.delay);if(a.timeout){clearTimeout(a.timeout);delete a.timeout;a.last=0;a.up=false;r.preventDefault();return n.Handler((r.touches[0]||r.touch),"DblClick",this)}},menu:function(r,q){delete a.timeout;a.last=0;a.up=false;return n.Handler((r.touches[0]||r.touch),"ContextMenu",q)}};d.Browser.Select({MSIE:function(q){var s=(document.documentMode||0);var r=q.versionAtLeast("8.0");c.msieBorderWidthBug=(document.compatMode==="BackCompat");c.msieEventBug=q.isIE9;c.msieAlignBug=(!r||s<8);if(s<9){n.LEFTBUTTON=1}},Safari:function(q){c.safariContextMenuBug=true},Opera:function(q){c.operaPositionBug=true},Konqueror:function(q){c.noContextMenuBug=true}});c.topImg=(c.msieAlignBug?h.Element("img",{style:{width:0,height:0,position:"relative"},src:"about:blank"}):h.Element("span",{style:{width:0,height:0,display:"inline-block"}}));if(c.operaPositionBug){c.topImg.style.border="1px solid"}c.config=o=d.CombineConfig("MathEvents",o);var e=function(){var q=o.styles[".MathJax_Hover_Frame"];q.border=o.frame.bwidth+"px solid "+o.frame.bcolor+" ! important";q["box-shadow"]=q["-webkit-box-shadow"]=q["-moz-box-shadow"]=q["-khtml-box-shadow"]="0px 0px "+o.frame.hwidth+" "+o.frame.hcolor};g.Queue(d.Register.StartupHook("End Config",{}),[e],["getImages",f],["Styles",l,o.styles],["Post",d.Startup.signal,"MathEvents Ready"],["loadComplete",l,"[MathJax]/extensions/MathEvents.js"])})(MathJax.Hub,MathJax.HTML,MathJax.Ajax,MathJax.Callback,MathJax.Localization,MathJax.OutputJax,MathJax.InputJax);
	(function(a,d,f,c,j){var k="2.6.0";var i=a.CombineConfig("MathZoom",{styles:{"#MathJax_Zoom":{position:"absolute","background-color":"#F0F0F0",overflow:"auto",display:"block","z-index":301,padding:".5em",border:"1px solid black",margin:0,"font-weight":"normal","font-style":"normal","text-align":"left","text-indent":0,"text-transform":"none","line-height":"normal","letter-spacing":"normal","word-spacing":"normal","word-wrap":"normal","white-space":"nowrap","float":"none","-webkit-box-sizing":"content-box","-moz-box-sizing":"content-box","box-sizing":"content-box","box-shadow":"5px 5px 15px #AAAAAA","-webkit-box-shadow":"5px 5px 15px #AAAAAA","-moz-box-shadow":"5px 5px 15px #AAAAAA","-khtml-box-shadow":"5px 5px 15px #AAAAAA",filter:"progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')"},"#MathJax_ZoomOverlay":{position:"absolute",left:0,top:0,"z-index":300,display:"inline-block",width:"100%",height:"100%",border:0,padding:0,margin:0,"background-color":"white",opacity:0,filter:"alpha(opacity=0)"},"#MathJax_ZoomFrame":{position:"relative",display:"inline-block",height:0,width:0},"#MathJax_ZoomEventTrap":{position:"absolute",left:0,top:0,"z-index":302,display:"inline-block",border:0,padding:0,margin:0,"background-color":"white",opacity:0,filter:"alpha(opacity=0)"}}});var e,b,g;MathJax.Hub.Register.StartupHook("MathEvents Ready",function(){g=MathJax.Extension.MathEvents.Event;e=MathJax.Extension.MathEvents.Event.False;b=MathJax.Extension.MathEvents.Hover});var h=MathJax.Extension.MathZoom={version:k,settings:a.config.menuSettings,scrollSize:18,HandleEvent:function(n,l,m){if(h.settings.CTRL&&!n.ctrlKey){return true}if(h.settings.ALT&&!n.altKey){return true}if(h.settings.CMD&&!n.metaKey){return true}if(h.settings.Shift&&!n.shiftKey){return true}if(!h[l]){return true}return h[l](n,m)},Click:function(m,l){if(this.settings.zoom==="Click"){return this.Zoom(m,l)}},DblClick:function(m,l){if(this.settings.zoom==="Double-Click"||this.settings.zoom==="DoubleClick"){return this.Zoom(m,l)}},Hover:function(m,l){if(this.settings.zoom==="Hover"){this.Zoom(m,l);return true}return false},Zoom:function(o,u){this.Remove();b.ClearHoverTimer();g.ClearSelection();var s=MathJax.OutputJax[u.jaxID];var p=s.getJaxFromMath(u);if(p.hover){b.UnHover(p)}var q=this.findContainer(u);var l=Math.floor(0.85*q.clientWidth),t=Math.max(document.body.clientHeight,document.documentElement.clientHeight);if(this.getOverflow(q)!=="visible"){t=Math.min(q.clientHeight,t)}t=Math.floor(0.85*t);var n=d.Element("span",{id:"MathJax_ZoomFrame"},[["span",{id:"MathJax_ZoomOverlay",onmousedown:this.Remove}],["span",{id:"MathJax_Zoom",onclick:this.Remove,style:{visibility:"hidden",fontSize:this.settings.zscale}},[["span",{style:{display:"inline-block","white-space":"nowrap"}}]]]]);var z=n.lastChild,w=z.firstChild,r=n.firstChild;u.parentNode.insertBefore(n,u);u.parentNode.insertBefore(u,n);if(w.addEventListener){w.addEventListener("mousedown",this.Remove,true)}var m=z.offsetWidth||z.clientWidth;l-=m;t-=m;z.style.maxWidth=l+"px";z.style.maxHeight=t+"px";if(this.msieTrapEventBug){var y=d.Element("span",{id:"MathJax_ZoomEventTrap",onmousedown:this.Remove});n.insertBefore(y,z)}if(this.msieZIndexBug){var v=d.addElement(document.body,"img",{src:"about:blank",id:"MathJax_ZoomTracker",width:0,height:0,style:{width:0,height:0,position:"relative"}});n.style.position="relative";n.style.zIndex=i.styles["#MathJax_ZoomOverlay"]["z-index"];n=v}var x=s.Zoom(p,w,u,l,t);if(this.msiePositionBug){if(this.msieSizeBug){z.style.height=x.zH+"px";z.style.width=x.zW+"px"}if(z.offsetHeight>t){z.style.height=t+"px";z.style.width=(x.zW+this.scrollSize)+"px"}if(z.offsetWidth>l){z.style.width=l+"px";z.style.height=(x.zH+this.scrollSize)+"px"}}if(this.operaPositionBug){z.style.width=Math.min(l,x.zW)+"px"}if(z.offsetWidth>m&&z.offsetWidth-m<l&&z.offsetHeight-m<t){z.style.overflow="visible"}this.Position(z,x);if(this.msieTrapEventBug){y.style.height=z.clientHeight+"px";y.style.width=z.clientWidth+"px";y.style.left=(parseFloat(z.style.left)+z.clientLeft)+"px";y.style.top=(parseFloat(z.style.top)+z.clientTop)+"px"}z.style.visibility="";if(this.settings.zoom==="Hover"){r.onmouseover=this.Remove}if(window.addEventListener){addEventListener("resize",this.Resize,false)}else{if(window.attachEvent){attachEvent("onresize",this.Resize)}else{this.onresize=window.onresize;window.onresize=this.Resize}}a.signal.Post(["math zoomed",p]);return e(o)},Position:function(p,r){p.style.display="none";var q=this.Resize(),m=q.x,s=q.y,l=r.mW;p.style.display="";var o=-l-Math.floor((p.offsetWidth-l)/2),n=r.Y;p.style.left=Math.max(o,10-m)+"px";p.style.top=Math.max(n,10-s)+"px";if(!h.msiePositionBug){h.SetWH()}},Resize:function(m){if(h.onresize){h.onresize(m)}var q=document.getElementById("MathJax_ZoomFrame"),l=document.getElementById("MathJax_ZoomOverlay");var o=h.getXY(q),n=h.findContainer(q);if(h.getOverflow(n)!=="visible"){l.scroll_parent=n;var p=h.getXY(n);o.x-=p.x;o.y-=p.y;p=h.getBorder(n);o.x-=p.x;o.y-=p.y}l.style.left=(-o.x)+"px";l.style.top=(-o.y)+"px";if(h.msiePositionBug){setTimeout(h.SetWH,0)}else{h.SetWH()}return o},SetWH:function(){var l=document.getElementById("MathJax_ZoomOverlay");if(!l){return}l.style.display="none";var m=l.scroll_parent||document.documentElement||document.body;l.style.width=m.scrollWidth+"px";l.style.height=Math.max(m.clientHeight,m.scrollHeight)+"px";l.style.display=""},findContainer:function(l){l=l.parentNode;while(l.parentNode&&l!==document.body&&h.getOverflow(l)==="visible"){l=l.parentNode}return l},getOverflow:(window.getComputedStyle?function(l){return getComputedStyle(l).overflow}:function(l){return(l.currentStyle||{overflow:"visible"}).overflow}),getBorder:function(o){var m={thin:1,medium:2,thick:3};var n=(window.getComputedStyle?getComputedStyle(o):(o.currentStyle||{borderLeftWidth:0,borderTopWidth:0}));var l=n.borderLeftWidth,p=n.borderTopWidth;if(m[l]){l=m[l]}else{l=parseInt(l)}if(m[p]){p=m[p]}else{p=parseInt(p)}return{x:l,y:p}},getXY:function(o){var l=0,n=0,m;m=o;while(m.offsetParent){l+=m.offsetLeft;m=m.offsetParent}if(h.operaPositionBug){o.style.border="1px solid"}m=o;while(m.offsetParent){n+=m.offsetTop;m=m.offsetParent}if(h.operaPositionBug){o.style.border=""}return{x:l,y:n}},Remove:function(n){var p=document.getElementById("MathJax_ZoomFrame");if(p){var o=MathJax.OutputJax[p.previousSibling.jaxID];var l=o.getJaxFromMath(p.previousSibling);a.signal.Post(["math unzoomed",l]);p.parentNode.removeChild(p);p=document.getElementById("MathJax_ZoomTracker");if(p){p.parentNode.removeChild(p)}if(h.operaRefreshBug){var m=d.addElement(document.body,"div",{style:{position:"fixed",left:0,top:0,width:"100%",height:"100%",backgroundColor:"white",opacity:0},id:"MathJax_OperaDiv"});document.body.removeChild(m)}if(window.removeEventListener){removeEventListener("resize",h.Resize,false)}else{if(window.detachEvent){detachEvent("onresize",h.Resize)}else{window.onresize=h.onresize;delete h.onresize}}}return e(n)}};a.Browser.Select({MSIE:function(l){var n=(document.documentMode||0);var m=(n>=9);h.msiePositionBug=!m;h.msieSizeBug=l.versionAtLeast("7.0")&&(!document.documentMode||n===7||n===8);h.msieZIndexBug=(n<=7);h.msieInlineBlockAlignBug=(n<=7);h.msieTrapEventBug=!window.addEventListener;if(document.compatMode==="BackCompat"){h.scrollSize=52}if(m){delete i.styles["#MathJax_Zoom"].filter}},Opera:function(l){h.operaPositionBug=true;h.operaRefreshBug=true}});h.topImg=(h.msieInlineBlockAlignBug?d.Element("img",{style:{width:0,height:0,position:"relative"},src:"about:blank"}):d.Element("span",{style:{width:0,height:0,display:"inline-block"}}));if(h.operaPositionBug||h.msieTopBug){h.topImg.style.border="1px solid"}MathJax.Callback.Queue(["StartupHook",MathJax.Hub.Register,"Begin Styles",{}],["Styles",f,i.styles],["Post",a.Startup.signal,"MathZoom Ready"],["loadComplete",f,"[MathJax]/extensions/MathZoom.js"])})(MathJax.Hub,MathJax.HTML,MathJax.Ajax,MathJax.OutputJax["HTML-CSS"],MathJax.OutputJax.NativeMML);
	(function(f,n,p,e,q){var o="2.6.1";var d=MathJax.Callback.Signal("menu");MathJax.Extension.MathMenu={version:o,signal:d};var s=function(t){return MathJax.Localization._.apply(MathJax.Localization,[["MathMenu",t]].concat([].slice.call(arguments,1)))};var a=f.Browser.isPC,k=f.Browser.isMSIE,l=((document.documentMode||0)>8);var i=(a?null:"5px");var r=f.CombineConfig("MathMenu",{delay:150,showRenderer:true,showMathPlayer:true,showFontMenu:false,showContext:false,showDiscoverable:false,showLocale:true,showLocaleURL:false,semanticsAnnotations:{TeX:["TeX","LaTeX","application/x-tex"],StarMath:["StarMath 5.0"],Maple:["Maple"],ContentMathML:["MathML-Content","application/mathml-content+xml"],OpenMath:["OpenMath"]},windowSettings:{status:"no",toolbar:"no",locationbar:"no",menubar:"no",directories:"no",personalbar:"no",resizable:"yes",scrollbars:"yes",width:400,height:300,left:Math.round((screen.width-400)/2),top:Math.round((screen.height-300)/3)},styles:{"#MathJax_About":{position:"fixed",left:"50%",width:"auto","text-align":"center",border:"3px outset",padding:"1em 2em","background-color":"#DDDDDD",color:"black",cursor:"default","font-family":"message-box","font-size":"120%","font-style":"normal","text-indent":0,"text-transform":"none","line-height":"normal","letter-spacing":"normal","word-spacing":"normal","word-wrap":"normal","white-space":"nowrap","float":"none","z-index":201,"border-radius":"15px","-webkit-border-radius":"15px","-moz-border-radius":"15px","-khtml-border-radius":"15px","box-shadow":"0px 10px 20px #808080","-webkit-box-shadow":"0px 10px 20px #808080","-moz-box-shadow":"0px 10px 20px #808080","-khtml-box-shadow":"0px 10px 20px #808080",filter:"progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')"},"#MathJax_About.MathJax_MousePost":{outline:"none"},".MathJax_Menu":{position:"absolute","background-color":"white",color:"black",width:"auto",padding:(a?"2px":"5px 0px"),border:"1px solid #CCCCCC",margin:0,cursor:"default",font:"menu","text-align":"left","text-indent":0,"text-transform":"none","line-height":"normal","letter-spacing":"normal","word-spacing":"normal","word-wrap":"normal","white-space":"nowrap","float":"none","z-index":201,"border-radius":i,"-webkit-border-radius":i,"-moz-border-radius":i,"-khtml-border-radius":i,"box-shadow":"0px 10px 20px #808080","-webkit-box-shadow":"0px 10px 20px #808080","-moz-box-shadow":"0px 10px 20px #808080","-khtml-box-shadow":"0px 10px 20px #808080",filter:"progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')"},".MathJax_MenuItem":{padding:(a?"2px 2em":"1px 2em"),background:"transparent"},".MathJax_MenuArrow":{position:"absolute",right:".5em","padding-top":".25em",color:"#666666","font-family":(k?"'Arial unicode MS'":null),"font-size":".75em"},".MathJax_MenuActive .MathJax_MenuArrow":{color:"white"},".MathJax_MenuArrow.RTL":{left:".5em",right:"auto"},".MathJax_MenuCheck":{position:"absolute",left:".7em","font-family":(k?"'Arial unicode MS'":null)},".MathJax_MenuCheck.RTL":{right:".7em",left:"auto"},".MathJax_MenuRadioCheck":{position:"absolute",left:(a?"1em":".7em")},".MathJax_MenuRadioCheck.RTL":{right:(a?"1em":".7em"),left:"auto"},".MathJax_MenuLabel":{padding:(a?"2px 2em 4px 1.33em":"1px 2em 3px 1.33em"),"font-style":"italic"},".MathJax_MenuRule":{"border-top":(a?"1px solid #CCCCCC":"1px solid #DDDDDD"),margin:(a?"4px 1px 0px":"4px 3px")},".MathJax_MenuDisabled":{color:"GrayText"},".MathJax_MenuActive":{"background-color":(a?"Highlight":"#606872"),color:(a?"HighlightText":"white")},".MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus":{"background-color":"#E8E8E8"},".MathJax_ContextMenu:focus":{outline:"none"},".MathJax_ContextMenu .MathJax_MenuItem:focus":{outline:"none"},"#MathJax_AboutClose":{top:".2em",right:".2em"},".MathJax_Menu .MathJax_MenuClose":{top:"-10px",left:"-10px"},".MathJax_MenuClose":{position:"absolute",cursor:"pointer",display:"inline-block",border:"2px solid #AAA","border-radius":"18px","-webkit-border-radius":"18px","-moz-border-radius":"18px","-khtml-border-radius":"18px","font-family":"'Courier New',Courier","font-size":"24px",color:"#F0F0F0"},".MathJax_MenuClose span":{display:"block","background-color":"#AAA",border:"1.5px solid","border-radius":"18px","-webkit-border-radius":"18px","-moz-border-radius":"18px","-khtml-border-radius":"18px","line-height":0,padding:"8px 0 6px"},".MathJax_MenuClose:hover":{color:"white!important",border:"2px solid #CCC!important"},".MathJax_MenuClose:hover span":{"background-color":"#CCC!important"},".MathJax_MenuClose:hover:focus":{outline:"none"}}});var m,j,b;f.Register.StartupHook("MathEvents Ready",function(){m=MathJax.Extension.MathEvents.Event.False;j=MathJax.Extension.MathEvents.Hover;b=MathJax.Extension.MathEvents.Event.KEY});var h=MathJax.Object.Subclass({Keydown:function(t,u){switch(t.keyCode){case b.ESCAPE:this.Remove(t,u);break;case b.RIGHT:this.Right(t,u);break;case b.LEFT:this.Left(t,u);break;case b.UP:this.Up(t,u);break;case b.DOWN:this.Down(t,u);break;case b.RETURN:case b.SPACE:this.Space(t,u);break;default:return;break}return m(t)},Escape:function(t,u){},Right:function(t,u){},Left:function(t,u){},Up:function(t,u){},Down:function(t,u){},Space:function(t,u){}},{});var g=MathJax.Menu=h.Subclass({version:o,items:[],posted:false,title:null,margin:5,Init:function(t){this.items=[].slice.call(arguments,0)},With:function(t){if(t){f.Insert(this,t)}return this},Post:function(u,I,G){if(!u){u=window.event||{}}var t=document.getElementById("MathJax_MenuFrame");if(!t){t=g.Background(this);delete c.lastItem;delete c.lastMenu;delete g.skipUp;d.Post(["post",g.jax]);g.isRTL=(MathJax.Localization.fontDirection()==="rtl")}var v=n.Element("div",{onmouseup:g.Mouseup,ondblclick:m,ondragstart:m,onselectstart:m,oncontextmenu:m,menuItem:this,className:"MathJax_Menu",onkeydown:g.Keydown,role:"menu"});if(u.type==="contextmenu"||u.type==="mouseover"){v.className+=" MathJax_ContextMenu"}if(!G){MathJax.Localization.setCSS(v)}for(var B=0,z=this.items.length;B<z;B++){this.items[B].Create(v)}if(g.isMobile){n.addElement(v,"span",{className:"MathJax_MenuClose",menu:I,ontouchstart:g.Close,ontouchend:m,onmousedown:g.Close,onmouseup:m},[["span",{},"\u00D7"]])}t.appendChild(v);this.posted=true;if(v.offsetWidth){v.style.width=(v.offsetWidth+2)+"px"}var H=u.pageX,F=u.pageY;if(!H&&!F&&"clientX" in u){H=u.clientX+document.body.scrollLeft+document.documentElement.scrollLeft;F=u.clientY+document.body.scrollTop+document.documentElement.scrollTop}if(!I){var w=g.CurrentNode()||u.target;if((u.type==="keydown"||(!H&&!F))&&w){var C=window.pageXOffset||document.documentElement.scrollLeft;var A=window.pageYOffset||document.documentElement.scrollTop;var E=w.getBoundingClientRect();H=(E.right+E.left)/2+C;F=(E.bottom+E.top)/2+A}if(H+v.offsetWidth>document.body.offsetWidth-this.margin){H=document.body.offsetWidth-v.offsetWidth-this.margin}if(g.isMobile){H=Math.max(5,H-Math.floor(v.offsetWidth/2));F-=20}g.skipUp=u.isContextMenu}else{var D="left",L=I.offsetWidth;H=(g.isMobile?30:L-2);F=0;while(I&&I!==t){H+=I.offsetLeft;F+=I.offsetTop;I=I.parentNode}if(!g.isMobile){if((g.isRTL&&H-L-v.offsetWidth>this.margin)||(!g.isRTL&&H+v.offsetWidth>document.body.offsetWidth-this.margin)){D="right";H=Math.max(this.margin,H-L-v.offsetWidth+6)}}if(!a){v.style["borderRadiusTop"+D]=0;v.style["WebkitBorderRadiusTop"+D]=0;v.style["MozBorderRadiusTop"+D]=0;v.style["KhtmlBorderRadiusTop"+D]=0}}v.style.left=H+"px";v.style.top=F+"px";if(document.selection&&document.selection.empty){document.selection.empty()}var K=window.pageXOffset||document.documentElement.scrollLeft;var J=window.pageYOffset||document.documentElement.scrollTop;g.Focus(v);if(u.type==="keydown"){g.skipMouseoverFromKey=true;setTimeout(function(){delete g.skipMouseoverFromKey},r.delay)}window.scrollTo(K,J);return m(u)},Remove:function(t,u){d.Post(["unpost",g.jax]);var v=document.getElementById("MathJax_MenuFrame");if(v){v.parentNode.removeChild(v);if(this.msieFixedPositionBug){detachEvent("onresize",g.Resize)}}if(g.jax.hover){delete g.jax.hover.nofade;j.UnHover(g.jax)}g.Unfocus(u);if(t.type==="mousedown"){g.CurrentNode().blur()}return m(t)},Find:function(t){return this.FindN(1,t,[].slice.call(arguments,1))},FindId:function(t){return this.FindN(0,t,[].slice.call(arguments,1))},FindN:function(x,u,w){for(var v=0,t=this.items.length;v<t;v++){if(this.items[v].name[x]===u){if(w.length){if(!this.items[v].submenu){return null}return this.items[v].submenu.FindN(x,w[0],w.slice(1))}return this.items[v]}}return null},IndexOf:function(t){return this.IndexOfN(1,t)},IndexOfId:function(t){return this.IndexOfN(0,t)},IndexOfN:function(w,u){for(var v=0,t=this.items.length;v<t;v++){if(this.items[v].name[w]===u){return v}}return null},Right:function(t,u){g.Right(t,u)},Left:function(t,u){g.Left(t,u)},Up:function(u,v){var t=v.lastChild;t.menuItem.Activate(u,t)},Down:function(u,v){var t=v.firstChild;t.menuItem.Activate(u,t)},Space:function(t,u){this.Remove(t,u)}},{config:r,Remove:function(t){return g.Event(t,this,"Remove")},Mouseover:function(t){return g.Event(t,this,"Mouseover")},Mouseout:function(t){return g.Event(t,this,"Mouseout")},Mousedown:function(t){return g.Event(t,this,"Mousedown")},Mouseup:function(t){return g.Event(t,this,"Mouseup")},Keydown:function(t){return g.Event(t,this,"Keydown")},Touchstart:function(t){return g.Event(t,this,"Touchstart")},Touchend:function(t){return g.Event(t,this,"Touchend")},Close:function(t){return g.Event(t,this.menu||this.parentNode,(this.menu?"Touchend":"Remove"))},Event:function(v,x,t,w){if(g.skipMouseover&&t==="Mouseover"&&!w){return m(v)}if(g.skipMouseoverFromKey&&t==="Mouseover"){delete g.skipMouseoverFromKey;return m(v)}if(g.skipUp){if(t.match(/Mouseup|Touchend/)){delete g.skipUp;return m(v)}if(t==="Touchstart"||(t==="Mousedown"&&!g.skipMousedown)){delete g.skipUp}}if(!v){v=window.event}var u=x.menuItem;if(u&&u[t]){return u[t](v,x)}return null},BGSTYLE:{position:"absolute",left:0,top:0,"z-index":200,width:"100%",height:"100%",border:0,padding:0,margin:0},Background:function(u){var v=n.addElement(document.body,"div",{style:this.BGSTYLE,id:"MathJax_MenuFrame"},[["div",{style:this.BGSTYLE,menuItem:u,onmousedown:this.Remove}]]);var t=v.firstChild;if(g.msieBackgroundBug){t.style.backgroundColor="white";t.style.filter="alpha(opacity=0)"}if(g.msieFixedPositionBug){v.width=v.height=0;this.Resize();attachEvent("onresize",this.Resize)}else{t.style.position="fixed"}return v},Resize:function(){setTimeout(g.SetWH,0)},SetWH:function(){var t=document.getElementById("MathJax_MenuFrame");if(t){t=t.firstChild;t.style.width=t.style.height="1px";t.style.width=document.body.scrollWidth+"px";t.style.height=document.body.scrollHeight+"px"}},posted:false,active:null,GetNode:function(t){var u=document.getElementById(t.inputID+"-Frame");return u.isMathJax?u:u.firstChild},CurrentNode:function(){return g.GetNode(g.jax)},AllNodes:function(){var u=MathJax.Hub.getAllJax();var v=[];for(var w=0,t;t=u[w];w++){v.push(g.GetNode(t))}return v},ActiveNode:function(){return g.active},FocusNode:function(t){g.active=t;t.focus()},Focus:function(t){!g.posted?g.Activate(t):g.ActiveNode().tabIndex=-1;t.tabIndex=0;g.FocusNode(t)},Activate:function(t,u){g.UnsetTabIndex();g.posted=true},Unfocus:function(){g.ActiveNode().tabIndex=-1;g.SetTabIndex();g.FocusNode(g.CurrentNode());g.posted=false},MoveHorizontal:function(x,y,v){if(!x.shiftKey){return}var u=g.AllNodes();var t=u.length;if(t===0){return}var w=u[g.Mod(v(g.IndexOf(u,g.CurrentNode())),t)];if(w===g.CurrentNode()){return}g.menu.Remove(x,y);g.jax=MathJax.Hub.getJaxFor(w);g.FocusNode(w);g.menu.Post(null)},Right:function(t,u){g.MoveHorizontal(t,u,function(v){return v+1})},Left:function(t,u){g.MoveHorizontal(t,u,function(v){return v-1})},UnsetTabIndex:function(){var u=g.AllNodes();for(var v=0,t;t=u[v];v++){if(t.tabIndex>0){t.oldTabIndex=t.tabIndex}t.tabIndex=-1}},SetTabIndex:function(){var u=g.AllNodes();for(var v=0,t;t=u[v];v++){if(t.oldTabIndex!==undefined){t.tabIndex=t.oldTabIndex;delete t.oldTabIndex}else{t.tabIndex=f.getTabOrder(t)}}},Mod:function(t,u){return((t%u)+u)%u},IndexOf:(Array.prototype.indexOf?function(t,u,v){return t.indexOf(u,v)}:function(t,w,x){for(var v=(x||0),u=t.length;v<u;v++){if(w===t[v]){return v}}return -1}),saveCookie:function(){n.Cookie.Set("menu",this.cookie)},getCookie:function(){this.cookie=n.Cookie.Get("menu")}});MathJax.Menu.NAV=h;var c=g.ITEM=h.Subclass({name:"",node:null,menu:null,Attributes:function(t){return f.Insert({onmouseup:g.Mouseup,ondragstart:m,onselectstart:m,onselectend:m,ontouchstart:g.Touchstart,ontouchend:g.Touchend,className:"MathJax_MenuItem",role:this.role,menuItem:this},t)},Create:function(v){if(!this.hidden){var u=this.Attributes();var t=this.Label(u,v);n.addElement(v,"div",u,t)}},Name:function(){return s(this.name[0],this.name[1])},Mouseover:function(t,u){if(u.parentNode===g.ActiveNode().parentNode){this.Deactivate(g.ActiveNode())}this.Activate(t,u)},Mouseout:function(t,u){this.Deactivate(u)},Mouseup:function(t,u){return this.Remove(t,u)},DeactivateSubmenus:function(y){var x=document.getElementById("MathJax_MenuFrame").childNodes,u=c.GetMenuNode(y).childNodes;for(var v=0,t=u.length;v<t;v++){var w=u[v].menuItem;if(w&&w.submenu&&w.submenu.posted&&w!==y.menuItem){w.Deactivate(u[v])}}this.RemoveSubmenus(y,x)},RemoveSubmenus:function(v,u){u=u||document.getElementById("MathJax_MenuFrame").childNodes;var t=u.length-1;while(t>=0&&c.GetMenuNode(v).menuItem!==u[t].menuItem){u[t].menuItem.posted=false;u[t].parentNode.removeChild(u[t]);t--}},Touchstart:function(t,u){return this.TouchEvent(t,u,"Mousedown")},Touchend:function(t,u){return this.TouchEvent(t,u,"Mouseup")},TouchEvent:function(u,v,t){if(this!==c.lastItem){if(c.lastMenu){g.Event(u,c.lastMenu,"Mouseout")}g.Event(u,v,"Mouseover",true);c.lastItem=this;c.lastMenu=v}if(this.nativeTouch){return null}g.Event(u,v,t);return false},Remove:function(t,u){u=u.parentNode.menuItem;return u.Remove(t,u)},With:function(t){if(t){f.Insert(this,t)}return this},isRTL:function(){return g.isRTL},rtlClass:function(){return(this.isRTL()?" RTL":"")}},{GetMenuNode:function(t){return t.parentNode}});g.ENTRY=g.ITEM.Subclass({role:"menuitem",Attributes:function(t){t=f.Insert({onmouseover:g.Mouseover,onmouseout:g.Mouseout,onmousedown:g.Mousedown,onkeydown:g.Keydown,"aria-disabled":!!this.disabled},t);t=this.SUPER(arguments).Attributes.call(this,t);if(this.disabled){t.className+=" MathJax_MenuDisabled"}return t},MoveVertical:function(t,D,v){var w=c.GetMenuNode(D);var C=[];for(var y=0,B=w.menuItem.items,x;x=B[y];y++){if(!x.hidden){C.push(x)}}var A=g.IndexOf(C,this);if(A===-1){return}var z=C.length;var u=w.childNodes;do{A=g.Mod(v(A),z)}while(C[A].hidden||!u[A].role||u[A].role==="separator");this.Deactivate(D);C[A].Activate(t,u[A])},Up:function(u,t){this.MoveVertical(u,t,function(v){return v-1})},Down:function(u,t){this.MoveVertical(u,t,function(v){return v+1})},Right:function(u,t){this.MoveHorizontal(u,t,g.Right,!this.isRTL())},Left:function(u,t){this.MoveHorizontal(u,t,g.Left,this.isRTL())},MoveHorizontal:function(z,y,t,A){var w=c.GetMenuNode(y);if(w.menuItem===g.menu&&z.shiftKey){t(z,y)}if(A){return}if(w.menuItem!==g.menu){this.Deactivate(y)}var u=w.previousSibling.childNodes;var x=u.length;while(x--){var v=u[x];if(v.menuItem.submenu&&v.menuItem.submenu===w.menuItem){g.Focus(v);break}}this.RemoveSubmenus(y)},Space:function(t,u){this.Mouseup(t,u)},Activate:function(t,u){this.Deactivate(u);if(!this.disabled){u.className+=" MathJax_MenuActive"}this.DeactivateSubmenus(u);g.Focus(u)},Deactivate:function(t){t.className=t.className.replace(/ MathJax_MenuActive/,"")}});g.ITEM.COMMAND=g.ENTRY.Subclass({action:function(){},Init:function(t,v,u){if(!(t instanceof Array)){t=[t,t]}this.name=t;this.action=v;this.With(u)},Label:function(t,u){return[this.Name()]},Mouseup:function(t,u){if(!this.disabled){this.Remove(t,u);d.Post(["command",this]);this.action.call(this,t)}return m(t)}});g.ITEM.SUBMENU=g.ENTRY.Subclass({submenu:null,marker:"\u25BA",markerRTL:"\u25C4",Attributes:function(t){t=f.Insert({"aria-haspopup":"true"},t);t=this.SUPER(arguments).Attributes.call(this,t);return t},Init:function(t,v){if(!(t instanceof Array)){t=[t,t]}this.name=t;var u=1;if(!(v instanceof g.ITEM)){this.With(v),u++}this.submenu=g.apply(g,[].slice.call(arguments,u))},Label:function(t,u){this.submenu.posted=false;return[this.Name()+" ",["span",{className:"MathJax_MenuArrow"+this.rtlClass()},[this.isRTL()?this.markerRTL:this.marker]]]},Timer:function(t,u){this.ClearTimer();t={type:t.type,clientX:t.clientX,clientY:t.clientY};this.timer=setTimeout(e(["Mouseup",this,t,u]),r.delay)},ClearTimer:function(){if(this.timer){clearTimeout(this.timer)}},Touchend:function(u,w){var v=this.submenu.posted;var t=this.SUPER(arguments).Touchend.apply(this,arguments);if(v){this.Deactivate(w);delete c.lastItem;delete c.lastMenu}return t},Mouseout:function(t,u){if(!this.submenu.posted){this.Deactivate(u)}this.ClearTimer()},Mouseover:function(t,u){this.Activate(t,u)},Mouseup:function(t,u){if(!this.disabled){if(!this.submenu.posted){this.ClearTimer();this.submenu.Post(t,u,this.ltr);g.Focus(u)}else{this.DeactivateSubmenus(u)}}return m(t)},Activate:function(t,u){if(!this.disabled){this.Deactivate(u);u.className+=" MathJax_MenuActive"}if(!this.submenu.posted){this.DeactivateSubmenus(u);if(!g.isMobile){this.Timer(t,u)}}g.Focus(u)},MoveVertical:function(v,u,t){this.ClearTimer();this.SUPER(arguments).MoveVertical.apply(this,arguments)},MoveHorizontal:function(v,x,u,w){if(!w){this.SUPER(arguments).MoveHorizontal.apply(this,arguments);return}if(this.disabled){return}if(!this.submenu.posted){this.Activate(v,x);return}var t=c.GetMenuNode(x).nextSibling.childNodes;if(t.length>0){this.submenu.items[0].Activate(v,t[0])}}});g.ITEM.RADIO=g.ENTRY.Subclass({variable:null,marker:(a?"\u25CF":"\u2713"),role:"menuitemradio",Attributes:function(u){var t=r.settings[this.variable]===this.value?"true":"false";u=f.Insert({"aria-checked":t},u);u=this.SUPER(arguments).Attributes.call(this,u);return u},Init:function(u,t,v){if(!(u instanceof Array)){u=[u,u]}this.name=u;this.variable=t;this.With(v);if(this.value==null){this.value=this.name[0]}},Label:function(u,v){var t={className:"MathJax_MenuRadioCheck"+this.rtlClass()};if(r.settings[this.variable]!==this.value){t={style:{display:"none"}}}return[["span",t,[this.marker]]," "+this.Name()]},Mouseup:function(w,x){if(!this.disabled){var y=x.parentNode.childNodes;for(var u=0,t=y.length;u<t;u++){var v=y[u].menuItem;if(v&&v.variable===this.variable){y[u].firstChild.style.display="none"}}x.firstChild.display="";r.settings[this.variable]=this.value;g.cookie[this.variable]=r.settings[this.variable];g.saveCookie();d.Post(["radio button",this])}this.Remove(w,x);if(this.action&&!this.disabled){this.action.call(g,this)}return m(w)}});g.ITEM.CHECKBOX=g.ENTRY.Subclass({variable:null,marker:"\u2713",role:"menuitemcheckbox",Attributes:function(u){var t=r.settings[this.variable]?"true":"false";u=f.Insert({"aria-checked":t},u);u=this.SUPER(arguments).Attributes.call(this,u);return u},Init:function(u,t,v){if(!(u instanceof Array)){u=[u,u]}this.name=u;this.variable=t;this.With(v)},Label:function(u,v){var t={className:"MathJax_MenuCheck"+this.rtlClass()};if(!r.settings[this.variable]){t={style:{display:"none"}}}return[["span",t,[this.marker]]," "+this.Name()]},Mouseup:function(t,u){if(!this.disabled){u.firstChild.display=(r.settings[this.variable]?"none":"");r.settings[this.variable]=!r.settings[this.variable];g.cookie[this.variable]=r.settings[this.variable];g.saveCookie();d.Post(["checkbox",this])}this.Remove(t,u);if(this.action&&!this.disabled){this.action.call(g,this)}return m(t)}});g.ITEM.LABEL=g.ENTRY.Subclass({role:"menuitem",Init:function(t,u){if(!(t instanceof Array)){t=[t,t]}this.name=t;this.With(u)},Label:function(t,u){t.className+=" MathJax_MenuLabel";return[this.Name()]},Activate:function(t,u){this.Deactivate(u);g.Focus(u)},Mouseup:function(t,u){}});g.ITEM.RULE=g.ITEM.Subclass({role:"separator",Attributes:function(t){t=f.Insert({"aria-orientation":"vertical"},t);t=this.SUPER(arguments).Attributes.call(this,t);return t},Label:function(t,u){t.className+=" MathJax_MenuRule";return null}});g.About=function(x){var u=g.About.GetFont();var z=g.About.GetFormat();var t=["MathJax.js v"+MathJax.fileversion,["br"]];t.push(["div",{style:{"border-top":"groove 2px",margin:".25em 0"}}]);g.About.GetJax(t,MathJax.InputJax,["InputJax","%1 Input Jax v%2"]);g.About.GetJax(t,MathJax.OutputJax,["OutputJax","%1 Output Jax v%2"]);g.About.GetJax(t,MathJax.ElementJax,["ElementJax","%1 Element Jax v%2"]);t.push(["div",{style:{"border-top":"groove 2px",margin:".25em 0"}}]);g.About.GetJax(t,MathJax.Extension,["Extension","%1 Extension v%2"],true);t.push(["div",{style:{"border-top":"groove 2px",margin:".25em 0"}}],["center",{},[f.Browser+" v"+f.Browser.version+(z?" \u2014 "+s(z.replace(/ /g,""),z):"")]]);g.About.div=g.Background(g.About);var w=n.addElement(g.About.div,"div",{id:"MathJax_About",tabIndex:0,onkeydown:g.About.Keydown},[["b",{style:{fontSize:"120%"}},["MathJax"]]," v"+MathJax.version,["br"],s(u.replace(/ /g,""),"using "+u),["br"],["br"],["span",{style:{display:"inline-block","text-align":"left","font-size":"80%","max-height":"20em",overflow:"auto","background-color":"#E4E4E4",padding:".4em .6em",border:"1px inset"},tabIndex:0},t],["br"],["br"],["a",{href:"http://www.mathjax.org/"},["www.mathjax.org"]],["span",{className:"MathJax_MenuClose",id:"MathJax_AboutClose",onclick:g.About.Remove,onkeydown:g.About.Keydown,tabIndex:0,role:"button","aria-label":s("CloseAboutDialog","Close about MathJax dialog")},[["span",{},"\u00D7"]]]]);if(x.type==="mouseup"){w.className+=" MathJax_MousePost"}w.focus();MathJax.Localization.setCSS(w);var y=(document.documentElement||{});var v=window.innerHeight||y.clientHeight||y.scrollHeight||0;if(g.prototype.msieAboutBug){w.style.width="20em";w.style.position="absolute";w.style.left=Math.floor((document.documentElement.scrollWidth-w.offsetWidth)/2)+"px";w.style.top=(Math.floor((v-w.offsetHeight)/3)+document.body.scrollTop)+"px"}else{w.style.marginLeft=Math.floor(-w.offsetWidth/2)+"px";w.style.top=Math.floor((v-w.offsetHeight)/3)+"px"}};g.About.Remove=function(t){if(g.About.div){document.body.removeChild(g.About.div);delete g.About.div}};g.About.Keydown=function(t){if(t.keyCode===b.ESCAPE||(this.id==="MathJax_AboutClose"&&(t.keyCode===b.SPACE||t.keyCode===b.RETURN))){g.About.Remove(t);g.CurrentNode().focus();m(t)}},g.About.GetJax=function(u,z,x,w){var y=[];for(var A in z){if(z.hasOwnProperty(A)&&z[A]){if((w&&z[A].version)||(z[A].isa&&z[A].isa(z))){y.push(s(x[0],x[1],(z[A].id||A),z[A].version))}}}y.sort();for(var v=0,t=y.length;v<t;v++){u.push(y[v],["br"])}return u};g.About.GetFont=function(){var t=MathJax.Hub.outputJax["jax/mml"][0]||{};var u={SVG:"web SVG",CommonHTML:"web TeX","HTML-CSS":(t.imgFonts?"image":(t.webFonts?"web":"local")+" "+t.fontInUse)}[t.id]||"generic";return u+" fonts"};g.About.GetFormat=function(){var t=MathJax.Hub.outputJax["jax/mml"][0]||{};if(t.id!=="HTML-CSS"||!t.webFonts||t.imgFonts){return}return t.allowWebFonts.replace(/otf/,"woff or otf")+" fonts"};g.Help=function(t){p.Require("[MathJax]/extensions/HelpDialog.js",function(){MathJax.Extension.Help.Dialog({type:t.type})})};g.ShowSource=function(x){if(!x){x=window.event}var w={screenX:x.screenX,screenY:x.screenY};if(!g.jax){return}if(this.format==="MathML"){var u=MathJax.ElementJax.mml;if(u&&typeof(u.mbase.prototype.toMathML)!=="undefined"){try{g.ShowSource.Text(g.jax.root.toMathML("",g.jax),x)}catch(v){if(!v.restart){throw v}e.After([this,g.ShowSource,w],v.restart)}}else{if(!p.loadingToMathML){p.loadingToMathML=true;g.ShowSource.Window(x);e.Queue(p.Require("[MathJax]/extensions/toMathML.js"),function(){delete p.loadingToMathML;if(!u.mbase.prototype.toMathML){u.mbase.prototype.toMathML=function(){}}},[this,g.ShowSource,w]);return}}}else{if(this.format==="Error"){g.ShowSource.Text(g.jax.errorText,x)}else{if(r.semanticsAnnotations[this.format]){var t=g.jax.root.getAnnotation(this.format);if(t.data[0]){g.ShowSource.Text(t.data[0].toString())}}else{if(g.jax.originalText==null){alert(s("NoOriginalForm","No original form available"));return}g.ShowSource.Text(g.jax.originalText,x)}}}};g.ShowSource.Window=function(u){if(!g.ShowSource.w){var v=[],t=r.windowSettings;for(var w in t){if(t.hasOwnProperty(w)){v.push(w+"="+t[w])}}g.ShowSource.w=window.open("","_blank",v.join(","))}return g.ShowSource.w};g.ShowSource.Text=function(y,v){var t=g.ShowSource.Window(v);delete g.ShowSource.w;y=y.replace(/^\s*/,"").replace(/\s*$/,"");y=y.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");var x=s("EqSource","MathJax Equation Source");if(g.isMobile){t.document.open();t.document.write("<html><head><meta name='viewport' content='width=device-width, initial-scale=1.0' /><title>"+x+"</title></head><body style='font-size:85%'>");t.document.write("<pre>"+y+"</pre>");t.document.write("<hr><input type='button' value='"+s("Close","Close")+"' onclick='window.close()' />");t.document.write("</body></html>");t.document.close()}else{t.document.open();t.document.write("<html><head><title>"+x+"</title></head><body style='font-size:85%'>");t.document.write("<table><tr><td><pre>"+y+"</pre></td></tr></table>");t.document.write("</body></html>");t.document.close();var u=t.document.body.firstChild;setTimeout(function(){var A=(t.outerHeight-t.innerHeight)||30,z=(t.outerWidth-t.innerWidth)||30,w,D;z=Math.max(140,Math.min(Math.floor(0.5*screen.width),u.offsetWidth+z+25));A=Math.max(40,Math.min(Math.floor(0.5*screen.height),u.offsetHeight+A+25));if(g.prototype.msieHeightBug){A+=35}t.resizeTo(z,A);var C;try{C=v.screenX}catch(B){}if(v&&C!=null){w=Math.max(0,Math.min(v.screenX-Math.floor(z/2),screen.width-z-20));D=Math.max(0,Math.min(v.screenY-Math.floor(A/2),screen.height-A-20));t.moveTo(w,D)}},50)}};g.Scale=function(){var y=["CommonHTML","HTML-CSS","SVG","NativeMML","PreviewHTML"],t=y.length,x=100,v,u;for(v=0;v<t;v++){u=q[y[v]];if(u){x=u.config.scale;break}}var w=prompt(s("ScaleMath","Scale all mathematics (compared to surrounding text) by"),x+"%");if(w){if(w.match(/^\s*\d+(\.\d*)?\s*%?\s*$/)){w=parseFloat(w);if(w){if(w!==x){for(v=0;v<t;v++){u=q[y[v]];if(u){u.config.scale=w}}g.cookie.scale=f.config.scale=w;g.saveCookie();f.Queue(["Rerender",f])}}else{alert(s("NonZeroScale","The scale should not be zero"))}}else{alert(s("PercentScale","The scale should be a percentage (e.g., 120%%)"))}}};g.Zoom=function(){if(!MathJax.Extension.MathZoom){p.Require("[MathJax]/extensions/MathZoom.js")}};g.Renderer=function(){var u=f.outputJax["jax/mml"];if(u[0]!==r.settings.renderer){var x=f.Browser,w,t=g.Renderer.Messages,v;switch(r.settings.renderer){case"NativeMML":if(!r.settings.warnedMML){if(x.isChrome&&x.version.substr(0,3)!=="24."){w=t.MML.WebKit}else{if(x.isSafari&&!x.versionAtLeast("5.0")){w=t.MML.WebKit}else{if(x.isMSIE){if(!x.hasMathPlayer){w=t.MML.MSIE}}else{if(x.isEdge){w=t.MML.WebKit}else{w=t.MML[x]}}}}v="warnedMML"}break;case"SVG":if(!r.settings.warnedSVG){if(x.isMSIE&&!l){w=t.SVG.MSIE}}break}if(w){w=s(w[0],w[1]);w+="\n\n";w+=s("SwitchAnyway","Switch the renderer anyway?\n\n(Press OK to switch, CANCEL to continue with the current renderer)");g.cookie.renderer=u[0].id;g.saveCookie();if(!confirm(w)){g.cookie.renderer=r.settings.renderer=n.Cookie.Get("menu").renderer;g.saveCookie();return}if(v){g.cookie.warned=r.settings.warned=true}g.cookie.renderer=r.settings.renderer;g.saveCookie()}f.Queue(["setRenderer",f,r.settings.renderer,"jax/mml"],["Rerender",f])}};g.Renderer.Messages={MML:{WebKit:["WebkitNativeMMLWarning","Your browser doesn't seem to support MathML natively, so switching to MathML output may cause the mathematics on the page to become unreadable."],MSIE:["MSIENativeMMLWarning","Internet Explorer requires the MathPlayer plugin in order to process MathML output."],Opera:["OperaNativeMMLWarning","Opera's support for MathML is limited, so switching to MathML output may cause some expressions to render poorly."],Safari:["SafariNativeMMLWarning","Your browser's native MathML does not implement all the features used by MathJax, so some expressions may not render properly."],Firefox:["FirefoxNativeMMLWarning","Your browser's native MathML does not implement all the features used by MathJax, so some expressions may not render properly."]},SVG:{MSIE:["MSIESVGWarning","SVG is not implemented in Internet Explorer prior to IE9 or when it is emulating IE8 or below. Switching to SVG output will cause the mathematics to not display properly."]}};g.AssistiveMML=function(v,t){var u=MathJax.Extension.AssistiveMML;if(!u){if(!t){p.Require("[MathJax]/extensions/AssistiveMML.js",["AssistiveMML",g,v,true])}return}MathJax.Hub.Queue([(r.settings.assistiveMML?"Add":"Remove")+"AssistiveMathML",u])};g.Font=function(){var t=q["HTML-CSS"];if(!t){return}document.location.reload()};g.Locale=function(){MathJax.Localization.setLocale(r.settings.locale);MathJax.Hub.Queue(["Reprocess",MathJax.Hub])};g.LoadLocale=function(){var t=prompt(s("LoadURL","Load translation data from this URL:"));if(t){if(!t.match(/\.js$/)){alert(s("BadURL","The URL should be for a javascript file that defines MathJax translation data.  Javascript file names should end with '.js'"))}p.Require(t,function(u){if(u!=p.STATUS.OK){alert(s("BadData","Failed to load translation data from %1",t))}})}};g.MPEvents=function(v){var u=r.settings.discoverable,t=g.MPEvents.Messages;if(!l){if(r.settings.mpMouse&&!confirm(s.apply(s,t.IE8warning))){delete g.cookie.mpContext;delete r.settings.mpContext;delete g.cookie.mpMouse;delete r.settings.mpMouse;g.saveCookie();return}r.settings.mpContext=r.settings.mpMouse;g.cookie.mpContext=g.cookie.mpMouse=r.settings.mpMouse;g.saveCookie();MathJax.Hub.Queue(["Rerender",MathJax.Hub])}else{if(!u&&v.name[1]==="Menu Events"&&r.settings.mpContext){alert(s.apply(s,t.IE9warning))}}};g.MPEvents.Messages={IE8warning:["IE8warning","This will disable the MathJax menu and zoom features, but you can Alt-Click on an expression to obtain the MathJax menu instead.\n\nReally change the MathPlayer settings?"],IE9warning:["IE9warning","The MathJax contextual menu will be disabled, but you can Alt-Click on an expression to obtain the MathJax menu instead."]};f.Browser.Select({MSIE:function(t){var u=(document.compatMode==="BackCompat");var v=t.versionAtLeast("8.0")&&document.documentMode>7;g.Augment({margin:20,msieBackgroundBug:((document.documentMode||0)<9),msieFixedPositionBug:(u||!v),msieAboutBug:u,msieHeightBug:((document.documentMode||0)<9)});if(l){delete r.styles["#MathJax_About"].filter;delete r.styles[".MathJax_Menu"].filter}},Firefox:function(t){g.skipMouseover=t.isMobile&&t.versionAtLeast("6.0");g.skipMousedown=t.isMobile}});g.isMobile=f.Browser.isMobile;g.noContextMenu=f.Browser.noContextMenu;g.CreateLocaleMenu=function(){if(!g.menu){return}var y=g.menu.Find("Language").submenu,v=y.items;var u=[],A=MathJax.Localization.strings;for(var z in A){if(A.hasOwnProperty(z)){u.push(z)}}u=u.sort();y.items=[];for(var w=0,t=u.length;w<t;w++){var x=A[u[w]].menuTitle;if(x){x+=" ("+u[w]+")"}else{x=u[w]}y.items.push(c.RADIO([u[w],x],"locale",{action:g.Locale}))}y.items.push(v[v.length-2],v[v.length-1])};g.CreateAnnotationMenu=function(){if(!g.menu){return}var v=g.menu.Find("Show Math As","Annotation").submenu;var u=r.semanticsAnnotations;for(var t in u){if(u.hasOwnProperty(t)){v.items.push(c.COMMAND([t,t],g.ShowSource,{hidden:true,nativeTouch:true,format:t}))}}};f.Register.StartupHook("End Config",function(){r.settings=f.config.menuSettings;if(typeof(r.settings.showRenderer)!=="undefined"){r.showRenderer=r.settings.showRenderer}if(typeof(r.settings.showFontMenu)!=="undefined"){r.showFontMenu=r.settings.showFontMenu}if(typeof(r.settings.showContext)!=="undefined"){r.showContext=r.settings.showContext}g.getCookie();g.menu=g(c.SUBMENU(["Show","Show Math As"],c.COMMAND(["MathMLcode","MathML Code"],g.ShowSource,{nativeTouch:true,format:"MathML"}),c.COMMAND(["Original","Original Form"],g.ShowSource,{nativeTouch:true}),c.SUBMENU(["Annotation","Annotation"],{disabled:true}),c.RULE(),c.CHECKBOX(["texHints","Show TeX hints in MathML"],"texHints"),c.CHECKBOX(["semantics","Add original form as annotation"],"semantics")),c.RULE(),c.SUBMENU(["Settings","Math Settings"],c.SUBMENU(["ZoomTrigger","Zoom Trigger"],c.RADIO(["Hover","Hover"],"zoom",{action:g.Zoom}),c.RADIO(["Click","Click"],"zoom",{action:g.Zoom}),c.RADIO(["DoubleClick","Double-Click"],"zoom",{action:g.Zoom}),c.RADIO(["NoZoom","No Zoom"],"zoom",{value:"None"}),c.RULE(),c.LABEL(["TriggerRequires","Trigger Requires:"]),c.CHECKBOX((f.Browser.isMac?["Option","Option"]:["Alt","Alt"]),"ALT"),c.CHECKBOX(["Command","Command"],"CMD",{hidden:!f.Browser.isMac}),c.CHECKBOX(["Control","Control"],"CTRL",{hidden:f.Browser.isMac}),c.CHECKBOX(["Shift","Shift"],"Shift")),c.SUBMENU(["ZoomFactor","Zoom Factor"],c.RADIO("125%","zscale"),c.RADIO("133%","zscale"),c.RADIO("150%","zscale"),c.RADIO("175%","zscale"),c.RADIO("200%","zscale"),c.RADIO("250%","zscale"),c.RADIO("300%","zscale"),c.RADIO("400%","zscale")),c.RULE(),c.SUBMENU(["Renderer","Math Renderer"],{hidden:!r.showRenderer},c.RADIO(["HTML-CSS","HTML-CSS"],"renderer",{action:g.Renderer}),c.RADIO(["CommonHTML","Common HTML"],"renderer",{action:g.Renderer,value:"CommonHTML"}),c.RADIO(["PreviewHTML","Preview HTML"],"renderer",{action:g.Renderer,value:"PreviewHTML"}),c.RADIO(["MathML","MathML"],"renderer",{action:g.Renderer,value:"NativeMML"}),c.RADIO(["SVG","SVG"],"renderer",{action:g.Renderer}),c.RADIO(["PlainSource","Plain Source"],"renderer",{action:g.Renderer,value:"PlainSource"}),c.RULE(),c.CHECKBOX(["FastPreview","Fast Preview"],"FastPreview"),c.CHECKBOX(["AssistiveMML","Assistive MathML"],"assistiveMML",{action:g.AssistiveMML}),c.CHECKBOX(["InTabOrder","Include in Tab Order"],"inTabOrder")),c.SUBMENU("MathPlayer",{hidden:!f.Browser.isMSIE||!r.showMathPlayer,disabled:!f.Browser.hasMathPlayer},c.LABEL(["MPHandles","Let MathPlayer Handle:"]),c.CHECKBOX(["MenuEvents","Menu Events"],"mpContext",{action:g.MPEvents,hidden:!l}),c.CHECKBOX(["MouseEvents","Mouse Events"],"mpMouse",{action:g.MPEvents,hidden:!l}),c.CHECKBOX(["MenuAndMouse","Mouse and Menu Events"],"mpMouse",{action:g.MPEvents,hidden:l})),c.SUBMENU(["FontPrefs","Font Preference"],{hidden:!r.showFontMenu},c.LABEL(["ForHTMLCSS","For HTML-CSS:"]),c.RADIO(["Auto","Auto"],"font",{action:g.Font}),c.RULE(),c.RADIO(["TeXLocal","TeX (local)"],"font",{action:g.Font}),c.RADIO(["TeXWeb","TeX (web)"],"font",{action:g.Font}),c.RADIO(["TeXImage","TeX (image)"],"font",{action:g.Font}),c.RULE(),c.RADIO(["STIXLocal","STIX (local)"],"font",{action:g.Font}),c.RADIO(["STIXWeb","STIX (web)"],"font",{action:g.Font}),c.RULE(),c.RADIO(["AsanaMathWeb","Asana Math (web)"],"font",{action:g.Font}),c.RADIO(["GyrePagellaWeb","Gyre Pagella (web)"],"font",{action:g.Font}),c.RADIO(["GyreTermesWeb","Gyre Termes (web)"],"font",{action:g.Font}),c.RADIO(["LatinModernWeb","Latin Modern (web)"],"font",{action:g.Font}),c.RADIO(["NeoEulerWeb","Neo Euler (web)"],"font",{action:g.Font})),c.SUBMENU(["ContextMenu","Contextual Menu"],{hidden:!r.showContext},c.RADIO(["MathJax","MathJax"],"context"),c.RADIO(["Browser","Browser"],"context")),c.COMMAND(["Scale","Scale All Math ..."],g.Scale),c.RULE().With({hidden:!r.showDiscoverable,name:["","discover_rule"]}),c.CHECKBOX(["Discoverable","Highlight on Hover"],"discoverable",{hidden:!r.showDiscoverable})),c.SUBMENU(["Locale","Language"],{hidden:!r.showLocale,ltr:true},c.RADIO("en","locale",{action:g.Locale}),c.RULE().With({hidden:!r.showLocaleURL,name:["","localURL_rule"]}),c.COMMAND(["LoadLocale","Load from URL ..."],g.LoadLocale,{hidden:!r.showLocaleURL})),c.RULE(),c.COMMAND(["About","About MathJax"],g.About),c.COMMAND(["Help","MathJax Help"],g.Help));if(g.isMobile){(function(){var u=r.settings;var t=g.menu.Find("Math Settings","Zoom Trigger").submenu;t.items[0].disabled=t.items[1].disabled=true;if(u.zoom==="Hover"||u.zoom=="Click"){u.zoom="None"}t.items=t.items.slice(0,4);if(navigator.appVersion.match(/[ (]Android[) ]/)){g.ITEM.SUBMENU.Augment({marker:"\u00BB"})}})()}g.CreateLocaleMenu();g.CreateAnnotationMenu()});g.showRenderer=function(t){g.cookie.showRenderer=r.showRenderer=t;g.saveCookie();g.menu.Find("Math Settings","Math Renderer").hidden=!t};g.showMathPlayer=function(t){g.cookie.showMathPlayer=r.showMathPlayer=t;g.saveCookie();g.menu.Find("Math Settings","MathPlayer").hidden=!t};g.showFontMenu=function(t){g.cookie.showFontMenu=r.showFontMenu=t;g.saveCookie();g.menu.Find("Math Settings","Font Preference").hidden=!t};g.showContext=function(t){g.cookie.showContext=r.showContext=t;g.saveCookie();g.menu.Find("Math Settings","Contextual Menu").hidden=!t};g.showDiscoverable=function(t){g.cookie.showDiscoverable=r.showDiscoverable=t;g.saveCookie();g.menu.Find("Math Settings","Highlight on Hover").hidden=!t;g.menu.Find("Math Settings","discover_rule").hidden=!t};g.showLocale=function(t){g.cookie.showLocale=r.showLocale=t;g.saveCookie();g.menu.Find("Language").hidden=!t};MathJax.Hub.Register.StartupHook("HTML-CSS Jax Ready",function(){if(!MathJax.OutputJax["HTML-CSS"].config.imageFont){g.menu.Find("Math Settings","Font Preference","TeX (image)").disabled=true}});e.Queue(f.Register.StartupHook("End Config",{}),["Styles",p,r.styles],["Post",f.Startup.signal,"MathMenu Ready"],["loadComplete",p,"[MathJax]/extensions/MathMenu.js"])})(MathJax.Hub,MathJax.HTML,MathJax.Ajax,MathJax.CallBack,MathJax.OutputJax);
	MathJax.ElementJax.mml=MathJax.ElementJax({mimeType:"jax/mml"},{id:"mml",version:"2.6.0",directory:MathJax.ElementJax.directory+"/mml",extensionDir:MathJax.ElementJax.extensionDir+"/mml",optableDir:MathJax.ElementJax.directory+"/mml/optable"});MathJax.ElementJax.mml.Augment({Init:function(){if(arguments.length===1&&arguments[0].type==="math"){this.root=arguments[0]}else{this.root=MathJax.ElementJax.mml.math.apply(this,arguments)}if(this.root.attr&&this.root.attr.mode){if(!this.root.display&&this.root.attr.mode==="display"){this.root.display="block";this.root.attrNames.push("display")}delete this.root.attr.mode;for(var b=0,a=this.root.attrNames.length;b<a;b++){if(this.root.attrNames[b]==="mode"){this.root.attrNames.splice(b,1);break}}}}},{INHERIT:"_inherit_",AUTO:"_auto_",SIZE:{INFINITY:"infinity",SMALL:"small",NORMAL:"normal",BIG:"big"},COLOR:{TRANSPARENT:"transparent"},VARIANT:{NORMAL:"normal",BOLD:"bold",ITALIC:"italic",BOLDITALIC:"bold-italic",DOUBLESTRUCK:"double-struck",FRAKTUR:"fraktur",BOLDFRAKTUR:"bold-fraktur",SCRIPT:"script",BOLDSCRIPT:"bold-script",SANSSERIF:"sans-serif",BOLDSANSSERIF:"bold-sans-serif",SANSSERIFITALIC:"sans-serif-italic",SANSSERIFBOLDITALIC:"sans-serif-bold-italic",MONOSPACE:"monospace",INITIAL:"inital",TAILED:"tailed",LOOPED:"looped",STRETCHED:"stretched",CALIGRAPHIC:"-tex-caligraphic",OLDSTYLE:"-tex-oldstyle"},FORM:{PREFIX:"prefix",INFIX:"infix",POSTFIX:"postfix"},LINEBREAK:{AUTO:"auto",NEWLINE:"newline",NOBREAK:"nobreak",GOODBREAK:"goodbreak",BADBREAK:"badbreak"},LINEBREAKSTYLE:{BEFORE:"before",AFTER:"after",DUPLICATE:"duplicate",INFIXLINBREAKSTYLE:"infixlinebreakstyle"},INDENTALIGN:{LEFT:"left",CENTER:"center",RIGHT:"right",AUTO:"auto",ID:"id",INDENTALIGN:"indentalign"},INDENTSHIFT:{INDENTSHIFT:"indentshift"},LINETHICKNESS:{THIN:"thin",MEDIUM:"medium",THICK:"thick"},NOTATION:{LONGDIV:"longdiv",ACTUARIAL:"actuarial",RADICAL:"radical",BOX:"box",ROUNDEDBOX:"roundedbox",CIRCLE:"circle",LEFT:"left",RIGHT:"right",TOP:"top",BOTTOM:"bottom",UPDIAGONALSTRIKE:"updiagonalstrike",DOWNDIAGONALSTRIKE:"downdiagonalstrike",UPDIAGONALARROW:"updiagonalarrow",VERTICALSTRIKE:"verticalstrike",HORIZONTALSTRIKE:"horizontalstrike",PHASORANGLE:"phasorangle",MADRUWB:"madruwb"},ALIGN:{TOP:"top",BOTTOM:"bottom",CENTER:"center",BASELINE:"baseline",AXIS:"axis",LEFT:"left",RIGHT:"right"},LINES:{NONE:"none",SOLID:"solid",DASHED:"dashed"},SIDE:{LEFT:"left",RIGHT:"right",LEFTOVERLAP:"leftoverlap",RIGHTOVERLAP:"rightoverlap"},WIDTH:{AUTO:"auto",FIT:"fit"},ACTIONTYPE:{TOGGLE:"toggle",STATUSLINE:"statusline",TOOLTIP:"tooltip",INPUT:"input"},LENGTH:{VERYVERYTHINMATHSPACE:"veryverythinmathspace",VERYTHINMATHSPACE:"verythinmathspace",THINMATHSPACE:"thinmathspace",MEDIUMMATHSPACE:"mediummathspace",THICKMATHSPACE:"thickmathspace",VERYTHICKMATHSPACE:"verythickmathspace",VERYVERYTHICKMATHSPACE:"veryverythickmathspace",NEGATIVEVERYVERYTHINMATHSPACE:"negativeveryverythinmathspace",NEGATIVEVERYTHINMATHSPACE:"negativeverythinmathspace",NEGATIVETHINMATHSPACE:"negativethinmathspace",NEGATIVEMEDIUMMATHSPACE:"negativemediummathspace",NEGATIVETHICKMATHSPACE:"negativethickmathspace",NEGATIVEVERYTHICKMATHSPACE:"negativeverythickmathspace",NEGATIVEVERYVERYTHICKMATHSPACE:"negativeveryverythickmathspace"},OVERFLOW:{LINBREAK:"linebreak",SCROLL:"scroll",ELIDE:"elide",TRUNCATE:"truncate",SCALE:"scale"},UNIT:{EM:"em",EX:"ex",PX:"px",IN:"in",CM:"cm",MM:"mm",PT:"pt",PC:"pc"},TEXCLASS:{ORD:0,OP:1,BIN:2,REL:3,OPEN:4,CLOSE:5,PUNCT:6,INNER:7,VCENTER:8,NONE:-1},TEXCLASSNAMES:["ORD","OP","BIN","REL","OPEN","CLOSE","PUNCT","INNER","VCENTER"],skipAttributes:{texClass:true,useHeight:true,texprimestyle:true},copyAttributes:{displaystyle:1,scriptlevel:1,open:1,close:1,form:1,actiontype:1,fontfamily:true,fontsize:true,fontweight:true,fontstyle:true,color:true,background:true,id:true,"class":1,href:true,style:true},copyAttributeNames:["displaystyle","scriptlevel","open","close","form","actiontype","fontfamily","fontsize","fontweight","fontstyle","color","background","id","class","href","style"],nocopyAttributes:{fontfamily:true,fontsize:true,fontweight:true,fontstyle:true,color:true,background:true,id:true,"class":true,href:true,style:true,xmlns:true},Error:function(d,e){var c=this.merror(d),b=MathJax.Localization.fontDirection(),a=MathJax.Localization.fontFamily();if(e){c=c.With(e)}if(b||a){c=this.mstyle(c);if(b){c.dir=b}if(a){c.style.fontFamily="font-family: "+a}}return c}});(function(a){a.mbase=MathJax.Object.Subclass({type:"base",isToken:false,defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,dir:a.INHERIT},noInherit:{},noInheritAttribute:{texClass:true},getRemoved:{},linebreakContainer:false,Init:function(){this.data=[];if(this.inferRow&&!(arguments.length===1&&arguments[0].inferred)){this.Append(a.mrow().With({inferred:true,notParent:true}))}this.Append.apply(this,arguments)},With:function(e){for(var f in e){if(e.hasOwnProperty(f)){this[f]=e[f]}}return this},Append:function(){if(this.inferRow&&this.data.length){this.data[0].Append.apply(this.data[0],arguments)}else{for(var f=0,e=arguments.length;f<e;f++){this.SetData(this.data.length,arguments[f])}}},SetData:function(e,f){if(f!=null){if(!(f instanceof a.mbase)){f=(this.isToken||this.isChars?a.chars(f):a.mtext(f))}f.parent=this;f.setInherit(this.inheritFromMe?this:this.inherit)}this.data[e]=f},Parent:function(){var e=this.parent;while(e&&e.notParent){e=e.parent}return e},Get:function(f,k,l){if(!l){if(this[f]!=null){return this[f]}if(this.attr&&this.attr[f]!=null){return this.attr[f]}}var g=this.Parent();if(g&&g["adjustChild_"+f]!=null){return(g["adjustChild_"+f])(this.childPosition(),k)}var j=this.inherit;var e=j;while(j){var i=j[f];if(i==null&&j.attr){i=j.attr[f]}if(j.removedStyles&&j.getRemoved[f]&&i==null){i=j.removedStyles[j.getRemoved[f]]}if(i!=null&&j.noInheritAttribute&&!j.noInheritAttribute[f]){var h=j.noInherit[this.type];if(!(h&&h[f])){return i}}e=j;j=j.inherit}if(!k){if(this.defaults[f]===a.AUTO){return this.autoDefault(f)}if(this.defaults[f]!==a.INHERIT&&this.defaults[f]!=null){return this.defaults[f]}if(e){return e.defaults[f]}}return null},hasValue:function(e){return(this.Get(e,true)!=null)},getValues:function(){var f={};for(var g=0,e=arguments.length;g<e;g++){f[arguments[g]]=this.Get(arguments[g])}return f},adjustChild_scriptlevel:function(f,e){return this.Get("scriptlevel",e)},adjustChild_displaystyle:function(f,e){return this.Get("displaystyle",e)},adjustChild_texprimestyle:function(f,e){return this.Get("texprimestyle",e)},childPosition:function(){var h=this,g=h.parent;while(g.notParent){h=g;g=h.parent}for(var f=0,e=g.data.length;f<e;f++){if(g.data[f]===h){return f}}return null},setInherit:function(g){if(g!==this.inherit&&this.inherit==null){this.inherit=g;for(var f=0,e=this.data.length;f<e;f++){if(this.data[f]&&this.data[f].setInherit){this.data[f].setInherit(g)}}}},setTeXclass:function(e){this.getPrevClass(e);return(typeof(this.texClass)!=="undefined"?this:e)},getPrevClass:function(e){if(e){this.prevClass=e.Get("texClass");this.prevLevel=e.Get("scriptlevel")}},updateTeXclass:function(e){if(e){this.prevClass=e.prevClass;delete e.prevClass;this.prevLevel=e.prevLevel;delete e.prevLevel;this.texClass=e.Get("texClass")}},texSpacing:function(){var f=(this.prevClass!=null?this.prevClass:a.TEXCLASS.NONE);var e=(this.Get("texClass")||a.TEXCLASS.ORD);if(f===a.TEXCLASS.NONE||e===a.TEXCLASS.NONE){return""}if(f===a.TEXCLASS.VCENTER){f=a.TEXCLASS.ORD}if(e===a.TEXCLASS.VCENTER){e=a.TEXCLASS.ORD}var g=this.TEXSPACE[f][e];if(this.prevLevel>0&&this.Get("scriptlevel")>0&&g>=0){return""}return this.TEXSPACELENGTH[Math.abs(g)]},TEXSPACELENGTH:["",a.LENGTH.THINMATHSPACE,a.LENGTH.MEDIUMMATHSPACE,a.LENGTH.THICKMATHSPACE],TEXSPACE:[[0,-1,2,3,0,0,0,1],[-1,-1,0,3,0,0,0,1],[2,2,0,0,2,0,0,2],[3,3,0,0,3,0,0,3],[0,0,0,0,0,0,0,0],[0,-1,2,3,0,0,0,1],[1,1,0,1,1,1,1,1],[1,-1,2,3,1,0,1,1]],autoDefault:function(e){return""},isSpacelike:function(){return false},isEmbellished:function(){return false},Core:function(){return this},CoreMO:function(){return this},childIndex:function(g){if(g==null){return}for(var f=0,e=this.data.length;f<e;f++){if(g===this.data[f]){return f}}},CoreIndex:function(){return(this.inferRow?this.data[0]||this:this).childIndex(this.Core())},hasNewline:function(){if(this.isEmbellished()){return this.CoreMO().hasNewline()}if(this.isToken||this.linebreakContainer){return false}for(var f=0,e=this.data.length;f<e;f++){if(this.data[f]&&this.data[f].hasNewline()){return true}}return false},array:function(){if(this.inferred){return this.data}else{return[this]}},toString:function(){return this.type+"("+this.data.join(",")+")"},getAnnotation:function(){return null}},{childrenSpacelike:function(){for(var f=0,e=this.data.length;f<e;f++){if(!this.data[f].isSpacelike()){return false}}return true},childEmbellished:function(){return(this.data[0]&&this.data[0].isEmbellished())},childCore:function(){return(this.inferRow&&this.data[0]?this.data[0].Core():this.data[0])},childCoreMO:function(){return(this.data[0]?this.data[0].CoreMO():null)},setChildTeXclass:function(e){if(this.data[0]){e=this.data[0].setTeXclass(e);this.updateTeXclass(this.data[0])}return e},setBaseTeXclasses:function(g){this.getPrevClass(g);this.texClass=null;if(this.data[0]){if(this.isEmbellished()||this.data[0].isa(a.mi)){g=this.data[0].setTeXclass(g);this.updateTeXclass(this.Core())}else{this.data[0].setTeXclass();g=this}}else{g=this}for(var f=1,e=this.data.length;f<e;f++){if(this.data[f]){this.data[f].setTeXclass()}}return g},setSeparateTeXclasses:function(g){this.getPrevClass(g);for(var f=0,e=this.data.length;f<e;f++){if(this.data[f]){this.data[f].setTeXclass()}}if(this.isEmbellished()){this.updateTeXclass(this.Core())}return this}});a.mi=a.mbase.Subclass({type:"mi",isToken:true,texClass:a.TEXCLASS.ORD,defaults:{mathvariant:a.AUTO,mathsize:a.INHERIT,mathbackground:a.INHERIT,mathcolor:a.INHERIT,dir:a.INHERIT},autoDefault:function(f){if(f==="mathvariant"){var e=(this.data[0]||"").toString();return(e.length===1||(e.length===2&&e.charCodeAt(0)>=55296&&e.charCodeAt(0)<56320)?a.VARIANT.ITALIC:a.VARIANT.NORMAL)}return""},setTeXclass:function(f){this.getPrevClass(f);var e=this.data.join("");if(e.length>1&&e.match(/^[a-z][a-z0-9]*$/i)&&this.texClass===a.TEXCLASS.ORD){this.texClass=a.TEXCLASS.OP;this.autoOP=true}return this}});a.mn=a.mbase.Subclass({type:"mn",isToken:true,texClass:a.TEXCLASS.ORD,defaults:{mathvariant:a.INHERIT,mathsize:a.INHERIT,mathbackground:a.INHERIT,mathcolor:a.INHERIT,dir:a.INHERIT}});a.mo=a.mbase.Subclass({type:"mo",isToken:true,defaults:{mathvariant:a.INHERIT,mathsize:a.INHERIT,mathbackground:a.INHERIT,mathcolor:a.INHERIT,dir:a.INHERIT,form:a.AUTO,fence:a.AUTO,separator:a.AUTO,lspace:a.AUTO,rspace:a.AUTO,stretchy:a.AUTO,symmetric:a.AUTO,maxsize:a.AUTO,minsize:a.AUTO,largeop:a.AUTO,movablelimits:a.AUTO,accent:a.AUTO,linebreak:a.LINEBREAK.AUTO,lineleading:a.INHERIT,linebreakstyle:a.AUTO,linebreakmultchar:a.INHERIT,indentalign:a.INHERIT,indentshift:a.INHERIT,indenttarget:a.INHERIT,indentalignfirst:a.INHERIT,indentshiftfirst:a.INHERIT,indentalignlast:a.INHERIT,indentshiftlast:a.INHERIT,texClass:a.AUTO},defaultDef:{form:a.FORM.INFIX,fence:false,separator:false,lspace:a.LENGTH.THICKMATHSPACE,rspace:a.LENGTH.THICKMATHSPACE,stretchy:false,symmetric:false,maxsize:a.SIZE.INFINITY,minsize:"0em",largeop:false,movablelimits:false,accent:false,linebreak:a.LINEBREAK.AUTO,lineleading:"1ex",linebreakstyle:"before",indentalign:a.INDENTALIGN.AUTO,indentshift:"0",indenttarget:"",indentalignfirst:a.INDENTALIGN.INDENTALIGN,indentshiftfirst:a.INDENTSHIFT.INDENTSHIFT,indentalignlast:a.INDENTALIGN.INDENTALIGN,indentshiftlast:a.INDENTSHIFT.INDENTSHIFT,texClass:a.TEXCLASS.REL},SPACE_ATTR:{lspace:1,rspace:2,form:4},useMMLspacing:7,autoDefault:function(g,n){var l=this.def;if(!l){if(g==="form"){this.useMMLspacing&=~this.SPACE_ATTR.form;return this.getForm()}var k=this.data.join("");var f=[this.Get("form"),a.FORM.INFIX,a.FORM.POSTFIX,a.FORM.PREFIX];for(var h=0,e=f.length;h<e;h++){var j=this.OPTABLE[f[h]][k];if(j){l=this.makeDef(j);break}}if(!l){l=this.CheckRange(k)}if(!l&&n){l={}}else{if(!l){l=MathJax.Hub.Insert({},this.defaultDef)}if(this.parent){this.def=l}else{l=MathJax.Hub.Insert({},l)}l.form=f[0]}}this.useMMLspacing&=~(this.SPACE_ATTR[g]||0);if(l[g]!=null){return l[g]}else{if(!n){return this.defaultDef[g]}}return""},CheckRange:function(j){var k=j.charCodeAt(0);if(k>=55296&&k<56320){k=(((k-55296)<<10)+(j.charCodeAt(1)-56320))+65536}for(var g=0,e=this.RANGES.length;g<e&&this.RANGES[g][0]<=k;g++){if(k<=this.RANGES[g][1]){if(this.RANGES[g][3]){var f=a.optableDir+"/"+this.RANGES[g][3]+".js";this.RANGES[g][3]=null;MathJax.Hub.RestartAfter(MathJax.Ajax.Require(f))}var h=a.TEXCLASSNAMES[this.RANGES[g][2]];h=this.OPTABLE.infix[j]=a.mo.OPTYPES[h==="BIN"?"BIN3":h];return this.makeDef(h)}}return null},makeDef:function(f){if(f[2]==null){f[2]=this.defaultDef.texClass}if(!f[3]){f[3]={}}var e=MathJax.Hub.Insert({},f[3]);e.lspace=this.SPACE[f[0]];e.rspace=this.SPACE[f[1]];e.texClass=f[2];if(e.texClass===a.TEXCLASS.REL&&(this.movablelimits||this.data.join("").match(/^[a-z]+$/i))){e.texClass=a.TEXCLASS.OP}return e},getForm:function(){var e=this,g=this.parent,f=this.Parent();while(f&&f.isEmbellished()){e=g;g=f.parent;f=f.Parent()}if(g&&g.type==="mrow"&&g.NonSpaceLength()!==1){if(g.FirstNonSpace()===e){return a.FORM.PREFIX}if(g.LastNonSpace()===e){return a.FORM.POSTFIX}}return a.FORM.INFIX},isEmbellished:function(){return true},hasNewline:function(){return(this.Get("linebreak")===a.LINEBREAK.NEWLINE)},CoreParent:function(){var e=this;while(e&&e.isEmbellished()&&e.CoreMO()===this&&!e.isa(a.math)){e=e.Parent()}return e},CoreText:function(e){if(!e){return""}if(e.isEmbellished()){return e.CoreMO().data.join("")}while((((e.isa(a.mrow)||e.isa(a.TeXAtom)||e.isa(a.mstyle)||e.isa(a.mphantom))&&e.data.length===1)||e.isa(a.munderover))&&e.data[0]){e=e.data[0]}if(!e.isToken){return""}else{return e.data.join("")}},remapChars:{"*":"\u2217",'"':"\u2033","\u00B0":"\u2218","\u00B2":"2","\u00B3":"3","\u00B4":"\u2032","\u00B9":"1"},remap:function(f,e){f=f.replace(/-/g,"\u2212");if(e){f=f.replace(/'/g,"\u2032").replace(/`/g,"\u2035");if(f.length===1){f=e[f]||f}}return f},setTeXclass:function(f){var e=this.getValues("form","lspace","rspace","fence");if(this.useMMLspacing){this.texClass=a.TEXCLASS.NONE;return this}if(e.fence&&!this.texClass){if(e.form===a.FORM.PREFIX){this.texClass=a.TEXCLASS.OPEN}if(e.form===a.FORM.POSTFIX){this.texClass=a.TEXCLASS.CLOSE}}this.texClass=this.Get("texClass");if(this.data.join("")==="\u2061"){if(f){f.texClass=a.TEXCLASS.OP;f.fnOP=true}this.texClass=this.prevClass=a.TEXCLASS.NONE;return f}return this.adjustTeXclass(f)},adjustTeXclass:function(f){if(this.texClass===a.TEXCLASS.NONE){return f}if(f){if(f.autoOP&&(this.texClass===a.TEXCLASS.BIN||this.texClass===a.TEXCLASS.REL)){f.texClass=a.TEXCLASS.ORD}this.prevClass=f.texClass||a.TEXCLASS.ORD;this.prevLevel=f.Get("scriptlevel")}else{this.prevClass=a.TEXCLASS.NONE}if(this.texClass===a.TEXCLASS.BIN&&(this.prevClass===a.TEXCLASS.NONE||this.prevClass===a.TEXCLASS.BIN||this.prevClass===a.TEXCLASS.OP||this.prevClass===a.TEXCLASS.REL||this.prevClass===a.TEXCLASS.OPEN||this.prevClass===a.TEXCLASS.PUNCT)){this.texClass=a.TEXCLASS.ORD}else{if(this.prevClass===a.TEXCLASS.BIN&&(this.texClass===a.TEXCLASS.REL||this.texClass===a.TEXCLASS.CLOSE||this.texClass===a.TEXCLASS.PUNCT)){f.texClass=this.prevClass=a.TEXCLASS.ORD}else{if(this.texClass===a.TEXCLASS.BIN){var g=this,e=this.parent;while(e&&e.parent&&e.isEmbellished()&&(e.data.length===1||(e.type!=="mrow"&&e.Core()===g))){g=e;e=e.parent}if(e.data[e.data.length-1]===g){this.texClass=a.TEXCLASS.ORD}}}}return this}});a.mtext=a.mbase.Subclass({type:"mtext",isToken:true,isSpacelike:function(){return true},texClass:a.TEXCLASS.ORD,defaults:{mathvariant:a.INHERIT,mathsize:a.INHERIT,mathbackground:a.INHERIT,mathcolor:a.INHERIT,dir:a.INHERIT}});a.mspace=a.mbase.Subclass({type:"mspace",isToken:true,isSpacelike:function(){return true},defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,width:"0em",height:"0ex",depth:"0ex",linebreak:a.LINEBREAK.AUTO},hasDimAttr:function(){return(this.hasValue("width")||this.hasValue("height")||this.hasValue("depth"))},hasNewline:function(){return(!this.hasDimAttr()&&this.Get("linebreak")===a.LINEBREAK.NEWLINE)}});a.ms=a.mbase.Subclass({type:"ms",isToken:true,texClass:a.TEXCLASS.ORD,defaults:{mathvariant:a.INHERIT,mathsize:a.INHERIT,mathbackground:a.INHERIT,mathcolor:a.INHERIT,dir:a.INHERIT,lquote:'"',rquote:'"'}});a.mglyph=a.mbase.Subclass({type:"mglyph",isToken:true,texClass:a.TEXCLASS.ORD,defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,alt:"",src:"",width:a.AUTO,height:a.AUTO,valign:"0em"}});a.mrow=a.mbase.Subclass({type:"mrow",isSpacelike:a.mbase.childrenSpacelike,inferred:false,notParent:false,isEmbellished:function(){var f=false;for(var g=0,e=this.data.length;g<e;g++){if(this.data[g]==null){continue}if(this.data[g].isEmbellished()){if(f){return false}f=true;this.core=g}else{if(!this.data[g].isSpacelike()){return false}}}return f},NonSpaceLength:function(){var g=0;for(var f=0,e=this.data.length;f<e;f++){if(this.data[f]&&!this.data[f].isSpacelike()){g++}}return g},FirstNonSpace:function(){for(var f=0,e=this.data.length;f<e;f++){if(this.data[f]&&!this.data[f].isSpacelike()){return this.data[f]}}return null},LastNonSpace:function(){for(var e=this.data.length-1;e>=0;e--){if(this.data[0]&&!this.data[e].isSpacelike()){return this.data[e]}}return null},Core:function(){if(!(this.isEmbellished())||typeof(this.core)==="undefined"){return this}return this.data[this.core]},CoreMO:function(){if(!(this.isEmbellished())||typeof(this.core)==="undefined"){return this}return this.data[this.core].CoreMO()},toString:function(){if(this.inferred){return"["+this.data.join(",")+"]"}return this.SUPER(arguments).toString.call(this)},setTeXclass:function(g){var f,e=this.data.length;if((this.open||this.close)&&(!g||!g.fnOP)){this.getPrevClass(g);g=null;for(f=0;f<e;f++){if(this.data[f]){g=this.data[f].setTeXclass(g)}}if(!this.hasOwnProperty("texClass")){this.texClass=a.TEXCLASS.INNER}return this}else{for(f=0;f<e;f++){if(this.data[f]){g=this.data[f].setTeXclass(g)}}if(this.data[0]){this.updateTeXclass(this.data[0])}return g}},getAnnotation:function(e){if(this.data.length!=1){return null}return this.data[0].getAnnotation(e)}});a.mfrac=a.mbase.Subclass({type:"mfrac",num:0,den:1,linebreakContainer:true,isEmbellished:a.mbase.childEmbellished,Core:a.mbase.childCore,CoreMO:a.mbase.childCoreMO,defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,linethickness:a.LINETHICKNESS.MEDIUM,numalign:a.ALIGN.CENTER,denomalign:a.ALIGN.CENTER,bevelled:false},adjustChild_displaystyle:function(e){return false},adjustChild_scriptlevel:function(f){var e=this.Get("scriptlevel");if(!this.Get("displaystyle")||e>0){e++}return e},adjustChild_texprimestyle:function(e){if(e==this.den){return true}return this.Get("texprimestyle")},setTeXclass:a.mbase.setSeparateTeXclasses});a.msqrt=a.mbase.Subclass({type:"msqrt",inferRow:true,linebreakContainer:true,texClass:a.TEXCLASS.ORD,setTeXclass:a.mbase.setSeparateTeXclasses,adjustChild_texprimestyle:function(e){return true}});a.mroot=a.mbase.Subclass({type:"mroot",linebreakContainer:true,texClass:a.TEXCLASS.ORD,adjustChild_displaystyle:function(e){if(e===1){return false}return this.Get("displaystyle")},adjustChild_scriptlevel:function(f){var e=this.Get("scriptlevel");if(f===1){e+=2}return e},adjustChild_texprimestyle:function(e){if(e===0){return true}return this.Get("texprimestyle")},setTeXclass:a.mbase.setSeparateTeXclasses});a.mstyle=a.mbase.Subclass({type:"mstyle",isSpacelike:a.mbase.childrenSpacelike,isEmbellished:a.mbase.childEmbellished,Core:a.mbase.childCore,CoreMO:a.mbase.childCoreMO,inferRow:true,defaults:{scriptlevel:a.INHERIT,displaystyle:a.INHERIT,scriptsizemultiplier:Math.sqrt(1/2),scriptminsize:"8pt",mathbackground:a.INHERIT,mathcolor:a.INHERIT,dir:a.INHERIT,infixlinebreakstyle:a.LINEBREAKSTYLE.BEFORE,decimalseparator:"."},adjustChild_scriptlevel:function(g){var f=this.scriptlevel;if(f==null){f=this.Get("scriptlevel")}else{if(String(f).match(/^ *[-+]/)){var e=this.Get("scriptlevel",null,true);f=e+parseInt(f)}}return f},inheritFromMe:true,noInherit:{mpadded:{width:true,height:true,depth:true,lspace:true,voffset:true},mtable:{width:true,height:true,depth:true,align:true}},getRemoved:{fontfamily:"fontFamily",fontweight:"fontWeight",fontstyle:"fontStyle",fontsize:"fontSize"},setTeXclass:a.mbase.setChildTeXclass});a.merror=a.mbase.Subclass({type:"merror",inferRow:true,linebreakContainer:true,texClass:a.TEXCLASS.ORD});a.mpadded=a.mbase.Subclass({type:"mpadded",inferRow:true,isSpacelike:a.mbase.childrenSpacelike,isEmbellished:a.mbase.childEmbellished,Core:a.mbase.childCore,CoreMO:a.mbase.childCoreMO,defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,width:"",height:"",depth:"",lspace:0,voffset:0},setTeXclass:a.mbase.setChildTeXclass});a.mphantom=a.mbase.Subclass({type:"mphantom",texClass:a.TEXCLASS.ORD,inferRow:true,isSpacelike:a.mbase.childrenSpacelike,isEmbellished:a.mbase.childEmbellished,Core:a.mbase.childCore,CoreMO:a.mbase.childCoreMO,setTeXclass:a.mbase.setChildTeXclass});a.mfenced=a.mbase.Subclass({type:"mfenced",defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,open:"(",close:")",separators:","},addFakeNodes:function(){var f=this.getValues("open","close","separators");f.open=f.open.replace(/[ \t\n\r]/g,"");f.close=f.close.replace(/[ \t\n\r]/g,"");f.separators=f.separators.replace(/[ \t\n\r]/g,"");if(f.open!==""){this.SetData("open",a.mo(f.open).With({fence:true,form:a.FORM.PREFIX,texClass:a.TEXCLASS.OPEN}));this.data.open.useMMLspacing=0}if(f.separators!==""){while(f.separators.length<this.data.length){f.separators+=f.separators.charAt(f.separators.length-1)}for(var g=1,e=this.data.length;g<e;g++){if(this.data[g]){this.SetData("sep"+g,a.mo(f.separators.charAt(g-1)).With({separator:true}));this.data["sep"+g].useMMLspacing=0}}}if(f.close!==""){this.SetData("close",a.mo(f.close).With({fence:true,form:a.FORM.POSTFIX,texClass:a.TEXCLASS.CLOSE}));this.data.close.useMMLspacing=0}},texClass:a.TEXCLASS.OPEN,setTeXclass:function(g){this.addFakeNodes();this.getPrevClass(g);if(this.data.open){g=this.data.open.setTeXclass(g)}if(this.data[0]){g=this.data[0].setTeXclass(g)}for(var f=1,e=this.data.length;f<e;f++){if(this.data["sep"+f]){g=this.data["sep"+f].setTeXclass(g)}if(this.data[f]){g=this.data[f].setTeXclass(g)}}if(this.data.close){g=this.data.close.setTeXclass(g)}this.updateTeXclass(this.data.open);this.texClass=a.TEXCLASS.INNER;return g}});a.menclose=a.mbase.Subclass({type:"menclose",inferRow:true,linebreakContainer:true,defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,notation:a.NOTATION.LONGDIV,texClass:a.TEXCLASS.ORD},setTeXclass:a.mbase.setSeparateTeXclasses});a.msubsup=a.mbase.Subclass({type:"msubsup",base:0,sub:1,sup:2,isEmbellished:a.mbase.childEmbellished,Core:a.mbase.childCore,CoreMO:a.mbase.childCoreMO,defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,subscriptshift:"",superscriptshift:"",texClass:a.AUTO},autoDefault:function(e){if(e==="texClass"){return(this.isEmbellished()?this.CoreMO().Get(e):a.TEXCLASS.ORD)}return 0},adjustChild_displaystyle:function(e){if(e>0){return false}return this.Get("displaystyle")},adjustChild_scriptlevel:function(f){var e=this.Get("scriptlevel");if(f>0){e++}return e},adjustChild_texprimestyle:function(e){if(e===this.sub){return true}return this.Get("texprimestyle")},setTeXclass:a.mbase.setBaseTeXclasses});a.msub=a.msubsup.Subclass({type:"msub"});a.msup=a.msubsup.Subclass({type:"msup",sub:2,sup:1});a.mmultiscripts=a.msubsup.Subclass({type:"mmultiscripts",adjustChild_texprimestyle:function(e){if(e%2===1){return true}return this.Get("texprimestyle")}});a.mprescripts=a.mbase.Subclass({type:"mprescripts"});a.none=a.mbase.Subclass({type:"none"});a.munderover=a.mbase.Subclass({type:"munderover",base:0,under:1,over:2,sub:1,sup:2,ACCENTS:["","accentunder","accent"],linebreakContainer:true,isEmbellished:a.mbase.childEmbellished,Core:a.mbase.childCore,CoreMO:a.mbase.childCoreMO,defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,accent:a.AUTO,accentunder:a.AUTO,align:a.ALIGN.CENTER,texClass:a.AUTO,subscriptshift:"",superscriptshift:""},autoDefault:function(e){if(e==="texClass"){return(this.isEmbellished()?this.CoreMO().Get(e):a.TEXCLASS.ORD)}if(e==="accent"&&this.data[this.over]){return this.data[this.over].CoreMO().Get("accent")}if(e==="accentunder"&&this.data[this.under]){return this.data[this.under].CoreMO().Get("accent")}return false},adjustChild_displaystyle:function(e){if(e>0){return false}return this.Get("displaystyle")},adjustChild_scriptlevel:function(g){var f=this.Get("scriptlevel");var e=(this.data[this.base]&&!this.Get("displaystyle")&&this.data[this.base].CoreMO().Get("movablelimits"));if(g==this.under&&(e||!this.Get("accentunder"))){f++}if(g==this.over&&(e||!this.Get("accent"))){f++}return f},adjustChild_texprimestyle:function(e){if(e===this.base&&this.data[this.over]){return true}return this.Get("texprimestyle")},setTeXclass:a.mbase.setBaseTeXclasses});a.munder=a.munderover.Subclass({type:"munder"});a.mover=a.munderover.Subclass({type:"mover",over:1,under:2,sup:1,sub:2,ACCENTS:["","accent","accentunder"]});a.mtable=a.mbase.Subclass({type:"mtable",defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,align:a.ALIGN.AXIS,rowalign:a.ALIGN.BASELINE,columnalign:a.ALIGN.CENTER,groupalign:"{left}",alignmentscope:true,columnwidth:a.WIDTH.AUTO,width:a.WIDTH.AUTO,rowspacing:"1ex",columnspacing:".8em",rowlines:a.LINES.NONE,columnlines:a.LINES.NONE,frame:a.LINES.NONE,framespacing:"0.4em 0.5ex",equalrows:false,equalcolumns:false,displaystyle:false,side:a.SIDE.RIGHT,minlabelspacing:"0.8em",texClass:a.TEXCLASS.ORD,useHeight:1},adjustChild_displaystyle:function(){return(this.displaystyle!=null?this.displaystyle:this.defaults.displaystyle)},inheritFromMe:true,noInherit:{mover:{align:true},munder:{align:true},munderover:{align:true},mtable:{align:true,rowalign:true,columnalign:true,groupalign:true,alignmentscope:true,columnwidth:true,width:true,rowspacing:true,columnspacing:true,rowlines:true,columnlines:true,frame:true,framespacing:true,equalrows:true,equalcolumns:true,displaystyle:true,side:true,minlabelspacing:true,texClass:true,useHeight:1}},linebreakContainer:true,Append:function(){for(var f=0,e=arguments.length;f<e;f++){if(!((arguments[f] instanceof a.mtr)||(arguments[f] instanceof a.mlabeledtr))){arguments[f]=a.mtr(arguments[f])}}this.SUPER(arguments).Append.apply(this,arguments)},setTeXclass:a.mbase.setSeparateTeXclasses});a.mtr=a.mbase.Subclass({type:"mtr",defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,rowalign:a.INHERIT,columnalign:a.INHERIT,groupalign:a.INHERIT},inheritFromMe:true,noInherit:{mrow:{rowalign:true,columnalign:true,groupalign:true},mtable:{rowalign:true,columnalign:true,groupalign:true}},linebreakContainer:true,Append:function(){for(var f=0,e=arguments.length;f<e;f++){if(!(arguments[f] instanceof a.mtd)){arguments[f]=a.mtd(arguments[f])}}this.SUPER(arguments).Append.apply(this,arguments)},setTeXclass:a.mbase.setSeparateTeXclasses});a.mtd=a.mbase.Subclass({type:"mtd",inferRow:true,linebreakContainer:true,isEmbellished:a.mbase.childEmbellished,Core:a.mbase.childCore,CoreMO:a.mbase.childCoreMO,defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,rowspan:1,columnspan:1,rowalign:a.INHERIT,columnalign:a.INHERIT,groupalign:a.INHERIT},setTeXclass:a.mbase.setSeparateTeXclasses});a.maligngroup=a.mbase.Subclass({type:"maligngroup",isSpacelike:function(){return true},defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,groupalign:a.INHERIT},inheritFromMe:true,noInherit:{mrow:{groupalign:true},mtable:{groupalign:true}}});a.malignmark=a.mbase.Subclass({type:"malignmark",defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,edge:a.SIDE.LEFT},isSpacelike:function(){return true}});a.mlabeledtr=a.mtr.Subclass({type:"mlabeledtr"});a.maction=a.mbase.Subclass({type:"maction",defaults:{mathbackground:a.INHERIT,mathcolor:a.INHERIT,actiontype:a.ACTIONTYPE.TOGGLE,selection:1},selected:function(){return this.data[this.Get("selection")-1]||a.NULL},isEmbellished:function(){return this.selected().isEmbellished()},isSpacelike:function(){return this.selected().isSpacelike()},Core:function(){return this.selected().Core()},CoreMO:function(){return this.selected().CoreMO()},setTeXclass:function(f){if(this.Get("actiontype")===a.ACTIONTYPE.TOOLTIP&&this.data[1]){this.data[1].setTeXclass()}var e=this.selected();f=e.setTeXclass(f);this.updateTeXclass(e);return f}});a.semantics=a.mbase.Subclass({type:"semantics",notParent:true,isEmbellished:a.mbase.childEmbellished,Core:a.mbase.childCore,CoreMO:a.mbase.childCoreMO,defaults:{definitionURL:null,encoding:null},setTeXclass:a.mbase.setChildTeXclass,getAnnotation:function(g){var l=MathJax.Hub.config.MathMenu.semanticsAnnotations[g];if(l){for(var h=0,e=this.data.length;h<e;h++){var k=this.data[h].Get("encoding");if(k){for(var f=0,o=l.length;f<o;f++){if(l[f]===k){return this.data[h]}}}}}return null}});a.annotation=a.mbase.Subclass({type:"annotation",isChars:true,linebreakContainer:true,defaults:{definitionURL:null,encoding:null,cd:"mathmlkeys",name:"",src:null}});a["annotation-xml"]=a.mbase.Subclass({type:"annotation-xml",linebreakContainer:true,defaults:{definitionURL:null,encoding:null,cd:"mathmlkeys",name:"",src:null}});a.math=a.mstyle.Subclass({type:"math",defaults:{mathvariant:a.VARIANT.NORMAL,mathsize:a.SIZE.NORMAL,mathcolor:"",mathbackground:a.COLOR.TRANSPARENT,dir:"ltr",scriptlevel:0,displaystyle:a.AUTO,display:"inline",maxwidth:"",overflow:a.OVERFLOW.LINEBREAK,altimg:"","altimg-width":"","altimg-height":"","altimg-valign":"",alttext:"",cdgroup:"",scriptsizemultiplier:Math.sqrt(1/2),scriptminsize:"8px",infixlinebreakstyle:a.LINEBREAKSTYLE.BEFORE,lineleading:"1ex",indentshift:"auto",indentalign:a.INDENTALIGN.AUTO,indentalignfirst:a.INDENTALIGN.INDENTALIGN,indentshiftfirst:a.INDENTSHIFT.INDENTSHIFT,indentalignlast:a.INDENTALIGN.INDENTALIGN,indentshiftlast:a.INDENTSHIFT.INDENTSHIFT,decimalseparator:".",texprimestyle:false},autoDefault:function(e){if(e==="displaystyle"){return this.Get("display")==="block"}return""},linebreakContainer:true,setTeXclass:a.mbase.setChildTeXclass,getAnnotation:function(e){if(this.data.length!=1){return null}return this.data[0].getAnnotation(e)}});a.chars=a.mbase.Subclass({type:"chars",Append:function(){this.data.push.apply(this.data,arguments)},value:function(){return this.data.join("")},toString:function(){return this.data.join("")}});a.entity=a.mbase.Subclass({type:"entity",Append:function(){this.data.push.apply(this.data,arguments)},value:function(){if(this.data[0].substr(0,2)==="#x"){return parseInt(this.data[0].substr(2),16)}else{if(this.data[0].substr(0,1)==="#"){return parseInt(this.data[0].substr(1))}else{return 0}}},toString:function(){var e=this.value();if(e<=65535){return String.fromCharCode(e)}e-=65536;return String.fromCharCode((e>>10)+55296)+String.fromCharCode((e&1023)+56320)}});a.xml=a.mbase.Subclass({type:"xml",Init:function(){this.div=document.createElement("div");return this.SUPER(arguments).Init.apply(this,arguments)},Append:function(){for(var f=0,e=arguments.length;f<e;f++){var g=this.Import(arguments[f]);this.data.push(g);this.div.appendChild(g)}},Import:function(j){if(document.importNode){return document.importNode(j,true)}var f,g,e;if(j.nodeType===1){f=document.createElement(j.nodeName);for(g=0,e=j.attributes.length;g<e;g++){var h=j.attributes[g];if(h.specified&&h.nodeValue!=null&&h.nodeValue!=""){f.setAttribute(h.nodeName,h.nodeValue)}if(h.nodeName==="style"){f.style.cssText=h.nodeValue}}if(j.className){f.className=j.className}}else{if(j.nodeType===3||j.nodeType===4){f=document.createTextNode(j.nodeValue)}else{if(j.nodeType===8){f=document.createComment(j.nodeValue)}else{return document.createTextNode("")}}}for(g=0,e=j.childNodes.length;g<e;g++){f.appendChild(this.Import(j.childNodes[g]))}return f},value:function(){return this.div},toString:function(){return this.div.innerHTML}});a.TeXAtom=a.mbase.Subclass({type:"texatom",inferRow:true,notParent:true,texClass:a.TEXCLASS.ORD,Core:a.mbase.childCore,CoreMO:a.mbase.childCoreMO,isEmbellished:a.mbase.childEmbellished,setTeXclass:function(e){this.data[0].setTeXclass();return this.adjustTeXclass(e)},adjustTeXclass:a.mo.prototype.adjustTeXclass});a.NULL=a.mbase().With({type:"null"});var b=a.TEXCLASS;var d={ORD:[0,0,b.ORD],ORD11:[1,1,b.ORD],ORD21:[2,1,b.ORD],ORD02:[0,2,b.ORD],ORD55:[5,5,b.ORD],OP:[1,2,b.OP,{largeop:true,movablelimits:true,symmetric:true}],OPFIXED:[1,2,b.OP,{largeop:true,movablelimits:true}],INTEGRAL:[0,1,b.OP,{largeop:true,symmetric:true}],INTEGRAL2:[1,2,b.OP,{largeop:true,symmetric:true}],BIN3:[3,3,b.BIN],BIN4:[4,4,b.BIN],BIN01:[0,1,b.BIN],BIN5:[5,5,b.BIN],TALLBIN:[4,4,b.BIN,{stretchy:true}],BINOP:[4,4,b.BIN,{largeop:true,movablelimits:true}],REL:[5,5,b.REL],REL1:[1,1,b.REL,{stretchy:true}],REL4:[4,4,b.REL],RELSTRETCH:[5,5,b.REL,{stretchy:true}],RELACCENT:[5,5,b.REL,{accent:true}],WIDEREL:[5,5,b.REL,{accent:true,stretchy:true}],OPEN:[0,0,b.OPEN,{fence:true,stretchy:true,symmetric:true}],CLOSE:[0,0,b.CLOSE,{fence:true,stretchy:true,symmetric:true}],INNER:[0,0,b.INNER],PUNCT:[0,3,b.PUNCT],ACCENT:[0,0,b.ORD,{accent:true}],WIDEACCENT:[0,0,b.ORD,{accent:true,stretchy:true}]};a.mo.Augment({SPACE:["0em","0.1111em","0.1667em","0.2222em","0.2667em","0.3333em"],RANGES:[[32,127,b.REL,"BasicLatin"],[160,255,b.ORD,"Latin1Supplement"],[256,383,b.ORD],[384,591,b.ORD],[688,767,b.ORD,"SpacingModLetters"],[768,879,b.ORD,"CombDiacritMarks"],[880,1023,b.ORD,"GreekAndCoptic"],[7680,7935,b.ORD],[8192,8303,b.PUNCT,"GeneralPunctuation"],[8304,8351,b.ORD],[8352,8399,b.ORD],[8400,8447,b.ORD,"CombDiactForSymbols"],[8448,8527,b.ORD,"LetterlikeSymbols"],[8528,8591,b.ORD],[8592,8703,b.REL,"Arrows"],[8704,8959,b.BIN,"MathOperators"],[8960,9215,b.ORD,"MiscTechnical"],[9312,9471,b.ORD],[9472,9631,b.ORD],[9632,9727,b.ORD,"GeometricShapes"],[9984,10175,b.ORD,"Dingbats"],[10176,10223,b.ORD,"MiscMathSymbolsA"],[10224,10239,b.REL,"SupplementalArrowsA"],[10496,10623,b.REL,"SupplementalArrowsB"],[10624,10751,b.ORD,"MiscMathSymbolsB"],[10752,11007,b.BIN,"SuppMathOperators"],[11008,11263,b.ORD,"MiscSymbolsAndArrows"],[119808,120831,b.ORD]],OPTABLE:{prefix:{"\u2200":d.ORD21,"\u2202":d.ORD21,"\u2203":d.ORD21,"\u2207":d.ORD21,"\u220F":d.OP,"\u2210":d.OP,"\u2211":d.OP,"\u2212":d.BIN01,"\u2213":d.BIN01,"\u221A":[1,1,b.ORD,{stretchy:true}],"\u2220":d.ORD,"\u222B":d.INTEGRAL,"\u222E":d.INTEGRAL,"\u22C0":d.OP,"\u22C1":d.OP,"\u22C2":d.OP,"\u22C3":d.OP,"\u2308":d.OPEN,"\u230A":d.OPEN,"\u27E8":d.OPEN,"\u27EE":d.OPEN,"\u2A00":d.OP,"\u2A01":d.OP,"\u2A02":d.OP,"\u2A04":d.OP,"\u2A06":d.OP,"\u00AC":d.ORD21,"\u00B1":d.BIN01,"(":d.OPEN,"+":d.BIN01,"-":d.BIN01,"[":d.OPEN,"{":d.OPEN,"|":d.OPEN},postfix:{"!":[1,0,b.CLOSE],"&":d.ORD,"\u2032":d.ORD02,"\u203E":d.WIDEACCENT,"\u2309":d.CLOSE,"\u230B":d.CLOSE,"\u23DE":d.WIDEACCENT,"\u23DF":d.WIDEACCENT,"\u266D":d.ORD02,"\u266E":d.ORD02,"\u266F":d.ORD02,"\u27E9":d.CLOSE,"\u27EF":d.CLOSE,"\u02C6":d.WIDEACCENT,"\u02C7":d.WIDEACCENT,"\u02C9":d.WIDEACCENT,"\u02CA":d.ACCENT,"\u02CB":d.ACCENT,"\u02D8":d.ACCENT,"\u02D9":d.ACCENT,"\u02DC":d.WIDEACCENT,"\u0302":d.WIDEACCENT,"\u00A8":d.ACCENT,"\u00AF":d.WIDEACCENT,")":d.CLOSE,"]":d.CLOSE,"^":d.WIDEACCENT,_:d.WIDEACCENT,"`":d.ACCENT,"|":d.CLOSE,"}":d.CLOSE,"~":d.WIDEACCENT},infix:{"":d.ORD,"%":[3,3,b.ORD],"\u2022":d.BIN4,"\u2026":d.INNER,"\u2044":d.TALLBIN,"\u2061":d.ORD,"\u2062":d.ORD,"\u2063":[0,0,b.ORD,{linebreakstyle:"after",separator:true}],"\u2064":d.ORD,"\u2190":d.WIDEREL,"\u2191":d.RELSTRETCH,"\u2192":d.WIDEREL,"\u2193":d.RELSTRETCH,"\u2194":d.WIDEREL,"\u2195":d.RELSTRETCH,"\u2196":d.RELSTRETCH,"\u2197":d.RELSTRETCH,"\u2198":d.RELSTRETCH,"\u2199":d.RELSTRETCH,"\u21A6":d.WIDEREL,"\u21A9":d.WIDEREL,"\u21AA":d.WIDEREL,"\u21BC":d.WIDEREL,"\u21BD":d.WIDEREL,"\u21C0":d.WIDEREL,"\u21C1":d.WIDEREL,"\u21CC":d.WIDEREL,"\u21D0":d.WIDEREL,"\u21D1":d.RELSTRETCH,"\u21D2":d.WIDEREL,"\u21D3":d.RELSTRETCH,"\u21D4":d.WIDEREL,"\u21D5":d.RELSTRETCH,"\u2208":d.REL,"\u2209":d.REL,"\u220B":d.REL,"\u2212":d.BIN4,"\u2213":d.BIN4,"\u2215":d.TALLBIN,"\u2216":d.BIN4,"\u2217":d.BIN4,"\u2218":d.BIN4,"\u2219":d.BIN4,"\u221D":d.REL,"\u2223":d.REL,"\u2225":d.REL,"\u2227":d.BIN4,"\u2228":d.BIN4,"\u2229":d.BIN4,"\u222A":d.BIN4,"\u223C":d.REL,"\u2240":d.BIN4,"\u2243":d.REL,"\u2245":d.REL,"\u2248":d.REL,"\u224D":d.REL,"\u2250":d.REL,"\u2260":d.REL,"\u2261":d.REL,"\u2264":d.REL,"\u2265":d.REL,"\u226A":d.REL,"\u226B":d.REL,"\u227A":d.REL,"\u227B":d.REL,"\u2282":d.REL,"\u2283":d.REL,"\u2286":d.REL,"\u2287":d.REL,"\u228E":d.BIN4,"\u2291":d.REL,"\u2292":d.REL,"\u2293":d.BIN4,"\u2294":d.BIN4,"\u2295":d.BIN4,"\u2296":d.BIN4,"\u2297":d.BIN4,"\u2298":d.BIN4,"\u2299":d.BIN4,"\u22A2":d.REL,"\u22A3":d.REL,"\u22A4":d.ORD55,"\u22A5":d.REL,"\u22A8":d.REL,"\u22C4":d.BIN4,"\u22C5":d.BIN4,"\u22C6":d.BIN4,"\u22C8":d.REL,"\u22EE":d.ORD55,"\u22EF":d.INNER,"\u22F1":[5,5,b.INNER],"\u25B3":d.BIN4,"\u25B5":d.BIN4,"\u25B9":d.BIN4,"\u25BD":d.BIN4,"\u25BF":d.BIN4,"\u25C3":d.BIN4,"\u2758":d.REL,"\u27F5":d.WIDEREL,"\u27F6":d.WIDEREL,"\u27F7":d.WIDEREL,"\u27F8":d.WIDEREL,"\u27F9":d.WIDEREL,"\u27FA":d.WIDEREL,"\u27FC":d.WIDEREL,"\u2A2F":d.BIN4,"\u2A3F":d.BIN4,"\u2AAF":d.REL,"\u2AB0":d.REL,"\u00B1":d.BIN4,"\u00B7":d.BIN4,"\u00D7":d.BIN4,"\u00F7":d.BIN4,"*":d.BIN3,"+":d.BIN4,",":[0,3,b.PUNCT,{linebreakstyle:"after",separator:true}],"-":d.BIN4,".":[3,3,b.ORD],"/":d.ORD11,":":[1,2,b.REL],";":[0,3,b.PUNCT,{linebreakstyle:"after",separator:true}],"<":d.REL,"=":d.REL,">":d.REL,"?":[1,1,b.CLOSE],"\\":d.ORD,"^":d.ORD11,_:d.ORD11,"|":[2,2,b.ORD,{fence:true,stretchy:true,symmetric:true}],"#":d.ORD,"$":d.ORD,"\u002E":[0,3,b.PUNCT,{separator:true}],"\u02B9":d.ORD,"\u0300":d.ACCENT,"\u0301":d.ACCENT,"\u0303":d.WIDEACCENT,"\u0304":d.ACCENT,"\u0306":d.ACCENT,"\u0307":d.ACCENT,"\u0308":d.ACCENT,"\u030C":d.ACCENT,"\u0332":d.WIDEACCENT,"\u0338":d.REL4,"\u2015":[0,0,b.ORD,{stretchy:true}],"\u2017":[0,0,b.ORD,{stretchy:true}],"\u2020":d.BIN3,"\u2021":d.BIN3,"\u20D7":d.ACCENT,"\u2111":d.ORD,"\u2113":d.ORD,"\u2118":d.ORD,"\u211C":d.ORD,"\u2205":d.ORD,"\u221E":d.ORD,"\u2305":d.BIN3,"\u2306":d.BIN3,"\u2322":d.REL4,"\u2323":d.REL4,"\u2329":d.OPEN,"\u232A":d.CLOSE,"\u23AA":d.ORD,"\u23AF":[0,0,b.ORD,{stretchy:true}],"\u23B0":d.OPEN,"\u23B1":d.CLOSE,"\u2500":d.ORD,"\u25EF":d.BIN3,"\u2660":d.ORD,"\u2661":d.ORD,"\u2662":d.ORD,"\u2663":d.ORD,"\u3008":d.OPEN,"\u3009":d.CLOSE,"\uFE37":d.WIDEACCENT,"\uFE38":d.WIDEACCENT}}},{OPTYPES:d});var c=a.mo.prototype.OPTABLE;c.infix["^"]=d.WIDEREL;c.infix._=d.WIDEREL;c.prefix["\u2223"]=d.OPEN;c.prefix["\u2225"]=d.OPEN;c.postfix["\u2223"]=d.CLOSE;c.postfix["\u2225"]=d.CLOSE})(MathJax.ElementJax.mml);MathJax.ElementJax.mml.loadComplete("jax.js");
	MathJax.Hub.Register.LoadHook("[MathJax]/jax/element/mml/jax.js",function(){var c="2.6.1";var a=MathJax.ElementJax.mml,b=MathJax.Hub.config.menuSettings;a.mbase.Augment({toMathML:function(l){var h=(this.inferred&&this.parent.inferRow);if(l==null){l=""}var f=this.type,e=this.toMathMLattributes();if(f==="mspace"){return l+"<"+f+e+" />"}var k=[],j=(this.isToken?"":l+(h?"":"  "));for(var g=0,d=this.data.length;g<d;g++){if(this.data[g]){k.push(this.data[g].toMathML(j))}else{if(!this.isToken&&!this.isChars){k.push(j+"<mrow />")}}}if(this.isToken||this.isChars){return l+"<"+f+e+">"+k.join("")+"</"+f+">"}if(h){return k.join("\n")}if(k.length===0||(k.length===1&&k[0]==="")){return l+"<"+f+e+" />"}return l+"<"+f+e+">\n"+k.join("\n")+"\n"+l+"</"+f+">"},toMathMLattributes:function(){var j=(this.type==="mstyle"?a.math.prototype.defaults:this.defaults);var h=(this.attrNames||a.copyAttributeNames),g=a.skipAttributes,l=a.copyAttributes;var e=[];if(this.type==="math"&&(!this.attr||!this.attr.xmlns)){e.push('xmlns="http://www.w3.org/1998/Math/MathML"')}if(!this.attrNames){for(var k in j){if(!g[k]&&!l[k]&&j.hasOwnProperty(k)){if(this[k]!=null&&this[k]!==j[k]){if(this.Get(k,null,1)!==this[k]){e.push(k+'="'+this.toMathMLattribute(this[k])+'"')}}}}}for(var f=0,d=h.length;f<d;f++){if(l[h[f]]===1&&!j.hasOwnProperty(h[f])){continue}value=(this.attr||{})[h[f]];if(value==null){value=this[h[f]]}if(value!=null){e.push(h[f]+'="'+this.toMathMLquote(value)+'"')}}this.toMathMLclass(e);if(e.length){return" "+e.join(" ")}else{return""}},toMathMLclass:function(d){var f=[];if(this["class"]){f.push(this["class"])}if(this.isa(a.TeXAtom)&&b.texHints){var e=["ORD","OP","BIN","REL","OPEN","CLOSE","PUNCT","INNER","VCENTER"][this.texClass];if(e){f.push("MJX-TeXAtom-"+e);if(e==="OP"&&!this.movablelimits){f.push("MJX-fixedlimits")}}}if(this.mathvariant&&this.toMathMLvariants[this.mathvariant]){f.push("MJX"+this.mathvariant)}if(this.variantForm){f.push("MJX-variant")}if(f.length){d.unshift('class="'+f.join(" ")+'"')}},toMathMLattribute:function(d){if(typeof(d)==="string"&&d.replace(/ /g,"").match(/^(([-+])?(\d+(\.\d*)?|\.\d+))mu$/)){return(RegExp.$2||"")+((1/18)*RegExp.$3).toFixed(3).replace(/\.?0+$/,"")+"em"}else{if(this.toMathMLvariants[d]){return this.toMathMLvariants[d]}}return this.toMathMLquote(d)},toMathMLvariants:{"-tex-caligraphic":a.VARIANT.SCRIPT,"-tex-caligraphic-bold":a.VARIANT.BOLDSCRIPT,"-tex-oldstyle":a.VARIANT.NORMAL,"-tex-oldstyle-bold":a.VARIANT.BOLD,"-tex-mathit":a.VARIANT.ITALIC},toMathMLquote:function(f){f=String(f).split("");for(var g=0,d=f.length;g<d;g++){var k=f[g].charCodeAt(0);if(k<=55295||57344<=k){if(k>126||(k<32&&k!==10&&k!==13&&k!==9)){f[g]="&#x"+k.toString(16).toUpperCase()+";"}else{var j={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[f[g]];if(j){f[g]=j}}}else{if(g+1<d){var h=f[g+1].charCodeAt(0);var e=(((k-55296)<<10)+(h-56320)+65536);f[g]="&#x"+e.toString(16).toUpperCase()+";";f[g+1]="";g++}else{f[g]=""}}}return f.join("")}});a.math.Augment({toMathML:function(d,e){var g;if(d==null){d=""}if(e&&e.originalText&&b.semantics){g=MathJax.InputJax[e.inputJax].annotationEncoding}var n=(this.data[0]&&this.data[0].data.length>1);var p=this.type,k=this.toMathMLattributes();var j=[],o=d+(g?"  "+(n?"  ":""):"")+"  ";for(var h=0,f=this.data.length;h<f;h++){if(this.data[h]){j.push(this.data[h].toMathML(o))}else{j.push(o+"<mrow />")}}if(j.length===0||(j.length===1&&j[0]==="")){if(!g){return"<"+p+k+" />"}j.push(o+"<mrow />")}if(g){if(n){j.unshift(d+"    <mrow>");j.push(d+"    </mrow>")}j.unshift(d+"  <semantics>");var l=e.originalText.replace(/[&<>]/g,function(i){return{">":"&gt;","<":"&lt;","&":"&amp;"}[i]});j.push(d+'    <annotation encoding="'+g+'">'+l+"</annotation>");j.push(d+"  </semantics>")}return d+"<"+p+k+">\n"+j.join("\n")+"\n"+d+"</"+p+">"}});a.msubsup.Augment({toMathML:function(j){var f=this.type;if(this.data[this.sup]==null){f="msub"}if(this.data[this.sub]==null){f="msup"}var e=this.toMathMLattributes();delete this.data[0].inferred;var h=[];for(var g=0,d=this.data.length;g<d;g++){if(this.data[g]){h.push(this.data[g].toMathML(j+"  "))}}return j+"<"+f+e+">\n"+h.join("\n")+"\n"+j+"</"+f+">"}});a.munderover.Augment({toMathML:function(k){var f=this.type;var j=this.data[this.base];if(j&&j.isa(a.TeXAtom)&&j.movablelimits&&!j.Get("displaystyle")){type="msubsup";if(this.data[this.under]==null){f="msup"}if(this.data[this.over]==null){f="msub"}}else{if(this.data[this.under]==null){f="mover"}if(this.data[this.over]==null){f="munder"}}var e=this.toMathMLattributes();delete this.data[0].inferred;var h=[];for(var g=0,d=this.data.length;g<d;g++){if(this.data[g]){h.push(this.data[g].toMathML(k+"  "))}}return k+"<"+f+e+">\n"+h.join("\n")+"\n"+k+"</"+f+">"}});a.TeXAtom.Augment({toMathML:function(e){var d=this.toMathMLattributes();if(!d&&this.data[0].data.length===1){return e.substr(2)+this.data[0].toMathML(e)}return e+"<mrow"+d+">\n"+this.data[0].toMathML(e+"  ")+"\n"+e+"</mrow>"}});a.chars.Augment({toMathML:function(d){return(d||"")+this.toMathMLquote(this.toString())}});a.entity.Augment({toMathML:function(d){return(d||"")+"&"+this.data[0]+";<!-- "+this.toString()+" -->"}});a.xml.Augment({toMathML:function(d){return(d||"")+this.toString()}});MathJax.Hub.Register.StartupHook("TeX mathchoice Ready",function(){a.TeXmathchoice.Augment({toMathML:function(d){return this.Core().toMathML(d)}})});MathJax.Hub.Startup.signal.Post("toMathML Ready")});MathJax.Ajax.loadComplete("[MathJax]/extensions/toMathML.js");
	(function(b,e){var d="2.6.0";var a=b.CombineConfig("TeX.noErrors",{disabled:false,multiLine:true,inlineDelimiters:["",""],style:{"font-size":"90%","text-align":"left",color:"black",padding:"1px 3px",border:"1px solid"}});var c="\u00A0";MathJax.Extension["TeX/noErrors"]={version:d,config:a};b.Register.StartupHook("TeX Jax Ready",function(){var f=MathJax.InputJax.TeX.formatError;MathJax.InputJax.TeX.Augment({formatError:function(j,i,k,g){if(a.disabled){return f.apply(this,arguments)}var h=j.message.replace(/\n.*/,"");b.signal.Post(["TeX Jax - parse error",h,i,k,g]);var m=a.inlineDelimiters;var l=(k||a.multiLine);if(!k){i=m[0]+i+m[1]}if(l){i=i.replace(/ /g,c)}else{i=i.replace(/\n/g," ")}return MathJax.ElementJax.mml.merror(i).With({isError:true,multiLine:l})}})});b.Register.StartupHook("HTML-CSS Jax Config",function(){b.Config({"HTML-CSS":{styles:{".MathJax .noError":b.Insert({"vertical-align":(b.Browser.isMSIE&&a.multiLine?"-2px":"")},a.style)}}})});b.Register.StartupHook("HTML-CSS Jax Ready",function(){var g=MathJax.ElementJax.mml;var h=MathJax.OutputJax["HTML-CSS"];var f=g.math.prototype.toHTML,i=g.merror.prototype.toHTML;g.math.Augment({toHTML:function(j,k){var l=this.data[0];if(l&&l.data[0]&&l.data[0].isError){j.style.fontSize="";j=this.HTMLcreateSpan(j);j.bbox=l.data[0].toHTML(j).bbox}else{j=f.apply(this,arguments)}return j}});g.merror.Augment({toHTML:function(p){if(!this.isError){return i.apply(this,arguments)}p=this.HTMLcreateSpan(p);p.className="noError";if(this.multiLine){p.style.display="inline-block"}var r=this.data[0].data[0].data.join("").split(/\n/);for(var o=0,l=r.length;o<l;o++){h.addText(p,r[o]);if(o!==l-1){h.addElement(p,"br",{isMathJax:true})}}var q=h.getHD(p.parentNode),k=h.getW(p.parentNode);if(l>1){var n=(q.h+q.d)/2,j=h.TeX.x_height/2;p.parentNode.style.verticalAlign=h.Em(q.d+(j-n));q.h=j+n;q.d=n-j}p.bbox={h:q.h,d:q.d,w:k,lw:0,rw:k};return p}})});b.Register.StartupHook("SVG Jax Config",function(){b.Config({SVG:{styles:{".MathJax_SVG .noError":b.Insert({"vertical-align":(b.Browser.isMSIE&&a.multiLine?"-2px":"")},a.style)}}})});b.Register.StartupHook("SVG Jax Ready",function(){var g=MathJax.ElementJax.mml;var f=g.math.prototype.toSVG,h=g.merror.prototype.toSVG;g.math.Augment({toSVG:function(i,j){var k=this.data[0];if(k&&k.data[0]&&k.data[0].isError){i=k.data[0].toSVG(i)}else{i=f.apply(this,arguments)}return i}});g.merror.Augment({toSVG:function(n){if(!this.isError||this.Parent().type!=="math"){return h.apply(this,arguments)}n=e.addElement(n,"span",{className:"noError",isMathJax:true});if(this.multiLine){n.style.display="inline-block"}var o=this.data[0].data[0].data.join("").split(/\n/);for(var l=0,j=o.length;l<j;l++){e.addText(n,o[l]);if(l!==j-1){e.addElement(n,"br",{isMathJax:true})}}if(j>1){var k=n.offsetHeight/2;n.style.verticalAlign=(-k+(k/j))+"px"}return n}})});b.Register.StartupHook("NativeMML Jax Ready",function(){var h=MathJax.ElementJax.mml;var g=MathJax.Extension["TeX/noErrors"].config;var f=h.math.prototype.toNativeMML,i=h.merror.prototype.toNativeMML;h.math.Augment({toNativeMML:function(j){var k=this.data[0];if(k&&k.data[0]&&k.data[0].isError){j=k.data[0].toNativeMML(j)}else{j=f.apply(this,arguments)}return j}});h.merror.Augment({toNativeMML:function(n){if(!this.isError){return i.apply(this,arguments)}n=n.appendChild(document.createElement("span"));var o=this.data[0].data[0].data.join("").split(/\n/);for(var l=0,k=o.length;l<k;l++){n.appendChild(document.createTextNode(o[l]));if(l!==k-1){n.appendChild(document.createElement("br"))}}if(this.multiLine){n.style.display="inline-block";if(k>1){n.style.verticalAlign="middle"}}for(var p in g.style){if(g.style.hasOwnProperty(p)){var j=p.replace(/-./g,function(m){return m.charAt(1).toUpperCase()});n.style[j]=g.style[p]}}return n}})});b.Register.StartupHook("PreviewHTML Jax Config",function(){b.Config({PreviewHTML:{styles:{".MathJax_PHTML .noError":b.Insert({"vertical-align":(b.Browser.isMSIE&&a.multiLine?"-2px":"")},a.style)}}})});b.Register.StartupHook("PreviewHTML Jax Ready",function(){var f=MathJax.ElementJax.mml;var h=MathJax.HTML;var g=f.merror.prototype.toPreviewHTML;f.merror.Augment({toPreviewHTML:function(l){if(!this.isError){return g.apply(this,arguments)}l=this.PHTMLcreateSpan(l);l.className="noError";if(this.multiLine){l.style.display="inline-block"}var n=this.data[0].data[0].data.join("").split(/\n/);for(var k=0,j=n.length;k<j;k++){h.addText(l,n[k]);if(k!==j-1){h.addElement(l,"br",{isMathJax:true})}}return l}})});b.Register.StartupHook("CommonHTML Jax Config",function(){b.Config({CommonHTML:{styles:{".mjx-chtml .mjx-noError":b.Insert({"line-height":1.2,"vertical-align":(b.Browser.isMSIE&&a.multiLine?"-2px":"")},a.style)}}})});b.Register.StartupHook("CommonHTML Jax Ready",function(){var f=MathJax.ElementJax.mml;var g=MathJax.OutputJax.CommonHTML;var i=MathJax.HTML;var h=f.merror.prototype.toCommonHTML;f.merror.Augment({toCommonHTML:function(n){if(!this.isError){return h.apply(this,arguments)}n=g.addElement(n,"mjx-noError");var p=this.data[0].data[0].data.join("").split(/\n/);for(var k=0,j=p.length;k<j;k++){i.addText(n,p[k]);if(k!==j-1){g.addElement(n,"br",{isMathJax:true})}}var o=this.CHTML=g.BBOX.zero();o.w=(n.offsetWidth)/g.em;if(j>1){var l=1.2*j/2;o.h=l+0.25;o.d=l-0.25;n.style.verticalAlign=g.Em(0.45-l)}else{o.h=1;o.d=0.2+2/g.em}return n}})});b.Startup.signal.Post("TeX noErrors Ready")})(MathJax.Hub,MathJax.HTML);MathJax.Ajax.loadComplete("[MathJax]/extensions/TeX/noErrors.js");
	MathJax.Extension["TeX/noUndefined"]={version:"2.6.0",config:MathJax.Hub.CombineConfig("TeX.noUndefined",{disabled:false,attributes:{mathcolor:"red"}})};MathJax.Hub.Register.StartupHook("TeX Jax Ready",function(){var b=MathJax.Extension["TeX/noUndefined"].config;var a=MathJax.ElementJax.mml;var c=MathJax.InputJax.TeX.Parse.prototype.csUndefined;MathJax.InputJax.TeX.Parse.Augment({csUndefined:function(d){if(b.disabled){return c.apply(this,arguments)}MathJax.Hub.signal.Post(["TeX Jax - undefined control sequence",d]);this.Push(a.mtext(d).With(b.attributes))}});MathJax.Hub.Startup.signal.Post("TeX noUndefined Ready")});MathJax.Ajax.loadComplete("[MathJax]/extensions/TeX/noUndefined.js");
	(function(d,c,i){var h,g="\u00A0";var j=function(l){return MathJax.Localization._.apply(MathJax.Localization,[["TeX",l]].concat([].slice.call(arguments,1)))};var e=MathJax.Object.Subclass({Init:function(m,l){this.global={isInner:l};this.data=[b.start(this.global)];if(m){this.data[0].env=m}this.env=this.data[0].env},Push:function(){var n,l,o,p;for(n=0,l=arguments.length;n<l;n++){o=arguments[n];if(!o){continue}if(o instanceof h.mbase){o=b.mml(o)}o.global=this.global;p=(this.data.length?this.Top().checkItem(o):true);if(p instanceof Array){this.Pop();this.Push.apply(this,p)}else{if(p instanceof b){this.Pop();this.Push(p)}else{if(p){this.data.push(o);if(o.env){for(var q in this.env){if(this.env.hasOwnProperty(q)){o.env[q]=this.env[q]}}this.env=o.env}else{o.env=this.env}}}}}},Pop:function(){var l=this.data.pop();if(!l.isOpen){delete l.env}this.env=(this.data.length?this.Top().env:{});return l},Top:function(l){if(l==null){l=1}if(this.data.length<l){return null}return this.data[this.data.length-l]},Prev:function(l){var m=this.Top();if(l){return m.data[m.data.length-1]}else{return m.Pop()}},toString:function(){return"stack[\n  "+this.data.join("\n  ")+"\n]"}});var b=e.Item=MathJax.Object.Subclass({type:"base",endError:["ExtraOpenMissingClose","Extra open brace or missing close brace"],closeError:["ExtraCloseMissingOpen","Extra close brace or missing open brace"],rightError:["MissingLeftExtraRight","Missing \\left or extra \\right"],Init:function(){if(this.isOpen){this.env={}}this.data=[];this.Push.apply(this,arguments)},Push:function(){this.data.push.apply(this.data,arguments)},Pop:function(){return this.data.pop()},mmlData:function(l,m){if(l==null){l=true}if(this.data.length===1&&!m){return this.data[0]}return h.mrow.apply(h,this.data).With((l?{inferred:true}:{}))},checkItem:function(l){if(l.type==="over"&&this.isOpen){l.num=this.mmlData(false);this.data=[]}if(l.type==="cell"&&this.isOpen){if(l.linebreak){return false}d.Error(["Misplaced","Misplaced %1",l.name])}if(l.isClose&&this[l.type+"Error"]){d.Error(this[l.type+"Error"])}if(!l.isNotStack){return true}this.Push(l.data[0]);return false},With:function(l){for(var m in l){if(l.hasOwnProperty(m)){this[m]=l[m]}}return this},toString:function(){return this.type+"["+this.data.join("; ")+"]"}});b.start=b.Subclass({type:"start",isOpen:true,Init:function(l){this.SUPER(arguments).Init.call(this);this.global=l},checkItem:function(l){if(l.type==="stop"){return b.mml(this.mmlData())}return this.SUPER(arguments).checkItem.call(this,l)}});b.stop=b.Subclass({type:"stop",isClose:true});b.open=b.Subclass({type:"open",isOpen:true,stopError:["ExtraOpenMissingClose","Extra open brace or missing close brace"],checkItem:function(m){if(m.type==="close"){var l=this.mmlData();return b.mml(h.TeXAtom(l))}return this.SUPER(arguments).checkItem.call(this,m)}});b.close=b.Subclass({type:"close",isClose:true});b.prime=b.Subclass({type:"prime",checkItem:function(l){if(this.data[0].type!=="msubsup"){return[h.msup(this.data[0],this.data[1]),l]}this.data[0].SetData(this.data[0].sup,this.data[1]);return[this.data[0],l]}});b.subsup=b.Subclass({type:"subsup",stopError:["MissingScript","Missing superscript or subscript argument"],supError:["MissingOpenForSup","Missing open brace for superscript"],subError:["MissingOpenForSub","Missing open brace for subscript"],checkItem:function(l){if(l.type==="open"||l.type==="left"){return true}if(l.type==="mml"){if(this.primes){if(this.position!==2){this.data[0].SetData(2,this.primes)}else{l.data[0]=h.mrow(this.primes.With({variantForm:true}),l.data[0])}}this.data[0].SetData(this.position,l.data[0]);if(this.movesupsub!=null){this.data[0].movesupsub=this.movesupsub}return b.mml(this.data[0])}if(this.SUPER(arguments).checkItem.call(this,l)){d.Error(this[["","subError","supError"][this.position]])}},Pop:function(){}});b.over=b.Subclass({type:"over",isClose:true,name:"\\over",checkItem:function(n,l){if(n.type==="over"){d.Error(["AmbiguousUseOf","Ambiguous use of %1",n.name])}if(n.isClose){var m=h.mfrac(this.num,this.mmlData(false));if(this.thickness!=null){m.linethickness=this.thickness}if(this.open||this.close){m.texWithDelims=true;m=d.fixedFence(this.open,m,this.close)}return[b.mml(m),n]}return this.SUPER(arguments).checkItem.call(this,n)},toString:function(){return"over["+this.num+" / "+this.data.join("; ")+"]"}});b.left=b.Subclass({type:"left",isOpen:true,delim:"(",stopError:["ExtraLeftMissingRight","Extra \\left or missing \\right"],checkItem:function(l){if(l.type==="right"){return b.mml(d.fenced(this.delim,this.mmlData(),l.delim))}return this.SUPER(arguments).checkItem.call(this,l)}});b.right=b.Subclass({type:"right",isClose:true,delim:")"});b.begin=b.Subclass({type:"begin",isOpen:true,checkItem:function(l){if(l.type==="end"){if(l.name!==this.name){d.Error(["EnvBadEnd","\\begin{%1} ended with \\end{%2}",this.name,l.name])}if(!this.end){return b.mml(this.mmlData())}return this.parse[this.end].call(this.parse,this,this.data)}if(l.type==="stop"){d.Error(["EnvMissingEnd","Missing \\end{%1}",this.name])}return this.SUPER(arguments).checkItem.call(this,l)}});b.end=b.Subclass({type:"end",isClose:true});b.style=b.Subclass({type:"style",checkItem:function(m){if(!m.isClose){return this.SUPER(arguments).checkItem.call(this,m)}var l=h.mstyle.apply(h,this.data).With(this.styles);return[b.mml(l),m]}});b.position=b.Subclass({type:"position",checkItem:function(m){if(m.isClose){d.Error(["MissingBoxFor","Missing box for %1",this.name])}if(m.isNotStack){var l=m.mmlData();switch(this.move){case"vertical":l=h.mpadded(l).With({height:this.dh,depth:this.dd,voffset:this.dh});return[b.mml(l)];case"horizontal":return[b.mml(this.left),m,b.mml(this.right)]}}return this.SUPER(arguments).checkItem.call(this,m)}});b.array=b.Subclass({type:"array",isOpen:true,arraydef:{},Init:function(){this.table=[];this.row=[];this.env={};this.frame=[];this.hfill=[];this.SUPER(arguments).Init.apply(this,arguments)},checkItem:function(m){if(m.isClose&&m.type!=="over"){if(m.isEntry){this.EndEntry();this.clearEnv();return false}if(m.isCR){this.EndEntry();this.EndRow();this.clearEnv();return false}this.EndTable();this.clearEnv();var n=this.arraydef.scriptlevel;delete this.arraydef.scriptlevel;var l=h.mtable.apply(h,this.table).With(this.arraydef);if(this.frame.length===4){l.frame=(this.frame.dashed?"dashed":"solid")}else{if(this.frame.length){l.hasFrame=true;if(this.arraydef.rowlines){this.arraydef.rowlines=this.arraydef.rowlines.replace(/none( none)+$/,"none")}l=h.menclose(l).With({notation:this.frame.join(" "),isFrame:true});if((this.arraydef.columnlines||"none")!="none"||(this.arraydef.rowlines||"none")!="none"){l.padding=0}}}if(n){l=h.mstyle(l).With({scriptlevel:n})}if(this.open||this.close){l=d.fenced(this.open,l,this.close)}l=b.mml(l);if(this.requireClose){if(m.type==="close"){return l}d.Error(["MissingCloseBrace","Missing close brace"])}return[l,m]}return this.SUPER(arguments).checkItem.call(this,m)},EndEntry:function(){var l=h.mtd.apply(h,this.data);if(this.hfill.length){if(this.hfill[0]===0){l.columnalign="right"}if(this.hfill[this.hfill.length-1]===this.data.length){l.columnalign=(l.columnalign?"center":"left")}}this.row.push(l);this.data=[];this.hfill=[]},EndRow:function(){var l=h.mtr;if(this.isNumbered&&this.row.length===3){this.row.unshift(this.row.pop());l=h.mlabeledtr}this.table.push(l.apply(h,this.row));this.row=[]},EndTable:function(){if(this.data.length||this.row.length){this.EndEntry();this.EndRow()}this.checkLines()},checkLines:function(){if(this.arraydef.rowlines){var l=this.arraydef.rowlines.split(/ /);if(l.length===this.table.length){this.frame.push("bottom");l.pop();this.arraydef.rowlines=l.join(" ")}else{if(l.length<this.table.length-1){this.arraydef.rowlines+=" none"}}}if(this.rowspacing){var m=this.arraydef.rowspacing.split(/ /);while(m.length<this.table.length){m.push(this.rowspacing+"em")}this.arraydef.rowspacing=m.join(" ")}},clearEnv:function(){for(var l in this.env){if(this.env.hasOwnProperty(l)){delete this.env[l]}}}});b.cell=b.Subclass({type:"cell",isClose:true});b.mml=b.Subclass({type:"mml",isNotStack:true,Add:function(){this.data.push.apply(this.data,arguments);return this}});b.fn=b.Subclass({type:"fn",checkItem:function(m){if(this.data[0]){if(m.isOpen){return true}if(m.type!=="fn"){if(m.type!=="mml"||!m.data[0]){return[this.data[0],m]}if(m.data[0].isa(h.mspace)){return[this.data[0],m]}var l=m.data[0];if(l.isEmbellished()){l=l.CoreMO()}if([0,0,1,1,0,1,1,0,0,0][l.Get("texClass")]){return[this.data[0],m]}}return[this.data[0],h.mo(h.entity("#x2061")).With({texClass:h.TEXCLASS.NONE}),m]}return this.SUPER(arguments).checkItem.apply(this,arguments)}});b.not=b.Subclass({type:"not",checkItem:function(m){var l,n;if(m.type==="open"||m.type==="left"){return true}if(m.type==="mml"&&m.data[0].type.match(/^(mo|mi|mtext)$/)){l=m.data[0],n=l.data.join("");if(n.length===1&&!l.movesupsub){n=b.not.remap[n.charCodeAt(0)];if(n){l.SetData(0,h.chars(String.fromCharCode(n)))}else{l.Append(h.chars("\u0338"))}return m}}l=h.mpadded(h.mtext("\u29F8")).With({width:0});l=h.TeXAtom(l).With({texClass:h.TEXCLASS.REL});return[l,m]}});b.not.remap={8592:8602,8594:8603,8596:8622,8656:8653,8658:8655,8660:8654,8712:8713,8715:8716,8739:8740,8741:8742,8764:8769,126:8769,8771:8772,8773:8775,8776:8777,8781:8813,61:8800,8801:8802,60:8814,62:8815,8804:8816,8805:8817,8818:8820,8819:8821,8822:8824,8823:8825,8826:8832,8827:8833,8834:8836,8835:8837,8838:8840,8839:8841,8866:8876,8872:8877,8873:8878,8875:8879,8828:8928,8829:8929,8849:8930,8850:8931,8882:8938,8883:8939,8884:8940,8885:8941,8707:8708};b.dots=b.Subclass({type:"dots",checkItem:function(m){if(m.type==="open"||m.type==="left"){return true}var n=this.ldots;if(m.type==="mml"&&m.data[0].isEmbellished()){var l=m.data[0].CoreMO().Get("texClass");if(l===h.TEXCLASS.BIN||l===h.TEXCLASS.REL){n=this.cdots}}return[n,m]}});var f={Add:function(l,o,n){if(!o){o=this}for(var m in l){if(l.hasOwnProperty(m)){if(typeof l[m]==="object"&&!(l[m] instanceof Array)&&(typeof o[m]==="object"||typeof o[m]==="function")){this.Add(l[m],o[m],l[m],n)}else{if(!o[m]||!o[m].isUser||!n){o[m]=l[m]}}}}return o}};var k=function(){h=MathJax.ElementJax.mml;c.Insert(f,{letter:/[a-z]/i,digit:/[0-9.]/,number:/^(?:[0-9]+(?:\{,\}[0-9]{3})*(?:\.[0-9]*)*|\.[0-9]+)/,special:{"\\":"ControlSequence","{":"Open","}":"Close","~":"Tilde","^":"Superscript",_:"Subscript"," ":"Space","\t":"Space","\r":"Space","\n":"Space","'":"Prime","%":"Comment","&":"Entry","#":"Hash","\u00A0":"Space","\u2019":"Prime"},remap:{"-":"2212","*":"2217","`":"2018"},mathchar0mi:{alpha:"03B1",beta:"03B2",gamma:"03B3",delta:"03B4",epsilon:"03F5",zeta:"03B6",eta:"03B7",theta:"03B8",iota:"03B9",kappa:"03BA",lambda:"03BB",mu:"03BC",nu:"03BD",xi:"03BE",omicron:"03BF",pi:"03C0",rho:"03C1",sigma:"03C3",tau:"03C4",upsilon:"03C5",phi:"03D5",chi:"03C7",psi:"03C8",omega:"03C9",varepsilon:"03B5",vartheta:"03D1",varpi:"03D6",varrho:"03F1",varsigma:"03C2",varphi:"03C6",S:["00A7",{mathvariant:h.VARIANT.NORMAL}],aleph:["2135",{mathvariant:h.VARIANT.NORMAL}],hbar:["210F",{variantForm:true}],imath:"0131",jmath:"0237",ell:"2113",wp:["2118",{mathvariant:h.VARIANT.NORMAL}],Re:["211C",{mathvariant:h.VARIANT.NORMAL}],Im:["2111",{mathvariant:h.VARIANT.NORMAL}],partial:["2202",{mathvariant:h.VARIANT.NORMAL}],infty:["221E",{mathvariant:h.VARIANT.NORMAL}],prime:["2032",{mathvariant:h.VARIANT.NORMAL,variantForm:true}],emptyset:["2205",{mathvariant:h.VARIANT.NORMAL}],nabla:["2207",{mathvariant:h.VARIANT.NORMAL}],top:["22A4",{mathvariant:h.VARIANT.NORMAL}],bot:["22A5",{mathvariant:h.VARIANT.NORMAL}],angle:["2220",{mathvariant:h.VARIANT.NORMAL}],triangle:["25B3",{mathvariant:h.VARIANT.NORMAL}],backslash:["2216",{mathvariant:h.VARIANT.NORMAL,variantForm:true}],forall:["2200",{mathvariant:h.VARIANT.NORMAL}],exists:["2203",{mathvariant:h.VARIANT.NORMAL}],neg:["00AC",{mathvariant:h.VARIANT.NORMAL}],lnot:["00AC",{mathvariant:h.VARIANT.NORMAL}],flat:["266D",{mathvariant:h.VARIANT.NORMAL}],natural:["266E",{mathvariant:h.VARIANT.NORMAL}],sharp:["266F",{mathvariant:h.VARIANT.NORMAL}],clubsuit:["2663",{mathvariant:h.VARIANT.NORMAL}],diamondsuit:["2662",{mathvariant:h.VARIANT.NORMAL}],heartsuit:["2661",{mathvariant:h.VARIANT.NORMAL}],spadesuit:["2660",{mathvariant:h.VARIANT.NORMAL}]},mathchar0mo:{surd:"221A",coprod:["2210",{texClass:h.TEXCLASS.OP,movesupsub:true}],bigvee:["22C1",{texClass:h.TEXCLASS.OP,movesupsub:true}],bigwedge:["22C0",{texClass:h.TEXCLASS.OP,movesupsub:true}],biguplus:["2A04",{texClass:h.TEXCLASS.OP,movesupsub:true}],bigcap:["22C2",{texClass:h.TEXCLASS.OP,movesupsub:true}],bigcup:["22C3",{texClass:h.TEXCLASS.OP,movesupsub:true}],"int":["222B",{texClass:h.TEXCLASS.OP}],intop:["222B",{texClass:h.TEXCLASS.OP,movesupsub:true,movablelimits:true}],iint:["222C",{texClass:h.TEXCLASS.OP}],iiint:["222D",{texClass:h.TEXCLASS.OP}],prod:["220F",{texClass:h.TEXCLASS.OP,movesupsub:true}],sum:["2211",{texClass:h.TEXCLASS.OP,movesupsub:true}],bigotimes:["2A02",{texClass:h.TEXCLASS.OP,movesupsub:true}],bigoplus:["2A01",{texClass:h.TEXCLASS.OP,movesupsub:true}],bigodot:["2A00",{texClass:h.TEXCLASS.OP,movesupsub:true}],oint:["222E",{texClass:h.TEXCLASS.OP}],bigsqcup:["2A06",{texClass:h.TEXCLASS.OP,movesupsub:true}],smallint:["222B",{largeop:false}],triangleleft:"25C3",triangleright:"25B9",bigtriangleup:"25B3",bigtriangledown:"25BD",wedge:"2227",land:"2227",vee:"2228",lor:"2228",cap:"2229",cup:"222A",ddagger:"2021",dagger:"2020",sqcap:"2293",sqcup:"2294",uplus:"228E",amalg:"2A3F",diamond:"22C4",bullet:"2219",wr:"2240",div:"00F7",odot:["2299",{largeop:false}],oslash:["2298",{largeop:false}],otimes:["2297",{largeop:false}],ominus:["2296",{largeop:false}],oplus:["2295",{largeop:false}],mp:"2213",pm:"00B1",circ:"2218",bigcirc:"25EF",setminus:["2216",{variantForm:true}],cdot:"22C5",ast:"2217",times:"00D7",star:"22C6",propto:"221D",sqsubseteq:"2291",sqsupseteq:"2292",parallel:"2225",mid:"2223",dashv:"22A3",vdash:"22A2",leq:"2264",le:"2264",geq:"2265",ge:"2265",lt:"003C",gt:"003E",succ:"227B",prec:"227A",approx:"2248",succeq:"2AB0",preceq:"2AAF",supset:"2283",subset:"2282",supseteq:"2287",subseteq:"2286","in":"2208",ni:"220B",notin:"2209",owns:"220B",gg:"226B",ll:"226A",sim:"223C",simeq:"2243",perp:"22A5",equiv:"2261",asymp:"224D",smile:"2323",frown:"2322",ne:"2260",neq:"2260",cong:"2245",doteq:"2250",bowtie:"22C8",models:"22A8",notChar:"29F8",Leftrightarrow:"21D4",Leftarrow:"21D0",Rightarrow:"21D2",leftrightarrow:"2194",leftarrow:"2190",gets:"2190",rightarrow:"2192",to:"2192",mapsto:"21A6",leftharpoonup:"21BC",leftharpoondown:"21BD",rightharpoonup:"21C0",rightharpoondown:"21C1",nearrow:"2197",searrow:"2198",nwarrow:"2196",swarrow:"2199",rightleftharpoons:"21CC",hookrightarrow:"21AA",hookleftarrow:"21A9",longleftarrow:"27F5",Longleftarrow:"27F8",longrightarrow:"27F6",Longrightarrow:"27F9",Longleftrightarrow:"27FA",longleftrightarrow:"27F7",longmapsto:"27FC",ldots:"2026",cdots:"22EF",vdots:"22EE",ddots:"22F1",dotsc:"2026",dotsb:"22EF",dotsm:"22EF",dotsi:"22EF",dotso:"2026",ldotp:["002E",{texClass:h.TEXCLASS.PUNCT}],cdotp:["22C5",{texClass:h.TEXCLASS.PUNCT}],colon:["003A",{texClass:h.TEXCLASS.PUNCT}]},mathchar7:{Gamma:"0393",Delta:"0394",Theta:"0398",Lambda:"039B",Xi:"039E",Pi:"03A0",Sigma:"03A3",Upsilon:"03A5",Phi:"03A6",Psi:"03A8",Omega:"03A9",_:"005F","#":"0023","$":"0024","%":"0025","&":"0026",And:"0026"},delimiter:{"(":"(",")":")","[":"[","]":"]","<":"27E8",">":"27E9","\\lt":"27E8","\\gt":"27E9","/":"/","|":["|",{texClass:h.TEXCLASS.ORD}],".":"","\\\\":"\\","\\lmoustache":"23B0","\\rmoustache":"23B1","\\lgroup":"27EE","\\rgroup":"27EF","\\arrowvert":"23D0","\\Arrowvert":"2016","\\bracevert":"23AA","\\Vert":["2225",{texClass:h.TEXCLASS.ORD}],"\\|":["2225",{texClass:h.TEXCLASS.ORD}],"\\vert":["|",{texClass:h.TEXCLASS.ORD}],"\\uparrow":"2191","\\downarrow":"2193","\\updownarrow":"2195","\\Uparrow":"21D1","\\Downarrow":"21D3","\\Updownarrow":"21D5","\\backslash":"\\","\\rangle":"27E9","\\langle":"27E8","\\rbrace":"}","\\lbrace":"{","\\}":"}","\\{":"{","\\rceil":"2309","\\lceil":"2308","\\rfloor":"230B","\\lfloor":"230A","\\lbrack":"[","\\rbrack":"]"},macros:{displaystyle:["SetStyle","D",true,0],textstyle:["SetStyle","T",false,0],scriptstyle:["SetStyle","S",false,1],scriptscriptstyle:["SetStyle","SS",false,2],rm:["SetFont",h.VARIANT.NORMAL],mit:["SetFont",h.VARIANT.ITALIC],oldstyle:["SetFont",h.VARIANT.OLDSTYLE],cal:["SetFont",h.VARIANT.CALIGRAPHIC],it:["SetFont","-tex-mathit"],bf:["SetFont",h.VARIANT.BOLD],bbFont:["SetFont",h.VARIANT.DOUBLESTRUCK],scr:["SetFont",h.VARIANT.SCRIPT],frak:["SetFont",h.VARIANT.FRAKTUR],sf:["SetFont",h.VARIANT.SANSSERIF],tt:["SetFont",h.VARIANT.MONOSPACE],tiny:["SetSize",0.5],Tiny:["SetSize",0.6],scriptsize:["SetSize",0.7],small:["SetSize",0.85],normalsize:["SetSize",1],large:["SetSize",1.2],Large:["SetSize",1.44],LARGE:["SetSize",1.73],huge:["SetSize",2.07],Huge:["SetSize",2.49],arcsin:["NamedFn"],arccos:["NamedFn"],arctan:["NamedFn"],arg:["NamedFn"],cos:["NamedFn"],cosh:["NamedFn"],cot:["NamedFn"],coth:["NamedFn"],csc:["NamedFn"],deg:["NamedFn"],det:"NamedOp",dim:["NamedFn"],exp:["NamedFn"],gcd:"NamedOp",hom:["NamedFn"],inf:"NamedOp",ker:["NamedFn"],lg:["NamedFn"],lim:"NamedOp",liminf:["NamedOp","lim&thinsp;inf"],limsup:["NamedOp","lim&thinsp;sup"],ln:["NamedFn"],log:["NamedFn"],max:"NamedOp",min:"NamedOp",Pr:"NamedOp",sec:["NamedFn"],sin:["NamedFn"],sinh:["NamedFn"],sup:"NamedOp",tan:["NamedFn"],tanh:["NamedFn"],limits:["Limits",1],nolimits:["Limits",0],overline:["UnderOver","00AF",null,1],underline:["UnderOver","005F"],overbrace:["UnderOver","23DE",1],underbrace:["UnderOver","23DF",1],overparen:["UnderOver","23DC"],underparen:["UnderOver","23DD"],overrightarrow:["UnderOver","2192"],underrightarrow:["UnderOver","2192"],overleftarrow:["UnderOver","2190"],underleftarrow:["UnderOver","2190"],overleftrightarrow:["UnderOver","2194"],underleftrightarrow:["UnderOver","2194"],overset:"Overset",underset:"Underset",stackrel:["Macro","\\mathrel{\\mathop{#2}\\limits^{#1}}",2],over:"Over",overwithdelims:"Over",atop:"Over",atopwithdelims:"Over",above:"Over",abovewithdelims:"Over",brace:["Over","{","}"],brack:["Over","[","]"],choose:["Over","(",")"],frac:"Frac",sqrt:"Sqrt",root:"Root",uproot:["MoveRoot","upRoot"],leftroot:["MoveRoot","leftRoot"],left:"LeftRight",right:"LeftRight",middle:"Middle",llap:"Lap",rlap:"Lap",raise:"RaiseLower",lower:"RaiseLower",moveleft:"MoveLeftRight",moveright:"MoveLeftRight",",":["Spacer",h.LENGTH.THINMATHSPACE],":":["Spacer",h.LENGTH.MEDIUMMATHSPACE],">":["Spacer",h.LENGTH.MEDIUMMATHSPACE],";":["Spacer",h.LENGTH.THICKMATHSPACE],"!":["Spacer",h.LENGTH.NEGATIVETHINMATHSPACE],enspace:["Spacer",".5em"],quad:["Spacer","1em"],qquad:["Spacer","2em"],thinspace:["Spacer",h.LENGTH.THINMATHSPACE],negthinspace:["Spacer",h.LENGTH.NEGATIVETHINMATHSPACE],hskip:"Hskip",hspace:"Hskip",kern:"Hskip",mskip:"Hskip",mspace:"Hskip",mkern:"Hskip",Rule:["Rule"],Space:["Rule","blank"],big:["MakeBig",h.TEXCLASS.ORD,0.85],Big:["MakeBig",h.TEXCLASS.ORD,1.15],bigg:["MakeBig",h.TEXCLASS.ORD,1.45],Bigg:["MakeBig",h.TEXCLASS.ORD,1.75],bigl:["MakeBig",h.TEXCLASS.OPEN,0.85],Bigl:["MakeBig",h.TEXCLASS.OPEN,1.15],biggl:["MakeBig",h.TEXCLASS.OPEN,1.45],Biggl:["MakeBig",h.TEXCLASS.OPEN,1.75],bigr:["MakeBig",h.TEXCLASS.CLOSE,0.85],Bigr:["MakeBig",h.TEXCLASS.CLOSE,1.15],biggr:["MakeBig",h.TEXCLASS.CLOSE,1.45],Biggr:["MakeBig",h.TEXCLASS.CLOSE,1.75],bigm:["MakeBig",h.TEXCLASS.REL,0.85],Bigm:["MakeBig",h.TEXCLASS.REL,1.15],biggm:["MakeBig",h.TEXCLASS.REL,1.45],Biggm:["MakeBig",h.TEXCLASS.REL,1.75],mathord:["TeXAtom",h.TEXCLASS.ORD],mathop:["TeXAtom",h.TEXCLASS.OP],mathopen:["TeXAtom",h.TEXCLASS.OPEN],mathclose:["TeXAtom",h.TEXCLASS.CLOSE],mathbin:["TeXAtom",h.TEXCLASS.BIN],mathrel:["TeXAtom",h.TEXCLASS.REL],mathpunct:["TeXAtom",h.TEXCLASS.PUNCT],mathinner:["TeXAtom",h.TEXCLASS.INNER],vcenter:["TeXAtom",h.TEXCLASS.VCENTER],mathchoice:["Extension","mathchoice"],buildrel:"BuildRel",hbox:["HBox",0],text:"HBox",mbox:["HBox",0],fbox:"FBox",strut:"Strut",mathstrut:["Macro","\\vphantom{(}"],phantom:"Phantom",vphantom:["Phantom",1,0],hphantom:["Phantom",0,1],smash:"Smash",acute:["Accent","00B4"],grave:["Accent","0060"],ddot:["Accent","00A8"],tilde:["Accent","007E"],bar:["Accent","00AF"],breve:["Accent","02D8"],check:["Accent","02C7"],hat:["Accent","005E"],vec:["Accent","2192"],dot:["Accent","02D9"],widetilde:["Accent","007E",1],widehat:["Accent","005E",1],matrix:"Matrix",array:"Matrix",pmatrix:["Matrix","(",")"],cases:["Matrix","{","","left left",null,".1em",null,true],eqalign:["Matrix",null,null,"right left",h.LENGTH.THICKMATHSPACE,".5em","D"],displaylines:["Matrix",null,null,"center",null,".5em","D"],cr:"Cr","\\":"CrLaTeX",newline:"Cr",hline:["HLine","solid"],hdashline:["HLine","dashed"],eqalignno:["Matrix",null,null,"right left",h.LENGTH.THICKMATHSPACE,".5em","D",null,"right"],leqalignno:["Matrix",null,null,"right left",h.LENGTH.THICKMATHSPACE,".5em","D",null,"left"],hfill:"HFill",hfil:"HFill",hfilll:"HFill",bmod:["Macro",'\\mmlToken{mo}[lspace="thickmathspace" rspace="thickmathspace"]{mod}'],pmod:["Macro","\\pod{\\mmlToken{mi}{mod}\\kern 6mu #1}",1],mod:["Macro","\\mathchoice{\\kern18mu}{\\kern12mu}{\\kern12mu}{\\kern12mu}\\mmlToken{mi}{mod}\\,\\,#1",1],pod:["Macro","\\mathchoice{\\kern18mu}{\\kern8mu}{\\kern8mu}{\\kern8mu}(#1)",1],iff:["Macro","\\;\\Longleftrightarrow\\;"],skew:["Macro","{{#2{#3\\mkern#1mu}\\mkern-#1mu}{}}",3],mathcal:["Macro","{\\cal #1}",1],mathscr:["Macro","{\\scr #1}",1],mathrm:["Macro","{\\rm #1}",1],mathbf:["Macro","{\\bf #1}",1],mathbb:["Macro","{\\bbFont #1}",1],Bbb:["Macro","{\\bbFont #1}",1],mathit:["Macro","{\\it #1}",1],mathfrak:["Macro","{\\frak #1}",1],mathsf:["Macro","{\\sf #1}",1],mathtt:["Macro","{\\tt #1}",1],textrm:["Macro","\\mathord{\\rm\\text{#1}}",1],textit:["Macro","\\mathord{\\it\\text{#1}}",1],textbf:["Macro","\\mathord{\\bf\\text{#1}}",1],textsf:["Macro","\\mathord{\\sf\\text{#1}}",1],texttt:["Macro","\\mathord{\\tt\\text{#1}}",1],pmb:["Macro","\\rlap{#1}\\kern1px{#1}",1],TeX:["Macro","T\\kern-.14em\\lower.5ex{E}\\kern-.115em X"],LaTeX:["Macro","L\\kern-.325em\\raise.21em{\\scriptstyle{A}}\\kern-.17em\\TeX"]," ":["Macro","\\text{ }"],not:"Not",dots:"Dots",space:"Tilde","\u00A0":"Tilde",begin:"BeginEnd",end:"BeginEnd",newcommand:["Extension","newcommand"],renewcommand:["Extension","newcommand"],newenvironment:["Extension","newcommand"],renewenvironment:["Extension","newcommand"],def:["Extension","newcommand"],let:["Extension","newcommand"],verb:["Extension","verb"],boldsymbol:["Extension","boldsymbol"],tag:["Extension","AMSmath"],notag:["Extension","AMSmath"],label:["Extension","AMSmath"],ref:["Extension","AMSmath"],eqref:["Extension","AMSmath"],nonumber:["Macro","\\notag"],unicode:["Extension","unicode"],color:"Color",href:["Extension","HTML"],"class":["Extension","HTML"],style:["Extension","HTML"],cssId:["Extension","HTML"],bbox:["Extension","bbox"],mmlToken:"MmlToken",require:"Require"},environment:{array:["AlignedArray"],matrix:["Array",null,null,null,"c"],pmatrix:["Array",null,"(",")","c"],bmatrix:["Array",null,"[","]","c"],Bmatrix:["Array",null,"\\{","\\}","c"],vmatrix:["Array",null,"\\vert","\\vert","c"],Vmatrix:["Array",null,"\\Vert","\\Vert","c"],cases:["Array",null,"\\{",".","ll",null,".2em","T"],equation:[null,"Equation"],"equation*":[null,"Equation"],eqnarray:["ExtensionEnv",null,"AMSmath"],"eqnarray*":["ExtensionEnv",null,"AMSmath"],align:["ExtensionEnv",null,"AMSmath"],"align*":["ExtensionEnv",null,"AMSmath"],aligned:["ExtensionEnv",null,"AMSmath"],multline:["ExtensionEnv",null,"AMSmath"],"multline*":["ExtensionEnv",null,"AMSmath"],split:["ExtensionEnv",null,"AMSmath"],gather:["ExtensionEnv",null,"AMSmath"],"gather*":["ExtensionEnv",null,"AMSmath"],gathered:["ExtensionEnv",null,"AMSmath"],alignat:["ExtensionEnv",null,"AMSmath"],"alignat*":["ExtensionEnv",null,"AMSmath"],alignedat:["ExtensionEnv",null,"AMSmath"]},p_height:1.2/0.85});if(this.config.Macros){var l=this.config.Macros;for(var m in l){if(l.hasOwnProperty(m)){if(typeof(l[m])==="string"){f.macros[m]=["Macro",l[m]]}else{f.macros[m]=["Macro"].concat(l[m])}f.macros[m].isUser=true}}}};var a=MathJax.Object.Subclass({Init:function(m,n){this.string=m;this.i=0;this.macroCount=0;var l;if(n){l={};for(var o in n){if(n.hasOwnProperty(o)){l[o]=n[o]}}}this.stack=d.Stack(l,!!n);this.Parse();this.Push(b.stop())},Parse:function(){var m,l;while(this.i<this.string.length){m=this.string.charAt(this.i++);l=m.charCodeAt(0);if(l>=55296&&l<56320){m+=this.string.charAt(this.i++)}if(f.special[m]){this[f.special[m]](m)}else{if(f.letter.test(m)){this.Variable(m)}else{if(f.digit.test(m)){this.Number(m)}else{this.Other(m)}}}}},Push:function(){this.stack.Push.apply(this.stack,arguments)},mml:function(){if(this.stack.Top().type!=="mml"){return null}return this.stack.Top().data[0]},mmlToken:function(l){return l},ControlSequence:function(o){var l=this.GetCS(),n=this.csFindMacro(l);if(n){if(!(n instanceof Array)){n=[n]}var m=n[0];if(!(m instanceof Function)){m=this[m]}m.apply(this,[o+l].concat(n.slice(1)))}else{if(f.mathchar0mi[l]){this.csMathchar0mi(l,f.mathchar0mi[l])}else{if(f.mathchar0mo[l]){this.csMathchar0mo(l,f.mathchar0mo[l])}else{if(f.mathchar7[l]){this.csMathchar7(l,f.mathchar7[l])}else{if(f.delimiter["\\"+l]!=null){this.csDelimiter(l,f.delimiter["\\"+l])}else{this.csUndefined(o+l)}}}}}},csFindMacro:function(l){return f.macros[l]},csMathchar0mi:function(l,n){var m={mathvariant:h.VARIANT.ITALIC};if(n instanceof Array){m=n[1];n=n[0]}this.Push(this.mmlToken(h.mi(h.entity("#x"+n)).With(m)))},csMathchar0mo:function(l,n){var m={stretchy:false};if(n instanceof Array){m=n[1];m.stretchy=false;n=n[0]}this.Push(this.mmlToken(h.mo(h.entity("#x"+n)).With(m)))},csMathchar7:function(l,n){var m={mathvariant:h.VARIANT.NORMAL};if(n instanceof Array){m=n[1];n=n[0]}if(this.stack.env.font){m.mathvariant=this.stack.env.font}this.Push(this.mmlToken(h.mi(h.entity("#x"+n)).With(m)))},csDelimiter:function(l,n){var m={};if(n instanceof Array){m=n[1];n=n[0]}if(n.length===4){n=h.entity("#x"+n)}else{n=h.chars(n)}this.Push(this.mmlToken(h.mo(n).With({fence:false,stretchy:false}).With(m)))},csUndefined:function(l){d.Error(["UndefinedControlSequence","Undefined control sequence %1",l])},Variable:function(m){var l={};if(this.stack.env.font){l.mathvariant=this.stack.env.font}this.Push(this.mmlToken(h.mi(h.chars(m)).With(l)))},Number:function(o){var l,m=this.string.slice(this.i-1).match(f.number);if(m){l=h.mn(m[0].replace(/[{}]/g,""));this.i+=m[0].length-1}else{l=h.mo(h.chars(o))}if(this.stack.env.font){l.mathvariant=this.stack.env.font}this.Push(this.mmlToken(l))},Open:function(l){this.Push(b.open())},Close:function(l){this.Push(b.close())},Tilde:function(l){this.Push(h.mtext(h.chars(g)))},Space:function(l){},Superscript:function(q){if(this.GetNext().match(/\d/)){this.string=this.string.substr(0,this.i+1)+" "+this.string.substr(this.i+1)}var p,n,o=this.stack.Top();if(o.type==="prime"){n=o.data[0];p=o.data[1];this.stack.Pop()}else{n=this.stack.Prev();if(!n){n=h.mi("")}}if(n.isEmbellishedWrapper){n=n.data[0].data[0]}var m=n.movesupsub,l=n.sup;if((n.type==="msubsup"&&n.data[n.sup])||(n.type==="munderover"&&n.data[n.over]&&!n.subsupOK)){d.Error(["DoubleExponent","Double exponent: use braces to clarify"])}if(n.type!=="msubsup"){if(m){if(n.type!=="munderover"||n.data[n.over]){if(n.movablelimits&&n.isa(h.mi)){n=this.mi2mo(n)}n=h.munderover(n,null,null).With({movesupsub:true})}l=n.over}else{n=h.msubsup(n,null,null);l=n.sup}}this.Push(b.subsup(n).With({position:l,primes:p,movesupsub:m}))},Subscript:function(q){if(this.GetNext().match(/\d/)){this.string=this.string.substr(0,this.i+1)+" "+this.string.substr(this.i+1)}var p,n,o=this.stack.Top();if(o.type==="prime"){n=o.data[0];p=o.data[1];this.stack.Pop()}else{n=this.stack.Prev();if(!n){n=h.mi("")}}if(n.isEmbellishedWrapper){n=n.data[0].data[0]}var m=n.movesupsub,l=n.sub;if((n.type==="msubsup"&&n.data[n.sub])||(n.type==="munderover"&&n.data[n.under]&&!n.subsupOK)){d.Error(["DoubleSubscripts","Double subscripts: use braces to clarify"])}if(n.type!=="msubsup"){if(m){if(n.type!=="munderover"||n.data[n.under]){if(n.movablelimits&&n.isa(h.mi)){n=this.mi2mo(n)}n=h.munderover(n,null,null).With({movesupsub:true})}l=n.under}else{n=h.msubsup(n,null,null);l=n.sub}}this.Push(b.subsup(n).With({position:l,primes:p,movesupsub:m}))},PRIME:"\u2032",SMARTQUOTE:"\u2019",Prime:function(n){var m=this.stack.Prev();if(!m){m=h.mi()}if(m.type==="msubsup"&&m.data[m.sup]){d.Error(["DoubleExponentPrime","Prime causes double exponent: use braces to clarify"])}var l="";this.i--;do{l+=this.PRIME;this.i++,n=this.GetNext()}while(n==="'"||n===this.SMARTQUOTE);l=["","\u2032","\u2033","\u2034","\u2057"][l.length]||l;this.Push(b.prime(m,this.mmlToken(h.mo(l))))},mi2mo:function(l){var m=h.mo();m.Append.apply(m,l.data);var n;for(n in m.defaults){if(m.defaults.hasOwnProperty(n)&&l[n]!=null){m[n]=l[n]}}for(n in h.copyAttributes){if(h.copyAttributes.hasOwnProperty(n)&&l[n]!=null){m[n]=l[n]}}m.lspace=m.rspace="0";m.useMMLspacing&=~(m.SPACE_ATTR.lspace|m.SPACE_ATTR.rspace);return m},Comment:function(l){while(this.i<this.string.length&&this.string.charAt(this.i)!="\n"){this.i++}},Hash:function(l){d.Error(["CantUseHash1","You can't use 'macro parameter character #' in math mode"])},Other:function(n){var m,l;if(this.stack.env.font){m={mathvariant:this.stack.env.font}}if(f.remap[n]){n=f.remap[n];if(n instanceof Array){m=n[1];n=n[0]}l=h.mo(h.entity("#x"+n)).With(m)}else{l=h.mo(n).With(m)}if(l.autoDefault("stretchy",true)){l.stretchy=false}if(l.autoDefault("texClass",true)==""){l=h.TeXAtom(l)}this.Push(this.mmlToken(l))},SetFont:function(m,l){this.stack.env.font=l},SetStyle:function(m,l,n,o){this.stack.env.style=l;this.stack.env.level=o;this.Push(b.style().With({styles:{displaystyle:n,scriptlevel:o}}))},SetSize:function(l,m){this.stack.env.size=m;this.Push(b.style().With({styles:{mathsize:m+"em"}}))},Color:function(n){var m=this.GetArgument(n);var l=this.stack.env.color;this.stack.env.color=m;var o=this.ParseArg(n);if(l){this.stack.env.color}else{delete this.stack.env.color}this.Push(h.mstyle(o).With({mathcolor:m}))},Spacer:function(l,m){this.Push(h.mspace().With({width:m,mathsize:h.SIZE.NORMAL,scriptlevel:0}))},LeftRight:function(l){this.Push(b[l.substr(1)]().With({delim:this.GetDelimiter(l)}))},Middle:function(l){var m=this.GetDelimiter(l);if(this.stack.Top().type!=="left"){d.Error(["MisplacedMiddle","%1 must be within \\left and \\right",l])}this.Push(h.mo(m).With({stretchy:true}))},NamedFn:function(m,n){if(!n){n=m.substr(1)}var l=h.mi(n).With({texClass:h.TEXCLASS.OP});this.Push(b.fn(this.mmlToken(l)))},NamedOp:function(m,n){if(!n){n=m.substr(1)}n=n.replace(/&thinsp;/,"\u2006");var l=h.mo(n).With({movablelimits:true,movesupsub:true,form:h.FORM.PREFIX,texClass:h.TEXCLASS.OP});l.useMMLspacing&=~l.SPACE_ATTR.form;this.Push(this.mmlToken(l))},Limits:function(m,l){var o=this.stack.Prev("nopop");if(!o||(o.Get("texClass")!==h.TEXCLASS.OP&&o.movesupsub==null)){d.Error(["MisplacedLimits","%1 is allowed only on operators",m])}var n=this.stack.Top();if(o.type==="munderover"&&!l){o=n.data[n.data.length-1]=h.msubsup.apply(h.subsup,o.data)}else{if(o.type==="msubsup"&&l){o=n.data[n.data.length-1]=h.munderover.apply(h.underover,o.data)}}o.movesupsub=(l?true:false);o.Core().movablelimits=false;if(o.movablelimits){o.movablelimits=false}},Over:function(n,m,o){var l=b.over().With({name:n});if(m||o){l.open=m;l.close=o}else{if(n.match(/withdelims$/)){l.open=this.GetDelimiter(n);l.close=this.GetDelimiter(n)}}if(n.match(/^\\above/)){l.thickness=this.GetDimen(n)}else{if(n.match(/^\\atop/)||m||o){l.thickness=0}}this.Push(l)},Frac:function(m){var l=this.ParseArg(m);var n=this.ParseArg(m);this.Push(h.mfrac(l,n))},Sqrt:function(o){var p=this.GetBrackets(o),l=this.GetArgument(o);if(l==="\\frac"){l+="{"+this.GetArgument(l)+"}{"+this.GetArgument(l)+"}"}var m=d.Parse(l,this.stack.env).mml();if(!p){m=h.msqrt.apply(h,m.array())}else{m=h.mroot(m,this.parseRoot(p))}this.Push(m)},Root:function(m){var o=this.GetUpTo(m,"\\of");var l=this.ParseArg(m);this.Push(h.mroot(l,this.parseRoot(o)))},parseRoot:function(q){var m=this.stack.env,l=m.inRoot;m.inRoot=true;var p=d.Parse(q,m);q=p.mml();var o=p.stack.global;if(o.leftRoot||o.upRoot){q=h.mpadded(q);if(o.leftRoot){q.width=o.leftRoot}if(o.upRoot){q.voffset=o.upRoot;q.height=o.upRoot}}m.inRoot=l;return q},MoveRoot:function(l,o){if(!this.stack.env.inRoot){d.Error(["MisplacedMoveRoot","%1 can appear only within a root",l])}if(this.stack.global[o]){d.Error(["MultipleMoveRoot","Multiple use of %1",l])}var m=this.GetArgument(l);if(!m.match(/-?[0-9]+/)){d.Error(["IntegerArg","The argument to %1 must be an integer",l])}m=(m/15)+"em";if(m.substr(0,1)!=="-"){m="+"+m}this.stack.global[o]=m},Accent:function(n,l,q){var p=this.ParseArg(n);var o={accent:true};if(this.stack.env.font){o.mathvariant=this.stack.env.font}var m=this.mmlToken(h.mo(h.entity("#x"+l)).With(o));m.stretchy=(q?true:false);this.Push(h.TeXAtom(h.munderover(p,null,m).With({accent:true})))},UnderOver:function(n,r,l,p){var q={o:"over",u:"under"}[n.charAt(1)];var o=this.ParseArg(n);if(o.Get("movablelimits")){o.movablelimits=false}if(o.isa(h.munderover)&&o.isEmbellished()){o.Core().With({lspace:0,rspace:0});o=h.mrow(h.mo().With({rspace:0}),o)}var m=h.munderover(o,null,null);m.SetData(m[q],this.mmlToken(h.mo(h.entity("#x"+r)).With({stretchy:true,accent:!p})));if(l){m=h.TeXAtom(m).With({texClass:h.TEXCLASS.OP,movesupsub:true})}this.Push(m.With({subsupOK:true}))},Overset:function(l){var n=this.ParseArg(l),m=this.ParseArg(l);if(m.movablelimits){m.movablelimits=false}this.Push(h.mover(m,n))},Underset:function(l){var n=this.ParseArg(l),m=this.ParseArg(l);if(m.movablelimits){m.movablelimits=false}this.Push(h.munder(m,n))},TeXAtom:function(o,q){var p={texClass:q},n;if(q==h.TEXCLASS.OP){p.movesupsub=p.movablelimits=true;var l=this.GetArgument(o);var m=l.match(/^\s*\\rm\s+([a-zA-Z0-9 ]+)$/);if(m){p.mathvariant=h.VARIANT.NORMAL;n=b.fn(this.mmlToken(h.mi(m[1]).With(p)))}else{n=b.fn(h.TeXAtom(d.Parse(l,this.stack.env).mml()).With(p))}}else{n=h.TeXAtom(this.ParseArg(o)).With(p)}this.Push(n)},MmlToken:function(n){var o=this.GetArgument(n),l=this.GetBrackets(n,"").replace(/^\s+/,""),r=this.GetArgument(n),q={attrNames:[]},m;if(!h[o]||!h[o].prototype.isToken){d.Error(["NotMathMLToken","%1 is not a token element",o])}while(l!==""){m=l.match(/^([a-z]+)\s*=\s*('[^']*'|"[^"]*"|[^ ,]*)\s*,?\s*/i);if(!m){d.Error(["InvalidMathMLAttr","Invalid MathML attribute: %1",l])}if(h[o].prototype.defaults[m[1]]==null&&!this.MmlTokenAllow[m[1]]){d.Error(["UnknownAttrForElement","%1 is not a recognized attribute for %2",m[1],o])}var p=this.MmlFilterAttribute(m[1],m[2].replace(/^(['"])(.*)\1$/,"$2"));if(p){if(p.toLowerCase()==="true"){p=true}else{if(p.toLowerCase()==="false"){p=false}}q[m[1]]=p;q.attrNames.push(m[1])}l=l.substr(m[0].length)}this.Push(this.mmlToken(h[o](r).With(q)))},MmlFilterAttribute:function(l,m){return m},MmlTokenAllow:{fontfamily:1,fontsize:1,fontweight:1,fontstyle:1,color:1,background:1,id:1,"class":1,href:1,style:1},Strut:function(l){this.Push(h.mpadded(h.mrow()).With({height:"8.6pt",depth:"3pt",width:0}))},Phantom:function(m,l,n){var o=h.mphantom(this.ParseArg(m));if(l||n){o=h.mpadded(o);if(n){o.height=o.depth=0}if(l){o.width=0}}this.Push(h.TeXAtom(o))},Smash:function(n){var m=this.trimSpaces(this.GetBrackets(n,""));var l=h.mpadded(this.ParseArg(n));switch(m){case"b":l.depth=0;break;case"t":l.height=0;break;default:l.height=l.depth=0}this.Push(h.TeXAtom(l))},Lap:function(m){var l=h.mpadded(this.ParseArg(m)).With({width:0});if(m==="\\llap"){l.lspace="-1width"}this.Push(h.TeXAtom(l))},RaiseLower:function(l){var m=this.GetDimen(l);var n=b.position().With({name:l,move:"vertical"});if(m.charAt(0)==="-"){m=m.slice(1);l={raise:"\\lower",lower:"\\raise"}[l.substr(1)]}if(l==="\\lower"){n.dh="-"+m;n.dd="+"+m}else{n.dh="+"+m;n.dd="-"+m}this.Push(n)},MoveLeftRight:function(l){var o=this.GetDimen(l);var n=(o.charAt(0)==="-"?o.slice(1):"-"+o);if(l==="\\moveleft"){var m=o;o=n;n=m}this.Push(b.position().With({name:l,move:"horizontal",left:h.mspace().With({width:o,mathsize:h.SIZE.NORMAL}),right:h.mspace().With({width:n,mathsize:h.SIZE.NORMAL})}))},Hskip:function(l){this.Push(h.mspace().With({width:this.GetDimen(l),mathsize:h.SIZE.NORMAL}))},Rule:function(n,p){var l=this.GetDimen(n),o=this.GetDimen(n),r=this.GetDimen(n);var m,q={width:l,height:o,depth:r};if(p!=="blank"){if(parseFloat(l)&&parseFloat(o)+parseFloat(r)){q.mathbackground=(this.stack.env.color||"black")}m=h.mpadded(h.mrow()).With(q)}else{m=h.mspace().With(q)}this.Push(m)},MakeBig:function(l,o,m){m*=f.p_height;m=String(m).replace(/(\.\d\d\d).+/,"$1")+"em";var n=this.GetDelimiter(l,true);this.Push(h.TeXAtom(h.mo(n).With({minsize:m,maxsize:m,fence:true,stretchy:true,symmetric:true})).With({texClass:o}))},BuildRel:function(l){var m=this.ParseUpTo(l,"\\over");var n=this.ParseArg(l);this.Push(h.TeXAtom(h.munderover(n,null,m)).With({texClass:h.TEXCLASS.REL}))},HBox:function(l,m){this.Push.apply(this,this.InternalMath(this.GetArgument(l),m))},FBox:function(l){this.Push(h.menclose.apply(h,this.InternalMath(this.GetArgument(l))).With({notation:"box"}))},Not:function(l){this.Push(b.not())},Dots:function(l){this.Push(b.dots().With({ldots:this.mmlToken(h.mo(h.entity("#x2026")).With({stretchy:false})),cdots:this.mmlToken(h.mo(h.entity("#x22EF")).With({stretchy:false}))}))},Require:function(l){var m=this.GetArgument(l).replace(/.*\//,"").replace(/[^a-z0-9_.-]/ig,"");this.Extension(null,m)},Extension:function(l,m,n){if(l&&!typeof(l)==="string"){l=l.name}m=d.extensionDir+"/"+m;if(!m.match(/\.js$/)){m+=".js"}if(!i.loaded[i.fileURL(m)]){if(l!=null){delete f[n||"macros"][l.replace(/^\\/,"")]}c.RestartAfter(i.Require(m))}},Macro:function(n,q,p,r){if(p){var m=[];if(r!=null){var l=this.GetBrackets(n);m.push(l==null?r:l)}for(var o=m.length;o<p;o++){m.push(this.GetArgument(n))}q=this.SubstituteArgs(m,q)}this.string=this.AddArgs(q,this.string.slice(this.i));this.i=0;if(++this.macroCount>d.config.MAXMACROS){d.Error(["MaxMacroSub1","MathJax maximum macro substitution count exceeded; is there a recursive macro call?"])}},Matrix:function(m,o,u,q,t,n,l,v,s){var r=this.GetNext();if(r===""){d.Error(["MissingArgFor","Missing argument for %1",m])}if(r==="{"){this.i++}else{this.string=r+"}"+this.string.slice(this.i+1);this.i=0}var p=b.array().With({requireClose:true,arraydef:{rowspacing:(n||"4pt"),columnspacing:(t||"1em")}});if(v){p.isCases=true}if(s){p.isNumbered=true;p.arraydef.side=s}if(o||u){p.open=o;p.close=u}if(l==="D"){p.arraydef.displaystyle=true}if(q!=null){p.arraydef.columnalign=q}this.Push(p)},Entry:function(o){this.Push(b.cell().With({isEntry:true,name:o}));if(this.stack.Top().isCases){var n=this.string;var r=0,p=this.i,l=n.length;while(p<l){var s=n.charAt(p);if(s==="{"){r++;p++}else{if(s==="}"){if(r===0){l=0}else{r--;p++}}else{if(s==="&"&&r===0){d.Error(["ExtraAlignTab","Extra alignment tab in \\cases text"])}else{if(s==="\\"){if(n.substr(p).match(/^((\\cr)[^a-zA-Z]|\\\\)/)){l=0}else{p+=2}}else{p++}}}}}var q=n.substr(this.i,p-this.i);if(!q.match(/^\s*\\text[^a-zA-Z]/)){this.Push.apply(this,this.InternalMath(q,0));this.i=p}}},Cr:function(l){this.Push(b.cell().With({isCR:true,name:l}))},CrLaTeX:function(l){var p;if(this.string.charAt(this.i)==="["){p=this.GetBrackets(l,"").replace(/ /g,"").replace(/,/,".");if(p&&!this.matchDimen(p)){d.Error(["BracketMustBeDimension","Bracket argument to %1 must be a dimension",l])}}this.Push(b.cell().With({isCR:true,name:l,linebreak:true}));var o=this.stack.Top();if(o.isa(b.array)){if(p&&o.arraydef.rowspacing){var m=o.arraydef.rowspacing.split(/ /);if(!o.rowspacing){o.rowspacing=this.dimen2em(m[0])}while(m.length<o.table.length){m.push(this.Em(o.rowspacing))}m[o.table.length-1]=this.Em(Math.max(0,o.rowspacing+this.dimen2em(p)));o.arraydef.rowspacing=m.join(" ")}}else{if(p){this.Push(h.mspace().With({depth:p}))}this.Push(h.mspace().With({linebreak:h.LINEBREAK.NEWLINE}))}},emPerInch:7.2,pxPerInch:72,matchDimen:function(l){return l.match(/^(-?(?:\.\d+|\d+(?:\.\d*)?))(px|pt|em|ex|mu|pc|in|mm|cm)$/)},dimen2em:function(p){var n=this.matchDimen(p);var l=parseFloat(n[1]||"1"),o=n[2];if(o==="em"){return l}if(o==="ex"){return l*0.43}if(o==="pt"){return l/10}if(o==="pc"){return l*1.2}if(o==="px"){return l*this.emPerInch/this.pxPerInch}if(o==="in"){return l*this.emPerInch}if(o==="cm"){return l*this.emPerInch/2.54}if(o==="mm"){return l*this.emPerInch/25.4}if(o==="mu"){return l/18}return 0},Em:function(l){if(Math.abs(l)<0.0006){return"0em"}return l.toFixed(3).replace(/\.?0+$/,"")+"em"},HLine:function(m,n){if(n==null){n="solid"}var o=this.stack.Top();if(!o.isa(b.array)||o.data.length){d.Error(["Misplaced","Misplaced %1",m])}if(o.table.length==0){o.frame.push("top")}else{var l=(o.arraydef.rowlines?o.arraydef.rowlines.split(/ /):[]);while(l.length<o.table.length){l.push("none")}l[o.table.length-1]=n;o.arraydef.rowlines=l.join(" ")}},HFill:function(l){var m=this.stack.Top();if(m.isa(b.array)){m.hfill.push(m.data.length)}else{d.Error(["UnsupportedHFill","Unsupported use of %1",l])}},BeginEnd:function(n){var o=this.GetArgument(n),q=false;if(o.match(/^\\end\\/)){q=true;o=o.substr(5)}if(o.match(/\\/i)){d.Error(["InvalidEnv","Invalid environment name '%1'",o])}var p=this.envFindName(o);if(!p){d.Error(["UnknownEnv","Unknown environment '%1'",o])}if(!(p instanceof Array)){p=[p]}var l=(p[1] instanceof Array?p[1][0]:p[1]);var m=b.begin().With({name:o,end:l,parse:this});if(n==="\\end"){if(!q&&p[1] instanceof Array&&this[p[1][1]]){m=this[p[1][1]].apply(this,[m].concat(p.slice(2)))}else{m=b.end().With({name:o})}}else{if(++this.macroCount>d.config.MAXMACROS){d.Error(["MaxMacroSub2","MathJax maximum substitution count exceeded; is there a recursive latex environment?"])}if(p[0]&&this[p[0]]){m=this[p[0]].apply(this,[m].concat(p.slice(2)))}}this.Push(m)},envFindName:function(l){return f.environment[l]},Equation:function(l,m){return m},ExtensionEnv:function(m,l){this.Extension(m.name,l,"environment")},Array:function(m,o,t,r,s,n,l,p){if(!r){r=this.GetArgument("\\begin{"+m.name+"}")}var u=("c"+r).replace(/[^clr|:]/g,"").replace(/[^|:]([|:])+/g,"$1");r=r.replace(/[^clr]/g,"").split("").join(" ");r=r.replace(/l/g,"left").replace(/r/g,"right").replace(/c/g,"center");var q=b.array().With({arraydef:{columnalign:r,columnspacing:(s||"1em"),rowspacing:(n||"4pt")}});if(u.match(/[|:]/)){if(u.charAt(0).match(/[|:]/)){q.frame.push("left");q.frame.dashed=u.charAt(0)===":"}if(u.charAt(u.length-1).match(/[|:]/)){q.frame.push("right")}u=u.substr(1,u.length-2);q.arraydef.columnlines=u.split("").join(" ").replace(/[^|: ]/g,"none").replace(/\|/g,"solid").replace(/:/g,"dashed")}if(o){q.open=this.convertDelimiter(o)}if(t){q.close=this.convertDelimiter(t)}if(l==="D"){q.arraydef.displaystyle=true}else{if(l){q.arraydef.displaystyle=false}}if(l==="S"){q.arraydef.scriptlevel=1}if(p){q.arraydef.useHeight=false}this.Push(m);return q},AlignedArray:function(l){var m=this.GetBrackets("\\begin{"+l.name+"}");return this.setArrayAlign(this.Array.apply(this,arguments),m)},setArrayAlign:function(m,l){l=this.trimSpaces(l||"");if(l==="t"){m.arraydef.align="baseline 1"}else{if(l==="b"){m.arraydef.align="baseline -1"}else{if(l==="c"){m.arraydef.align="center"}else{if(l){m.arraydef.align=l}}}}return m},convertDelimiter:function(l){if(l){l=f.delimiter[l]}if(l==null){return null}if(l instanceof Array){l=l[0]}if(l.length===4){l=String.fromCharCode(parseInt(l,16))}return l},trimSpaces:function(l){if(typeof(l)!="string"){return l}return l.replace(/^\s+|\s+$/g,"")},nextIsSpace:function(){return this.string.charAt(this.i).match(/\s/)},GetNext:function(){while(this.nextIsSpace()){this.i++}return this.string.charAt(this.i)},GetCS:function(){var l=this.string.slice(this.i).match(/^([a-z]+|.) ?/i);if(l){this.i+=l[1].length;return l[1]}else{this.i++;return" "}},GetArgument:function(m,n){switch(this.GetNext()){case"":if(!n){d.Error(["MissingArgFor","Missing argument for %1",m])}return null;case"}":if(!n){d.Error(["ExtraCloseMissingOpen","Extra close brace or missing open brace"])}return null;case"\\":this.i++;return"\\"+this.GetCS();case"{":var l=++this.i,o=1;while(this.i<this.string.length){switch(this.string.charAt(this.i++)){case"\\":this.i++;break;case"{":o++;break;case"}":if(--o==0){return this.string.slice(l,this.i-1)}break}}d.Error(["MissingCloseBrace","Missing close brace"]);break}return this.string.charAt(this.i++)},GetBrackets:function(m,o){if(this.GetNext()!="["){return o}var l=++this.i,n=0;while(this.i<this.string.length){switch(this.string.charAt(this.i++)){case"{":n++;break;case"\\":this.i++;break;case"}":if(n--<=0){d.Error(["ExtraCloseLooking","Extra close brace while looking for %1","']'"])}break;case"]":if(n==0){return this.string.slice(l,this.i-1)}break}}d.Error(["MissingCloseBracket","Couldn't find closing ']' for argument to %1",m])},GetDelimiter:function(l,m){while(this.nextIsSpace()){this.i++}var n=this.string.charAt(this.i);this.i++;if(this.i<=this.string.length){if(n=="\\"){n+=this.GetCS(l)}else{if(n==="{"&&m){this.i--;n=this.GetArgument(l)}}if(f.delimiter[n]!=null){return this.convertDelimiter(n)}}d.Error(["MissingOrUnrecognizedDelim","Missing or unrecognized delimiter for %1",l])},GetDimen:function(m){var n;if(this.nextIsSpace()){this.i++}if(this.string.charAt(this.i)=="{"){n=this.GetArgument(m);if(n.match(/^\s*([-+]?([.,]\d+|\d+([.,]\d*)?))\s*(pt|em|ex|mu|px|mm|cm|in|pc)\s*$/)){return n.replace(/ /g,"").replace(/,/,".")}}else{n=this.string.slice(this.i);var l=n.match(/^\s*(([-+]?([.,]\d+|\d+([.,]\d*)?))\s*(pt|em|ex|mu|px|mm|cm|in|pc)) ?/);if(l){this.i+=l[0].length;return l[1].replace(/ /g,"").replace(/,/,".")}}d.Error(["MissingDimOrUnits","Missing dimension or its units for %1",m])},GetUpTo:function(n,o){while(this.nextIsSpace()){this.i++}var m=this.i,l,q,p=0;while(this.i<this.string.length){l=this.i;q=this.string.charAt(this.i++);switch(q){case"\\":q+=this.GetCS();break;case"{":p++;break;case"}":if(p==0){d.Error(["ExtraCloseLooking","Extra close brace while looking for %1",o])}p--;break}if(p==0&&q==o){return this.string.slice(m,l)}}d.Error(["TokenNotFoundForCommand","Couldn't find %1 for %2",o,n])},ParseArg:function(l){return d.Parse(this.GetArgument(l),this.stack.env).mml()},ParseUpTo:function(l,m){return d.Parse(this.GetUpTo(l,m),this.stack.env).mml()},InternalMath:function(u,l){var n=(this.stack.env.font?{mathvariant:this.stack.env.font}:{});var m=[],q=0,p=0,t,r="",o=0;if(u.match(/\\?[${}\\]|\\\(|\\(eq)?ref\s*\{/)){while(q<u.length){t=u.charAt(q++);if(t==="$"){if(r==="$"&&o===0){m.push(h.TeXAtom(d.Parse(u.slice(p,q-1),{}).mml()));r="";p=q}else{if(r===""){if(p<q-1){m.push(this.InternalText(u.slice(p,q-1),n))}r="$";p=q}}}else{if(t==="{"&&r!==""){o++}else{if(t==="}"){if(r==="}"&&o===0){m.push(h.TeXAtom(d.Parse(u.slice(p,q),{}).mml().With(n)));r="";p=q}else{if(r!==""){if(o){o--}}}}else{if(t==="\\"){if(r===""&&u.substr(q).match(/^(eq)?ref\s*\{/)){var s=RegExp["$&"].length;if(p<q-1){m.push(this.InternalText(u.slice(p,q-1),n))}r="}";p=q-1;q+=s}else{t=u.charAt(q++);if(t==="("&&r===""){if(p<q-2){m.push(this.InternalText(u.slice(p,q-2),n))}r=")";p=q}else{if(t===")"&&r===")"&&o===0){m.push(h.TeXAtom(d.Parse(u.slice(p,q-2),{}).mml()));r="";p=q}else{if(t.match(/[${}\\]/)&&r===""){q--;u=u.substr(0,q-1)+u.substr(q)}}}}}}}}}if(r!==""){d.Error(["MathNotTerminated","Math not terminated in text box"])}}if(p<u.length){m.push(this.InternalText(u.slice(p),n))}if(l!=null){m=[h.mstyle.apply(h,m).With({displaystyle:false,scriptlevel:l})]}else{if(m.length>1){m=[h.mrow.apply(h,m)]}}return m},InternalText:function(m,l){m=m.replace(/^\s+/,g).replace(/\s+$/,g);return h.mtext(h.chars(m)).With(l)},SubstituteArgs:function(m,l){var p="";var o="";var q;var n=0;while(n<l.length){q=l.charAt(n++);if(q==="\\"){p+=q+l.charAt(n++)}else{if(q==="#"){q=l.charAt(n++);if(q==="#"){p+=q}else{if(!q.match(/[1-9]/)||q>m.length){d.Error(["IllegalMacroParam","Illegal macro parameter reference"])}o=this.AddArgs(this.AddArgs(o,p),m[q-1]);p=""}}else{p+=q}}}return this.AddArgs(o,p)},AddArgs:function(m,l){if(l.match(/^[a-z]/i)&&m.match(/(^|[^\\])(\\\\)*\\[a-z]+$/i)){m+=" "}if(m.length+l.length>d.config.MAXBUFFER){d.Error(["MaxBufferSize","MathJax internal buffer size exceeded; is there a recursive macro call?"])}return m+l}});d.Augment({Stack:e,Parse:a,Definitions:f,Startup:k,config:{MAXMACROS:10000,MAXBUFFER:5*1024},sourceMenuTitle:["TeXCommands","TeX Commands"],annotationEncoding:"application/x-tex",prefilterHooks:MathJax.Callback.Hooks(true),postfilterHooks:MathJax.Callback.Hooks(true),Config:function(){this.SUPER(arguments).Config.apply(this,arguments);if(this.config.equationNumbers.autoNumber!=="none"){if(!this.config.extensions){this.config.extensions=[]}this.config.extensions.push("AMSmath.js")}},Translate:function(l){var m,n=false,p=MathJax.HTML.getScript(l);var r=(l.type.replace(/\n/g," ").match(/(;|\s|\n)mode\s*=\s*display(;|\s|\n|$)/)!=null);var q={math:p,display:r,script:l};var s=this.prefilterHooks.Execute(q);if(s){return s}p=q.math;try{m=d.Parse(p).mml()}catch(o){if(!o.texError){throw o}m=this.formatError(o,p,r,l);n=true}if(m.isa(h.mtable)&&m.displaystyle==="inherit"){m.displaystyle=r}if(m.inferred){m=h.apply(MathJax.ElementJax,m.data)}else{m=h(m)}if(r){m.root.display="block"}if(n){m.texError=true}q.math=m;return this.postfilterHooks.Execute(q)||q.math},prefilterMath:function(m,n,l){return m},postfilterMath:function(m,n,l){this.combineRelations(m.root);return m},formatError:function(o,n,p,l){var m=o.message.replace(/\n.*/,"");c.signal.Post(["TeX Jax - parse error",m,n,p,l]);return h.Error(m)},Error:function(l){if(l instanceof Array){l=j.apply(j,l)}throw c.Insert(Error(l),{texError:true})},Macro:function(l,m,n){f.macros[l]=["Macro"].concat([].slice.call(arguments,1));f.macros[l].isUser=true},fenced:function(n,m,o){var l=h.mrow().With({open:n,close:o,texClass:h.TEXCLASS.INNER});l.Append(h.mo(n).With({fence:true,stretchy:true,texClass:h.TEXCLASS.OPEN}));if(m.type==="mrow"){l.Append.apply(l,m.data)}else{l.Append(m)}l.Append(h.mo(o).With({fence:true,stretchy:true,texClass:h.TEXCLASS.CLOSE}));return l},fixedFence:function(n,m,o){var l=h.mrow().With({open:n,close:o,texClass:h.TEXCLASS.ORD});if(n){l.Append(this.mathPalette(n,"l"))}if(m.type==="mrow"){l.Append.apply(l,m.data)}else{l.Append(m)}if(o){l.Append(this.mathPalette(o,"r"))}return l},mathPalette:function(o,m){if(o==="{"||o==="}"){o="\\"+o}var n="{\\bigg"+m+" "+o+"}",l="{\\big"+m+" "+o+"}";return d.Parse("\\mathchoice"+n+l+l+l,{}).mml()},combineRelations:function(p){var q,l,o,n;for(q=0,l=p.data.length;q<l;q++){if(p.data[q]){if(p.isa(h.mrow)){while(q+1<l&&(o=p.data[q])&&(n=p.data[q+1])&&o.isa(h.mo)&&n.isa(h.mo)&&o.Get("texClass")===h.TEXCLASS.REL&&n.Get("texClass")===h.TEXCLASS.REL){if(o.variantForm==n.variantForm&&o.Get("mathvariant")==n.Get("mathvariant")&&o.style==n.style&&o["class"]==n["class"]&&!o.id&&!n.id){o.Append.apply(o,n.data);p.data.splice(q+1,1);l--}else{o.rspace=n.lspace="0pt";q++}}}if(!p.data[q].isToken){this.combineRelations(p.data[q])}}}}});d.prefilterHooks.Add(function(l){l.math=d.prefilterMath(l.math,l.display,l.script)});d.postfilterHooks.Add(function(l){l.math=d.postfilterMath(l.math,l.display,l.script)});d.loadComplete("jax.js")})(MathJax.InputJax.TeX,MathJax.Hub,MathJax.Ajax);
	MathJax.Extension["TeX/AMSmath"]={version:"2.6.1",number:0,startNumber:0,IDs:{},eqIDs:{},labels:{},eqlabels:{},refs:[]};MathJax.Hub.Register.StartupHook("TeX Jax Ready",function(){var b=MathJax.ElementJax.mml,g=MathJax.InputJax.TeX,f=MathJax.Extension["TeX/AMSmath"];var d=g.Definitions,e=g.Stack.Item,a=g.config.equationNumbers;var c=function(j){var l=[];for(var k=0,h=j.length;k<h;k++){l[k]=g.Parse.prototype.Em(j[k])}return l.join(" ")};d.Add({mathchar0mo:{iiiint:["2A0C",{texClass:b.TEXCLASS.OP}]},macros:{mathring:["Accent","2DA"],nobreakspace:"Tilde",negmedspace:["Spacer",b.LENGTH.NEGATIVEMEDIUMMATHSPACE],negthickspace:["Spacer",b.LENGTH.NEGATIVETHICKMATHSPACE],idotsint:["MultiIntegral","\\int\\cdots\\int"],dddot:["Accent","20DB"],ddddot:["Accent","20DC"],sideset:["Macro","\\mathop{\\mathop{\\rlap{\\phantom{#3}}}\\nolimits#1\\!\\mathop{#3}\\nolimits#2}",3],boxed:["Macro","\\fbox{$\\displaystyle{#1}$}",1],tag:"HandleTag",notag:"HandleNoTag",label:"HandleLabel",ref:"HandleRef",eqref:["HandleRef",true],substack:["Macro","\\begin{subarray}{c}#1\\end{subarray}",1],injlim:["NamedOp","inj&thinsp;lim"],projlim:["NamedOp","proj&thinsp;lim"],varliminf:["Macro","\\mathop{\\underline{\\mmlToken{mi}{lim}}}"],varlimsup:["Macro","\\mathop{\\overline{\\mmlToken{mi}{lim}}}"],varinjlim:["Macro","\\mathop{\\underrightarrow{\\mmlToken{mi}{lim}}}"],varprojlim:["Macro","\\mathop{\\underleftarrow{\\mmlToken{mi}{lim}}}"],DeclareMathOperator:"HandleDeclareOp",operatorname:"HandleOperatorName",SkipLimits:"SkipLimits",genfrac:"Genfrac",frac:["Genfrac","","","",""],tfrac:["Genfrac","","","",1],dfrac:["Genfrac","","","",0],binom:["Genfrac","(",")","0",""],tbinom:["Genfrac","(",")","0",1],dbinom:["Genfrac","(",")","0",0],cfrac:"CFrac",shoveleft:["HandleShove",b.ALIGN.LEFT],shoveright:["HandleShove",b.ALIGN.RIGHT],xrightarrow:["xArrow",8594,5,6],xleftarrow:["xArrow",8592,7,3]},environment:{align:["AMSarray",null,true,true,"rlrlrlrlrlrl",c([0,2,0,2,0,2,0,2,0,2,0])],"align*":["AMSarray",null,false,true,"rlrlrlrlrlrl",c([0,2,0,2,0,2,0,2,0,2,0])],multline:["Multline",null,true],"multline*":["Multline",null,false],split:["AMSarray",null,false,false,"rl",c([0])],gather:["AMSarray",null,true,true,"c"],"gather*":["AMSarray",null,false,true,"c"],alignat:["AlignAt",null,true,true],"alignat*":["AlignAt",null,false,true],alignedat:["AlignAt",null,false,false],aligned:["AlignedAMSArray",null,null,null,"rlrlrlrlrlrl",c([0,2,0,2,0,2,0,2,0,2,0]),".5em","D"],gathered:["AlignedAMSArray",null,null,null,"c",null,".5em","D"],subarray:["Array",null,null,null,null,c([0]),"0.1em","S",1],smallmatrix:["Array",null,null,null,"c",c([1/3]),".2em","S",1],equation:["EquationBegin","Equation",true],"equation*":["EquationBegin","EquationStar",false],eqnarray:["AMSarray",null,true,true,"rcl","0 "+b.LENGTH.THICKMATHSPACE,".5em"],"eqnarray*":["AMSarray",null,false,true,"rcl","0 "+b.LENGTH.THICKMATHSPACE,".5em"]},delimiter:{"\\lvert":["2223",{texClass:b.TEXCLASS.OPEN}],"\\rvert":["2223",{texClass:b.TEXCLASS.CLOSE}],"\\lVert":["2225",{texClass:b.TEXCLASS.OPEN}],"\\rVert":["2225",{texClass:b.TEXCLASS.CLOSE}]}},null,true);g.Parse.Augment({HandleTag:function(j){var l=this.GetStar();var i=this.trimSpaces(this.GetArgument(j)),h=i;if(!l){i=a.formatTag(i)}var k=this.stack.global;k.tagID=h;if(k.notags){g.Error(["CommandNotAllowedInEnv","%1 not allowed in %2 environment",j,k.notags])}if(k.tag){g.Error(["MultipleCommand","Multiple %1",j])}k.tag=b.mtd.apply(b,this.InternalMath(i)).With({id:a.formatID(h)})},HandleNoTag:function(h){if(this.stack.global.tag){delete this.stack.global.tag}this.stack.global.notag=true},HandleLabel:function(i){var j=this.stack.global,h=this.GetArgument(i);if(h===""){return}if(!f.refUpdate){if(j.label){g.Error(["MultipleCommand","Multiple %1",i])}j.label=h;if(f.labels[h]||f.eqlabels[h]){g.Error(["MultipleLabel","Label '%1' multiply defined",h])}f.eqlabels[h]={tag:"???",id:""}}},HandleRef:function(j,l){var i=this.GetArgument(j);var k=f.labels[i]||f.eqlabels[i];if(!k){k={tag:"???",id:""};f.badref=!f.refUpdate}var h=k.tag;if(l){h=a.formatTag(h)}this.Push(b.mrow.apply(b,this.InternalMath(h)).With({href:a.formatURL(k.id),"class":"MathJax_ref"}))},HandleDeclareOp:function(i){var h=(this.GetStar()?"":"\\nolimits\\SkipLimits");var j=this.trimSpaces(this.GetArgument(i));if(j.charAt(0)=="\\"){j=j.substr(1)}var k=this.GetArgument(i);k=k.replace(/\*/g,"\\text{*}").replace(/-/g,"\\text{-}");g.Definitions.macros[j]=["Macro","\\mathop{\\rm "+k+"}"+h]},HandleOperatorName:function(i){var h=(this.GetStar()?"":"\\nolimits\\SkipLimits");var j=this.trimSpaces(this.GetArgument(i));j=j.replace(/\*/g,"\\text{*}").replace(/-/g,"\\text{-}");this.string="\\mathop{\\rm "+j+"}"+h+" "+this.string.slice(this.i);this.i=0},SkipLimits:function(h){var k=this.GetNext(),j=this.i;if(k==="\\"&&++this.i&&this.GetCS()!=="limits"){this.i=j}},HandleShove:function(i,h){var j=this.stack.Top();if(j.type!=="multline"||j.data.length){g.Error(["CommandAtTheBeginingOfLine","%1 must come at the beginning of the line",i])}j.data.shove=h},CFrac:function(k){var h=this.trimSpaces(this.GetBrackets(k,"")),j=this.GetArgument(k),l=this.GetArgument(k);var i=b.mfrac(g.Parse("\\strut\\textstyle{"+j+"}",this.stack.env).mml(),g.Parse("\\strut\\textstyle{"+l+"}",this.stack.env).mml());h=({l:b.ALIGN.LEFT,r:b.ALIGN.RIGHT,"":""})[h];if(h==null){g.Error(["IllegalAlign","Illegal alignment specified in %1",k])}if(h){i.numalign=i.denomalign=h}this.Push(i)},Genfrac:function(i,k,p,m,h){if(k==null){k=this.GetDelimiterArg(i)}if(p==null){p=this.GetDelimiterArg(i)}if(m==null){m=this.GetArgument(i)}if(h==null){h=this.trimSpaces(this.GetArgument(i))}var l=this.ParseArg(i);var o=this.ParseArg(i);var j=b.mfrac(l,o);if(m!==""){j.linethickness=m}if(k||p){j=g.fixedFence(k,j.With({texWithDelims:true}),p)}if(h!==""){var n=(["D","T","S","SS"])[h];if(n==null){g.Error(["BadMathStyleFor","Bad math style for %1",i])}j=b.mstyle(j);if(n==="D"){j.displaystyle=true;j.scriptlevel=0}else{j.displaystyle=false;j.scriptlevel=h-1}}this.Push(j)},Multline:function(i,h){this.Push(i);this.checkEqnEnv();return e.multline(h,this.stack).With({arraydef:{displaystyle:true,rowspacing:".5em",width:g.config.MultLineWidth,columnwidth:"100%",side:g.config.TagSide,minlabelspacing:g.config.TagIndent}})},AMSarray:function(j,i,h,l,k){this.Push(j);if(h){this.checkEqnEnv()}l=l.replace(/[^clr]/g,"").split("").join(" ");l=l.replace(/l/g,"left").replace(/r/g,"right").replace(/c/g,"center");return e.AMSarray(j.name,i,h,this.stack).With({arraydef:{displaystyle:true,rowspacing:".5em",columnalign:l,columnspacing:(k||"1em"),rowspacing:"3pt",side:g.config.TagSide,minlabelspacing:g.config.TagIndent}})},AlignedAMSArray:function(h){var i=this.GetBrackets("\\begin{"+h.name+"}");return this.setArrayAlign(this.AMSarray.apply(this,arguments),i)},AlignAt:function(k,i,h){var p,j,o="",m=[];if(!h){j=this.GetBrackets("\\begin{"+k.name+"}")}p=this.GetArgument("\\begin{"+k.name+"}");if(p.match(/[^0-9]/)){g.Error(["PositiveIntegerArg","Argument to %1 must me a positive integer","\\begin{"+k.name+"}"])}while(p>0){o+="rl";m.push("0em 0em");p--}m=m.join(" ");if(h){return this.AMSarray(k,i,h,o,m)}var l=this.AMSarray(k,i,h,o,m);return this.setArrayAlign(l,j)},EquationBegin:function(h,i){this.checkEqnEnv();this.stack.global.forcetag=(i&&a.autoNumber!=="none");return h},EquationStar:function(h,i){this.stack.global.tagged=true;return i},checkEqnEnv:function(){if(this.stack.global.eqnenv){g.Error(["ErroneousNestingEq","Erroneous nesting of equation structures"])}this.stack.global.eqnenv=true},MultiIntegral:function(h,l){var k=this.GetNext();if(k==="\\"){var j=this.i;k=this.GetArgument(h);this.i=j;if(k==="\\limits"){if(h==="\\idotsint"){l="\\!\\!\\mathop{\\,\\,"+l+"}"}else{l="\\!\\!\\!\\mathop{\\,\\,\\,"+l+"}"}}}this.string=l+" "+this.string.slice(this.i);this.i=0},xArrow:function(j,n,m,h){var k={width:"+"+(m+h)+"mu",lspace:m+"mu"};var o=this.GetBrackets(j),p=this.ParseArg(j);var q=b.mo(b.chars(String.fromCharCode(n))).With({stretchy:true,texClass:b.TEXCLASS.REL});var i=b.munderover(q);i.SetData(i.over,b.mpadded(p).With(k).With({voffset:".15em"}));if(o){o=g.Parse(o,this.stack.env).mml();i.SetData(i.under,b.mpadded(o).With(k).With({voffset:"-.24em"}))}this.Push(i.With({subsupOK:true}))},GetDelimiterArg:function(h){var i=this.trimSpaces(this.GetArgument(h));if(i==""){return null}if(i in d.delimiter){return i}g.Error(["MissingOrUnrecognizedDelim","Missing or unrecognized delimiter for %1",h])},GetStar:function(){var h=(this.GetNext()==="*");if(h){this.i++}return h}});e.Augment({autoTag:function(){var i=this.global;if(!i.notag){f.number++;i.tagID=a.formatNumber(f.number.toString());var h=g.Parse("\\text{"+a.formatTag(i.tagID)+"}",{}).mml();i.tag=b.mtd(h).With({id:a.formatID(i.tagID)})}},getTag:function(){var l=this.global,j=l.tag;l.tagged=true;if(l.label){if(a.useLabelIds){j.id=a.formatID(l.label)}f.eqlabels[l.label]={tag:l.tagID,id:j.id}}if(document.getElementById(j.id)||f.IDs[j.id]||f.eqIDs[j.id]){var k=0,h;do{k++;h=j.id+"_"+k}while(document.getElementById(h)||f.IDs[h]||f.eqIDs[h]);j.id=h;if(l.label){f.eqlabels[l.label].id=h}}f.eqIDs[j.id]=1;this.clearTag();return j},clearTag:function(){var h=this.global;delete h.tag;delete h.tagID;delete h.label},fixInitialMO:function(k){for(var j=0,h=k.length;j<h;j++){if(k[j]&&(k[j].type!=="mspace"&&(k[j].type!=="texatom"||(k[j].data[0]&&k[j].data[0].data.length)))){if(k[j].isEmbellished()){k.unshift(b.mi())}break}}}});e.multline=e.array.Subclass({type:"multline",Init:function(i,h){this.SUPER(arguments).Init.apply(this);this.numbered=(i&&a.autoNumber!=="none");this.save={notag:h.global.notag};h.global.tagged=!i&&!h.global.forcetag},EndEntry:function(){if(this.table.length){this.fixInitialMO(this.data)}var h=b.mtd.apply(b,this.data);if(this.data.shove){h.columnalign=this.data.shove}this.row.push(h);this.data=[]},EndRow:function(){if(this.row.length!=1){g.Error(["MultlineRowsOneCol","The rows within the %1 environment must have exactly one column","multline"])}this.table.push(this.row);this.row=[]},EndTable:function(){this.SUPER(arguments).EndTable.call(this);if(this.table.length){var j=this.table.length-1,l,k=-1;if(!this.table[0][0].columnalign){this.table[0][0].columnalign=b.ALIGN.LEFT}if(!this.table[j][0].columnalign){this.table[j][0].columnalign=b.ALIGN.RIGHT}if(!this.global.tag&&this.numbered){this.autoTag()}if(this.global.tag&&!this.global.notags){k=(this.arraydef.side==="left"?0:this.table.length-1);this.table[k]=[this.getTag()].concat(this.table[k])}for(l=0,j=this.table.length;l<j;l++){var h=(l===k?b.mlabeledtr:b.mtr);this.table[l]=h.apply(b,this.table[l])}}this.global.notag=this.save.notag}});e.AMSarray=e.array.Subclass({type:"AMSarray",Init:function(k,j,i,h){this.SUPER(arguments).Init.apply(this);this.numbered=(j&&a.autoNumber!=="none");this.save={notags:h.global.notags,notag:h.global.notag};h.global.notags=(i?null:k);h.global.tagged=!j&&!h.global.forcetag},EndEntry:function(){if(this.row.length){this.fixInitialMO(this.data)}this.row.push(b.mtd.apply(b,this.data));this.data=[]},EndRow:function(){var h=b.mtr;if(!this.global.tag&&this.numbered){this.autoTag()}if(this.global.tag&&!this.global.notags){this.row=[this.getTag()].concat(this.row);h=b.mlabeledtr}else{this.clearTag()}if(this.numbered){delete this.global.notag}this.table.push(h.apply(b,this.row));this.row=[]},EndTable:function(){this.SUPER(arguments).EndTable.call(this);this.global.notags=this.save.notags;this.global.notag=this.save.notag}});e.start.Augment({oldCheckItem:e.start.prototype.checkItem,checkItem:function(j){if(j.type==="stop"){var h=this.mmlData(),i=this.global;if(f.display&&!i.tag&&!i.tagged&&!i.isInner&&(a.autoNumber==="all"||i.forcetag)){this.autoTag()}if(i.tag){var l=[this.getTag(),b.mtd(h)];var k={side:g.config.TagSide,minlabelspacing:g.config.TagIndent,displaystyle:"inherit"};h=b.mtable(b.mlabeledtr.apply(b,l)).With(k)}return e.mml(h)}return this.oldCheckItem.call(this,j)}});g.prefilterHooks.Add(function(h){f.display=h.display;f.number=f.startNumber;f.eqlabels=f.eqIDs={};f.badref=false;if(f.refUpdate){f.number=h.script.MathJax.startNumber}});g.postfilterHooks.Add(function(h){h.script.MathJax.startNumber=f.startNumber;f.startNumber=f.number;MathJax.Hub.Insert(f.IDs,f.eqIDs);MathJax.Hub.Insert(f.labels,f.eqlabels);if(f.badref&&!h.math.texError){f.refs.push(h.script)}},100);MathJax.Hub.Register.MessageHook("Begin Math Input",function(){f.refs=[];f.refUpdate=false});MathJax.Hub.Register.MessageHook("End Math Input",function(k){if(f.refs.length){f.refUpdate=true;for(var j=0,h=f.refs.length;j<h;j++){f.refs[j].MathJax.state=MathJax.ElementJax.STATE.UPDATE}return MathJax.Hub.processInput({scripts:f.refs,start:new Date().getTime(),i:0,j:0,jax:{},jaxIDs:[]})}return null});g.resetEquationNumbers=function(i,h){f.startNumber=(i||0);if(!h){f.labels=f.IDs={}}};MathJax.Hub.Startup.signal.Post("TeX AMSmath Ready")});MathJax.Ajax.loadComplete("[MathJax]/extensions/TeX/AMSmath.js");
	MathJax.Extension["TeX/AMSsymbols"]={version:"2.6.0"};MathJax.Hub.Register.StartupHook("TeX Jax Ready",function(){var a=MathJax.ElementJax.mml,b=MathJax.InputJax.TeX.Definitions;b.Add({mathchar0mi:{digamma:"03DD",varkappa:"03F0",varGamma:["0393",{mathvariant:a.VARIANT.ITALIC}],varDelta:["0394",{mathvariant:a.VARIANT.ITALIC}],varTheta:["0398",{mathvariant:a.VARIANT.ITALIC}],varLambda:["039B",{mathvariant:a.VARIANT.ITALIC}],varXi:["039E",{mathvariant:a.VARIANT.ITALIC}],varPi:["03A0",{mathvariant:a.VARIANT.ITALIC}],varSigma:["03A3",{mathvariant:a.VARIANT.ITALIC}],varUpsilon:["03A5",{mathvariant:a.VARIANT.ITALIC}],varPhi:["03A6",{mathvariant:a.VARIANT.ITALIC}],varPsi:["03A8",{mathvariant:a.VARIANT.ITALIC}],varOmega:["03A9",{mathvariant:a.VARIANT.ITALIC}],beth:"2136",gimel:"2137",daleth:"2138",backprime:["2035",{variantForm:true}],hslash:"210F",varnothing:["2205",{variantForm:true}],blacktriangle:"25B4",triangledown:["25BD",{variantForm:true}],blacktriangledown:"25BE",square:"25FB",Box:"25FB",blacksquare:"25FC",lozenge:"25CA",Diamond:"25CA",blacklozenge:"29EB",circledS:["24C8",{mathvariant:a.VARIANT.NORMAL}],bigstar:"2605",sphericalangle:"2222",measuredangle:"2221",nexists:"2204",complement:"2201",mho:"2127",eth:["00F0",{mathvariant:a.VARIANT.NORMAL}],Finv:"2132",diagup:"2571",Game:"2141",diagdown:"2572",Bbbk:["006B",{mathvariant:a.VARIANT.DOUBLESTRUCK}],yen:"00A5",circledR:"00AE",checkmark:"2713",maltese:"2720"},mathchar0mo:{dotplus:"2214",ltimes:"22C9",smallsetminus:"2216",rtimes:"22CA",Cap:"22D2",doublecap:"22D2",leftthreetimes:"22CB",Cup:"22D3",doublecup:"22D3",rightthreetimes:"22CC",barwedge:"22BC",curlywedge:"22CF",veebar:"22BB",curlyvee:"22CE",doublebarwedge:"2A5E",boxminus:"229F",circleddash:"229D",boxtimes:"22A0",circledast:"229B",boxdot:"22A1",circledcirc:"229A",boxplus:"229E",centerdot:["22C5",{variantForm:true}],divideontimes:"22C7",intercal:"22BA",leqq:"2266",geqq:"2267",leqslant:"2A7D",geqslant:"2A7E",eqslantless:"2A95",eqslantgtr:"2A96",lesssim:"2272",gtrsim:"2273",lessapprox:"2A85",gtrapprox:"2A86",approxeq:"224A",lessdot:"22D6",gtrdot:"22D7",lll:"22D8",llless:"22D8",ggg:"22D9",gggtr:"22D9",lessgtr:"2276",gtrless:"2277",lesseqgtr:"22DA",gtreqless:"22DB",lesseqqgtr:"2A8B",gtreqqless:"2A8C",doteqdot:"2251",Doteq:"2251",eqcirc:"2256",risingdotseq:"2253",circeq:"2257",fallingdotseq:"2252",triangleq:"225C",backsim:"223D",thicksim:["223C",{variantForm:true}],backsimeq:"22CD",thickapprox:["2248",{variantForm:true}],subseteqq:"2AC5",supseteqq:"2AC6",Subset:"22D0",Supset:"22D1",sqsubset:"228F",sqsupset:"2290",preccurlyeq:"227C",succcurlyeq:"227D",curlyeqprec:"22DE",curlyeqsucc:"22DF",precsim:"227E",succsim:"227F",precapprox:"2AB7",succapprox:"2AB8",vartriangleleft:"22B2",lhd:"22B2",vartriangleright:"22B3",rhd:"22B3",trianglelefteq:"22B4",unlhd:"22B4",trianglerighteq:"22B5",unrhd:"22B5",vDash:"22A8",Vdash:"22A9",Vvdash:"22AA",smallsmile:["2323",{variantForm:true}],shortmid:["2223",{variantForm:true}],smallfrown:["2322",{variantForm:true}],shortparallel:["2225",{variantForm:true}],bumpeq:"224F",between:"226C",Bumpeq:"224E",pitchfork:"22D4",varpropto:"221D",backepsilon:"220D",blacktriangleleft:"25C2",blacktriangleright:"25B8",therefore:"2234",because:"2235",eqsim:"2242",vartriangle:["25B3",{variantForm:true}],Join:"22C8",nless:"226E",ngtr:"226F",nleq:"2270",ngeq:"2271",nleqslant:["2A87",{variantForm:true}],ngeqslant:["2A88",{variantForm:true}],nleqq:["2270",{variantForm:true}],ngeqq:["2271",{variantForm:true}],lneq:"2A87",gneq:"2A88",lneqq:"2268",gneqq:"2269",lvertneqq:["2268",{variantForm:true}],gvertneqq:["2269",{variantForm:true}],lnsim:"22E6",gnsim:"22E7",lnapprox:"2A89",gnapprox:"2A8A",nprec:"2280",nsucc:"2281",npreceq:["22E0",{variantForm:true}],nsucceq:["22E1",{variantForm:true}],precneqq:"2AB5",succneqq:"2AB6",precnsim:"22E8",succnsim:"22E9",precnapprox:"2AB9",succnapprox:"2ABA",nsim:"2241",ncong:"2246",nshortmid:["2224",{variantForm:true}],nshortparallel:["2226",{variantForm:true}],nmid:"2224",nparallel:"2226",nvdash:"22AC",nvDash:"22AD",nVdash:"22AE",nVDash:"22AF",ntriangleleft:"22EA",ntriangleright:"22EB",ntrianglelefteq:"22EC",ntrianglerighteq:"22ED",nsubseteq:"2288",nsupseteq:"2289",nsubseteqq:["2288",{variantForm:true}],nsupseteqq:["2289",{variantForm:true}],subsetneq:"228A",supsetneq:"228B",varsubsetneq:["228A",{variantForm:true}],varsupsetneq:["228B",{variantForm:true}],subsetneqq:"2ACB",supsetneqq:"2ACC",varsubsetneqq:["2ACB",{variantForm:true}],varsupsetneqq:["2ACC",{variantForm:true}],leftleftarrows:"21C7",rightrightarrows:"21C9",leftrightarrows:"21C6",rightleftarrows:"21C4",Lleftarrow:"21DA",Rrightarrow:"21DB",twoheadleftarrow:"219E",twoheadrightarrow:"21A0",leftarrowtail:"21A2",rightarrowtail:"21A3",looparrowleft:"21AB",looparrowright:"21AC",leftrightharpoons:"21CB",rightleftharpoons:["21CC",{variantForm:true}],curvearrowleft:"21B6",curvearrowright:"21B7",circlearrowleft:"21BA",circlearrowright:"21BB",Lsh:"21B0",Rsh:"21B1",upuparrows:"21C8",downdownarrows:"21CA",upharpoonleft:"21BF",upharpoonright:"21BE",downharpoonleft:"21C3",restriction:"21BE",multimap:"22B8",downharpoonright:"21C2",leftrightsquigarrow:"21AD",rightsquigarrow:"21DD",leadsto:"21DD",dashrightarrow:"21E2",dashleftarrow:"21E0",nleftarrow:"219A",nrightarrow:"219B",nLeftarrow:"21CD",nRightarrow:"21CF",nleftrightarrow:"21AE",nLeftrightarrow:"21CE"},delimiter:{"\\ulcorner":"231C","\\urcorner":"231D","\\llcorner":"231E","\\lrcorner":"231F"},macros:{implies:["Macro","\\;\\Longrightarrow\\;"],impliedby:["Macro","\\;\\Longleftarrow\\;"]}},null,true);var c=a.mo.OPTYPES.REL;MathJax.Hub.Insert(a.mo.prototype,{OPTABLE:{infix:{"\u2322":c,"\u2323":c,"\u25B3":c,"\uE006":c,"\uE007":c,"\uE00C":c,"\uE00D":c,"\uE00E":c,"\uE00F":c,"\uE010":c,"\uE011":c,"\uE016":c,"\uE017":c,"\uE018":c,"\uE019":c,"\uE01A":c,"\uE01B":c,"\uE04B":c,"\uE04F":c}}});MathJax.Hub.Startup.signal.Post("TeX AMSsymbols Ready")});MathJax.Ajax.loadComplete("[MathJax]/extensions/TeX/AMSsymbols.js");
	(function(c,d){var a;var b=function(e){return MathJax.Localization._.apply(MathJax.Localization,[["MathML",e]].concat([].slice.call(arguments,1)))};c.Parse=MathJax.Object.Subclass({Init:function(f,e){this.Parse(f,e)},Parse:function(h,e){var j;if(typeof h!=="string"){j=h.parentNode}else{j=c.ParseXML(this.preProcessMath.call(this,h));if(j==null){c.Error(["ErrorParsingMathML","Error parsing MathML"])}}var g=j.getElementsByTagName("parsererror")[0];if(g){c.Error(["ParsingError","Error parsing MathML: %1",g.textContent.replace(/This page.*?errors:|XML Parsing Error: |Below is a rendering of the page.*/g,"")])}if(j.childNodes.length!==1){c.Error(["MathMLSingleElement","MathML must be formed by a single element"])}if(j.firstChild.nodeName.toLowerCase()==="html"){var f=j.getElementsByTagName("h1")[0];if(f&&f.textContent==="XML parsing error"&&f.nextSibling){c.Error(["ParsingError","Error parsing MathML: %1",String(f.nextSibling.nodeValue).replace(/fatal parsing error: /,"")])}}if(j.firstChild.nodeName.toLowerCase().replace(/^[a-z]+:/,"")!=="math"){c.Error(["MathMLRootElement","MathML must be formed by a <math> element, not %1","<"+j.firstChild.nodeName+">"])}var i={math:j.firstChild,script:e};c.DOMfilterHooks.Execute(i);this.mml=this.MakeMML(i.math)},MakeMML:function(h){var i=String(h.getAttribute("class")||"");var f,g=h.nodeName.toLowerCase().replace(/^[a-z]+:/,"");var e=(i.match(/(^| )MJX-TeXAtom-([^ ]*)/));if(e){f=this.TeXAtom(e[2],e[2]==="OP"&&!i.match(/MJX-fixedlimits/))}else{if(!(a[g]&&a[g].isa&&a[g].isa(a.mbase))){MathJax.Hub.signal.Post(["MathML Jax - unknown node type",g]);return a.Error(b("UnknownNodeType","Unknown node type: %1",g))}else{f=a[g]()}}this.AddAttributes(f,h);this.CheckClass(f,f["class"]);this.AddChildren(f,h);if(c.config.useMathMLspacing){f.useMMLspacing=8}return f},TeXAtom:function(g,f){var e=a.TeXAtom().With({texClass:a.TEXCLASS[g]});if(f){e.movesupsub=e.movablelimits=true}return e},CheckClass:function(f,h){h=(h||"").split(/ /);var j=[];for(var g=0,e=h.length;g<e;g++){if(h[g].substr(0,4)==="MJX-"){if(h[g]==="MJX-arrow"){if(!f.notation.match("/"+a.NOTATION.UPDIAGONALARROW+"/")){f.notation+=" "+a.NOTATION.UPDIAGONALARROW}}else{if(h[g]==="MJX-variant"){f.variantForm=true;if(!MathJax.Extension["TeX/AMSsymbols"]){MathJax.Hub.RestartAfter(MathJax.Ajax.Require("[MathJax]/extensions/TeX/AMSsymbols.js"))}}else{if(h[g].substr(0,11)!=="MJX-TeXAtom"){f.mathvariant=h[g].substr(3);if(f.mathvariant==="-tex-caligraphic-bold"||f.mathvariant==="-tex-oldstyle-bold"){if(!MathJax.Extension["TeX/boldsymbol"]){MathJax.Hub.RestartAfter(MathJax.Ajax.Require("[MathJax]/extensions/TeX/boldsymbol.js"))}}}}}}else{j.push(h[g])}}if(j.length){f["class"]=j.join(" ")}else{delete f["class"]}},AddAttributes:function(g,j){g.attr={};g.attrNames=[];for(var h=0,e=j.attributes.length;h<e;h++){var f=j.attributes[h].name;if(f=="xlink:href"){f="href"}if(f.match(/:/)){continue}if(f.match(/^_moz-math-((column|row)(align|line)|font-style)$/)){continue}var k=j.attributes[h].value;k=this.filterAttribute(f,k);var l=(g.type==="mstyle"?a.math.prototype.defaults:g.defaults);if(k!=null){if(k.toLowerCase()==="true"){k=true}else{if(k.toLowerCase()==="false"){k=false}}if(l[f]!=null||a.copyAttributes[f]){g[f]=k}else{g.attr[f]=k}g.attrNames.push(f)}}},filterAttribute:function(e,f){return f},AddChildren:function(e,g){for(var k=0,j=g.childNodes.length;k<j;k++){var f=g.childNodes[k];if(f.nodeName==="#comment"){continue}if(f.nodeName==="#text"){if((e.isToken||e.isChars)&&!e.mmlSelfClosing){var o=f.nodeValue;if(e.isToken){o=o.replace(/&([a-z][a-z0-9]*);/ig,this.replaceEntity);o=this.trimSpace(o)}e.Append(a.chars(o))}else{if(f.nodeValue.match(/\S/)){c.Error(["UnexpectedTextNode","Unexpected text node: %1","'"+f.nodeValue+"'"])}}}else{if(e.type==="annotation-xml"){e.Append(a.xml(f))}else{var h=this.MakeMML(f);e.Append(h);if(h.mmlSelfClosing&&h.data.length){e.Append.apply(e,h.data);h.data=[]}}}}if(e.type==="mrow"&&e.data.length>=2){var l=e.data[0],n=e.data[e.data.length-1];if(l.type==="mo"&&l.Get("fence")&&n.type==="mo"&&n.Get("fence")){if(l.data[0]){e.open=l.data.join("")}if(n.data[0]){e.close=n.data.join("")}}}},preProcessMath:function(f){if(f.match(/^<[a-z]+:/i)&&!f.match(/^<[^<>]* xmlns:/)){f=f.replace(/^<([a-z]+)(:math)/i,'<$1$2 xmlns:$1="http://www.w3.org/1998/Math/MathML"')}var e=f.match(/^(<math( ('.*?'|".*?"|[^>])+)>)/i);if(e&&e[2].match(/ (?!xmlns=)[a-z]+=\"http:/i)){f=e[1].replace(/ (?!xmlns=)([a-z]+=(['"])http:.*?\2)/ig," xmlns:$1 $1")+f.substr(e[0].length)}if(f.match(/^<math/i)&&!f.match(/^<[^<>]* xmlns=/)){f=f.replace(/^<(math)/i,'<math xmlns="http://www.w3.org/1998/Math/MathML"')}f=f.replace(/^\s*(?:\/\/)?<!(--)?\[CDATA\[((.|\n)*)(\/\/)?\]\]\1>\s*$/,"$2");return f.replace(/&([a-z][a-z0-9]*);/ig,this.replaceEntity)},trimSpace:function(e){return e.replace(/[\t\n\r]/g," ").replace(/^ +/,"").replace(/ +$/,"").replace(/  +/g," ")},replaceEntity:function(g,f){if(f.match(/^(lt|amp|quot)$/)){return g}if(c.Parse.Entity[f]){return c.Parse.Entity[f]}var h=f.charAt(0).toLowerCase();var e=f.match(/^[a-zA-Z](fr|scr|opf)$/);if(e){h=e[1]}if(!c.Parse.loaded[h]){c.Parse.loaded[h]=true;MathJax.Hub.RestartAfter(MathJax.Ajax.Require(c.entityDir+"/"+h+".js"))}return g}},{loaded:[]});c.Augment({sourceMenuTitle:["OriginalMathML","Original MathML"],prefilterHooks:MathJax.Callback.Hooks(true),DOMfilterHooks:MathJax.Callback.Hooks(true),postfilterHooks:MathJax.Callback.Hooks(true),Translate:function(e){if(!this.ParseXML){this.ParseXML=this.createParser()}var f,h,i={script:e};if(e.firstChild&&e.firstChild.nodeName.toLowerCase().replace(/^[a-z]+:/,"")==="math"){i.math=e.firstChild}else{h=MathJax.HTML.getScript(e);if(d.isMSIE){h=h.replace(/(&nbsp;)+$/,"")}i.math=h}var j=this.prefilterHooks.Execute(i);if(j){return j}h=i.math;try{f=c.Parse(h,e).mml}catch(g){if(!g.mathmlError){throw g}f=this.formatError(g,h,e)}i.math=a(f);return this.postfilterHooks.Execute(i)||i.math},prefilterMath:function(f,e){return f},prefilterMathML:function(f,e){return f},formatError:function(h,g,e){var f=h.message.replace(/\n.*/,"");MathJax.Hub.signal.Post(["MathML Jax - parse error",f,g,e]);return a.Error(f)},Error:function(e){if(e instanceof Array){e=b.apply(b,e)}throw MathJax.Hub.Insert(Error(e),{mathmlError:true})},parseDOM:function(e){return this.parser.parseFromString(e,"text/xml")},parseMS:function(e){return(this.parser.loadXML(e)?this.parser:null)},parseDIV:function(e){this.div.innerHTML="<div>"+e.replace(/<([a-z]+)([^>]*)\/>/g,"<$1$2></$1>")+"</div>";var f=this.div.firstChild;this.div.innerHTML="";return f},parseError:function(e){return null},createMSParser:function(){var j=null;var f=["MSXML2.DOMDocument.6.0","MSXML2.DOMDocument.5.0","MSXML2.DOMDocument.4.0","MSXML2.DOMDocument.3.0","MSXML2.DOMDocument.2.0","Microsoft.XMLDOM"];for(var g=0,e=f.length;g<e&&!j;g++){try{j=new ActiveXObject(f[g])}catch(h){}}return j},createParser:function(){if(window.DOMParser){this.parser=new DOMParser();return(this.parseDOM)}else{if(window.ActiveXObject){this.parser=this.createMSParser();if(!this.parser){MathJax.Localization.Try(this.parserCreationError);return(this.parseError)}this.parser.async=false;return(this.parseMS)}}this.div=MathJax.Hub.Insert(document.createElement("div"),{style:{visibility:"hidden",overflow:"hidden",height:"1px",position:"absolute",top:0}});if(!document.body.firstChild){document.body.appendChild(this.div)}else{document.body.insertBefore(this.div,document.body.firstChild)}return(this.parseDIV)},parserCreationError:function(){alert(b("CantCreateXMLParser","MathJax can't create an XML parser for MathML.  Check that\nthe 'Script ActiveX controls marked safe for scripting' security\nsetting is enabled (use the Internet Options item in the Tools\nmenu, and select the Security panel, then press the Custom Level\nbutton to check this).\n\nMathML equations will not be able to be processed by MathJax."))},Startup:function(){a=MathJax.ElementJax.mml;a.mspace.Augment({mmlSelfClosing:true});a.none.Augment({mmlSelfClosing:true});a.mprescripts.Augment({mmlSelfClosing:true});a.maligngroup.Augment({mmlSelfClosing:true});a.malignmark.Augment({mmlSelfClosing:true})}});c.prefilterHooks.Add(function(e){e.math=(typeof(e.math)==="string"?c.prefilterMath(e.math,e.script):c.prefilterMathML(e.math,e.script))});c.Parse.Entity={ApplyFunction:"\u2061",Backslash:"\u2216",Because:"\u2235",Breve:"\u02D8",Cap:"\u22D2",CenterDot:"\u00B7",CircleDot:"\u2299",CircleMinus:"\u2296",CirclePlus:"\u2295",CircleTimes:"\u2297",Congruent:"\u2261",ContourIntegral:"\u222E",Coproduct:"\u2210",Cross:"\u2A2F",Cup:"\u22D3",CupCap:"\u224D",Dagger:"\u2021",Del:"\u2207",Delta:"\u0394",Diamond:"\u22C4",DifferentialD:"\u2146",DotEqual:"\u2250",DoubleDot:"\u00A8",DoubleRightTee:"\u22A8",DoubleVerticalBar:"\u2225",DownArrow:"\u2193",DownLeftVector:"\u21BD",DownRightVector:"\u21C1",DownTee:"\u22A4",Downarrow:"\u21D3",Element:"\u2208",EqualTilde:"\u2242",Equilibrium:"\u21CC",Exists:"\u2203",ExponentialE:"\u2147",FilledVerySmallSquare:"\u25AA",ForAll:"\u2200",Gamma:"\u0393",Gg:"\u22D9",GreaterEqual:"\u2265",GreaterEqualLess:"\u22DB",GreaterFullEqual:"\u2267",GreaterLess:"\u2277",GreaterSlantEqual:"\u2A7E",GreaterTilde:"\u2273",Hacek:"\u02C7",Hat:"\u005E",HumpDownHump:"\u224E",HumpEqual:"\u224F",Im:"\u2111",ImaginaryI:"\u2148",Integral:"\u222B",Intersection:"\u22C2",InvisibleComma:"\u2063",InvisibleTimes:"\u2062",Lambda:"\u039B",Larr:"\u219E",LeftAngleBracket:"\u27E8",LeftArrow:"\u2190",LeftArrowRightArrow:"\u21C6",LeftCeiling:"\u2308",LeftDownVector:"\u21C3",LeftFloor:"\u230A",LeftRightArrow:"\u2194",LeftTee:"\u22A3",LeftTriangle:"\u22B2",LeftTriangleEqual:"\u22B4",LeftUpVector:"\u21BF",LeftVector:"\u21BC",Leftarrow:"\u21D0",Leftrightarrow:"\u21D4",LessEqualGreater:"\u22DA",LessFullEqual:"\u2266",LessGreater:"\u2276",LessSlantEqual:"\u2A7D",LessTilde:"\u2272",Ll:"\u22D8",Lleftarrow:"\u21DA",LongLeftArrow:"\u27F5",LongLeftRightArrow:"\u27F7",LongRightArrow:"\u27F6",Longleftarrow:"\u27F8",Longleftrightarrow:"\u27FA",Longrightarrow:"\u27F9",Lsh:"\u21B0",MinusPlus:"\u2213",NestedGreaterGreater:"\u226B",NestedLessLess:"\u226A",NotDoubleVerticalBar:"\u2226",NotElement:"\u2209",NotEqual:"\u2260",NotExists:"\u2204",NotGreater:"\u226F",NotGreaterEqual:"\u2271",NotLeftTriangle:"\u22EA",NotLeftTriangleEqual:"\u22EC",NotLess:"\u226E",NotLessEqual:"\u2270",NotPrecedes:"\u2280",NotPrecedesSlantEqual:"\u22E0",NotRightTriangle:"\u22EB",NotRightTriangleEqual:"\u22ED",NotSubsetEqual:"\u2288",NotSucceeds:"\u2281",NotSucceedsSlantEqual:"\u22E1",NotSupersetEqual:"\u2289",NotTilde:"\u2241",NotVerticalBar:"\u2224",Omega:"\u03A9",OverBar:"\u203E",OverBrace:"\u23DE",PartialD:"\u2202",Phi:"\u03A6",Pi:"\u03A0",PlusMinus:"\u00B1",Precedes:"\u227A",PrecedesEqual:"\u2AAF",PrecedesSlantEqual:"\u227C",PrecedesTilde:"\u227E",Product:"\u220F",Proportional:"\u221D",Psi:"\u03A8",Rarr:"\u21A0",Re:"\u211C",ReverseEquilibrium:"\u21CB",RightAngleBracket:"\u27E9",RightArrow:"\u2192",RightArrowLeftArrow:"\u21C4",RightCeiling:"\u2309",RightDownVector:"\u21C2",RightFloor:"\u230B",RightTee:"\u22A2",RightTeeArrow:"\u21A6",RightTriangle:"\u22B3",RightTriangleEqual:"\u22B5",RightUpVector:"\u21BE",RightVector:"\u21C0",Rightarrow:"\u21D2",Rrightarrow:"\u21DB",Rsh:"\u21B1",Sigma:"\u03A3",SmallCircle:"\u2218",Sqrt:"\u221A",Square:"\u25A1",SquareIntersection:"\u2293",SquareSubset:"\u228F",SquareSubsetEqual:"\u2291",SquareSuperset:"\u2290",SquareSupersetEqual:"\u2292",SquareUnion:"\u2294",Star:"\u22C6",Subset:"\u22D0",SubsetEqual:"\u2286",Succeeds:"\u227B",SucceedsEqual:"\u2AB0",SucceedsSlantEqual:"\u227D",SucceedsTilde:"\u227F",SuchThat:"\u220B",Sum:"\u2211",Superset:"\u2283",SupersetEqual:"\u2287",Supset:"\u22D1",Therefore:"\u2234",Theta:"\u0398",Tilde:"\u223C",TildeEqual:"\u2243",TildeFullEqual:"\u2245",TildeTilde:"\u2248",UnderBar:"\u005F",UnderBrace:"\u23DF",Union:"\u22C3",UnionPlus:"\u228E",UpArrow:"\u2191",UpDownArrow:"\u2195",UpTee:"\u22A5",Uparrow:"\u21D1",Updownarrow:"\u21D5",Upsilon:"\u03A5",Vdash:"\u22A9",Vee:"\u22C1",VerticalBar:"\u2223",VerticalTilde:"\u2240",Vvdash:"\u22AA",Wedge:"\u22C0",Xi:"\u039E",acute:"\u00B4",aleph:"\u2135",alpha:"\u03B1",amalg:"\u2A3F",and:"\u2227",ang:"\u2220",angmsd:"\u2221",angsph:"\u2222",ape:"\u224A",backprime:"\u2035",backsim:"\u223D",backsimeq:"\u22CD",beta:"\u03B2",beth:"\u2136",between:"\u226C",bigcirc:"\u25EF",bigodot:"\u2A00",bigoplus:"\u2A01",bigotimes:"\u2A02",bigsqcup:"\u2A06",bigstar:"\u2605",bigtriangledown:"\u25BD",bigtriangleup:"\u25B3",biguplus:"\u2A04",blacklozenge:"\u29EB",blacktriangle:"\u25B4",blacktriangledown:"\u25BE",blacktriangleleft:"\u25C2",bowtie:"\u22C8",boxdl:"\u2510",boxdr:"\u250C",boxminus:"\u229F",boxplus:"\u229E",boxtimes:"\u22A0",boxul:"\u2518",boxur:"\u2514",bsol:"\u005C",bull:"\u2022",cap:"\u2229",check:"\u2713",chi:"\u03C7",circ:"\u02C6",circeq:"\u2257",circlearrowleft:"\u21BA",circlearrowright:"\u21BB",circledR:"\u00AE",circledS:"\u24C8",circledast:"\u229B",circledcirc:"\u229A",circleddash:"\u229D",clubs:"\u2663",colon:"\u003A",comp:"\u2201",ctdot:"\u22EF",cuepr:"\u22DE",cuesc:"\u22DF",cularr:"\u21B6",cup:"\u222A",curarr:"\u21B7",curlyvee:"\u22CE",curlywedge:"\u22CF",dagger:"\u2020",daleth:"\u2138",ddarr:"\u21CA",deg:"\u00B0",delta:"\u03B4",digamma:"\u03DD",div:"\u00F7",divideontimes:"\u22C7",dot:"\u02D9",doteqdot:"\u2251",dotplus:"\u2214",dotsquare:"\u22A1",dtdot:"\u22F1",ecir:"\u2256",efDot:"\u2252",egs:"\u2A96",ell:"\u2113",els:"\u2A95",empty:"\u2205",epsi:"\u03B5",epsiv:"\u03F5",erDot:"\u2253",eta:"\u03B7",eth:"\u00F0",flat:"\u266D",fork:"\u22D4",frown:"\u2322",gEl:"\u2A8C",gamma:"\u03B3",gap:"\u2A86",gimel:"\u2137",gnE:"\u2269",gnap:"\u2A8A",gne:"\u2A88",gnsim:"\u22E7",gt:"\u003E",gtdot:"\u22D7",harrw:"\u21AD",hbar:"\u210F",hellip:"\u2026",hookleftarrow:"\u21A9",hookrightarrow:"\u21AA",imath:"\u0131",infin:"\u221E",intcal:"\u22BA",iota:"\u03B9",jmath:"\u0237",kappa:"\u03BA",kappav:"\u03F0",lEg:"\u2A8B",lambda:"\u03BB",lap:"\u2A85",larrlp:"\u21AB",larrtl:"\u21A2",lbrace:"\u007B",lbrack:"\u005B",le:"\u2264",leftleftarrows:"\u21C7",leftthreetimes:"\u22CB",lessdot:"\u22D6",lmoust:"\u23B0",lnE:"\u2268",lnap:"\u2A89",lne:"\u2A87",lnsim:"\u22E6",longmapsto:"\u27FC",looparrowright:"\u21AC",lowast:"\u2217",loz:"\u25CA",lt:"\u003C",ltimes:"\u22C9",ltri:"\u25C3",macr:"\u00AF",malt:"\u2720",mho:"\u2127",mu:"\u03BC",multimap:"\u22B8",nLeftarrow:"\u21CD",nLeftrightarrow:"\u21CE",nRightarrow:"\u21CF",nVDash:"\u22AF",nVdash:"\u22AE",natur:"\u266E",nearr:"\u2197",nharr:"\u21AE",nlarr:"\u219A",not:"\u00AC",nrarr:"\u219B",nu:"\u03BD",nvDash:"\u22AD",nvdash:"\u22AC",nwarr:"\u2196",omega:"\u03C9",omicron:"\u03BF",or:"\u2228",osol:"\u2298",period:"\u002E",phi:"\u03C6",phiv:"\u03D5",pi:"\u03C0",piv:"\u03D6",prap:"\u2AB7",precnapprox:"\u2AB9",precneqq:"\u2AB5",precnsim:"\u22E8",prime:"\u2032",psi:"\u03C8",rarrtl:"\u21A3",rbrace:"\u007D",rbrack:"\u005D",rho:"\u03C1",rhov:"\u03F1",rightrightarrows:"\u21C9",rightthreetimes:"\u22CC",ring:"\u02DA",rmoust:"\u23B1",rtimes:"\u22CA",rtri:"\u25B9",scap:"\u2AB8",scnE:"\u2AB6",scnap:"\u2ABA",scnsim:"\u22E9",sdot:"\u22C5",searr:"\u2198",sect:"\u00A7",sharp:"\u266F",sigma:"\u03C3",sigmav:"\u03C2",simne:"\u2246",smile:"\u2323",spades:"\u2660",sub:"\u2282",subE:"\u2AC5",subnE:"\u2ACB",subne:"\u228A",supE:"\u2AC6",supnE:"\u2ACC",supne:"\u228B",swarr:"\u2199",tau:"\u03C4",theta:"\u03B8",thetav:"\u03D1",tilde:"\u02DC",times:"\u00D7",triangle:"\u25B5",triangleq:"\u225C",upsi:"\u03C5",upuparrows:"\u21C8",veebar:"\u22BB",vellip:"\u22EE",weierp:"\u2118",xi:"\u03BE",yen:"\u00A5",zeta:"\u03B6",zigrarr:"\u21DD"};c.loadComplete("jax.js")})(MathJax.InputJax.MathML,MathJax.Hub.Browser);
	(function(i,b,e,g){var h;var j,a,d;var f="'Times New Roman',Times,STIXGeneral,serif";var m={".MJXp-script":{"font-size":".8em"},".MJXp-right":{"-webkit-transform-origin":"right","-moz-transform-origin":"right","-ms-transform-origin":"right","-o-transform-origin":"right","transform-origin":"right"},".MJXp-bold":{"font-weight":"bold"},".MJXp-italic":{"font-style":"italic"},".MJXp-scr":{"font-family":"MathJax_Script,"+f},".MJXp-frak":{"font-family":"MathJax_Fraktur,"+f},".MJXp-sf":{"font-family":"MathJax_SansSerif,"+f},".MJXp-cal":{"font-family":"MathJax_Caligraphic,"+f},".MJXp-mono":{"font-family":"MathJax_Typewriter,"+f},".MJXp-largeop":{"font-size":"150%"},".MJXp-largeop.MJXp-int":{"vertical-align":"-.2em"},".MJXp-math":{display:"inline-block","line-height":"1.2","text-indent":"0","font-family":f,"white-space":"nowrap","border-collapse":"collapse"},".MJXp-display":{display:"block","text-align":"center",margin:"1em 0"},".MJXp-math span":{display:"inline-block"},".MJXp-box":{display:"block!important","text-align":"center"},".MJXp-box:after":{content:'" "'},".MJXp-rule":{display:"block!important","margin-top":".1em"},".MJXp-char":{display:"block!important"},".MJXp-mo":{margin:"0 .15em"},".MJXp-mfrac":{margin:"0 .125em","vertical-align":".25em"},".MJXp-denom":{display:"inline-table!important",width:"100%"},".MJXp-denom > *":{display:"table-row!important"},".MJXp-surd":{"vertical-align":"top"},".MJXp-surd > *":{display:"block!important"},".MJXp-script-box > * ":{display:"table!important",height:"50%"},".MJXp-script-box > * > *":{display:"table-cell!important","vertical-align":"top"},".MJXp-script-box > *:last-child > *":{"vertical-align":"bottom"},".MJXp-script-box > * > * > *":{display:"block!important"},".MJXp-mphantom":{visibility:"hidden"},".MJXp-munderover":{display:"inline-table!important"},".MJXp-over":{display:"inline-block!important","text-align":"center"},".MJXp-over > *":{display:"block!important"},".MJXp-munderover > *":{display:"table-row!important"},".MJXp-mtable":{"vertical-align":".25em",margin:"0 .125em"},".MJXp-mtable > *":{display:"inline-table!important","vertical-align":"middle"},".MJXp-mtr":{display:"table-row!important"},".MJXp-mtd":{display:"table-cell!important","text-align":"center",padding:".5em 0 0 .5em"},".MJXp-mtr > .MJXp-mtd:first-child":{"padding-left":0},".MJXp-mtr:first-child > .MJXp-mtd":{"padding-top":0},".MJXp-mlabeledtr":{display:"table-row!important"},".MJXp-mlabeledtr > .MJXp-mtd:first-child":{"padding-left":0},".MJXp-mlabeledtr:first-child > .MJXp-mtd":{"padding-top":0},".MJXp-merror":{"background-color":"#FFFF88",color:"#CC0000",border:"1px solid #CC0000",padding:"1px 3px","font-style":"normal","font-size":"90%"}};(function(){for(var n=0;n<10;n++){var o="scaleX(."+n+")";m[".MJXp-scale"+n]={"-webkit-transform":o,"-moz-transform":o,"-ms-transform":o,"-o-transform":o,transform:o}}})();var k=1000000;var c="V",l="H";g.Augment({settings:b.config.menuSettings,config:{styles:m},hideProcessedMath:false,maxStretchyParts:1000,Config:function(){if(!this.require){this.require=[]}this.SUPER(arguments).Config.call(this);var n=this.settings;if(n.scale){this.config.scale=n.scale}this.require.push(MathJax.OutputJax.extensionDir+"/MathEvents.js")},Startup:function(){j=MathJax.Extension.MathEvents.Event;a=MathJax.Extension.MathEvents.Touch;d=MathJax.Extension.MathEvents.Hover;this.ContextMenu=j.ContextMenu;this.Mousedown=j.AltContextMenu;this.Mouseover=d.Mouseover;this.Mouseout=d.Mouseout;this.Mousemove=d.Mousemove;var n=e.addElement(document.body,"div",{style:{width:"5in"}});this.pxPerInch=n.offsetWidth/5;n.parentNode.removeChild(n);return i.Styles(this.config.styles,["InitializePHTML",this])},InitializePHTML:function(){},preTranslate:function(p){var s=p.jax[this.id],t,q=s.length,u,r,v,o,n;for(t=0;t<q;t++){u=s[t];if(!u.parentNode){continue}r=u.previousSibling;if(r&&String(r.className).match(/^MathJax_PHTML(_Display)?( MathJax_Processing)?$/)){r.parentNode.removeChild(r)}n=u.MathJax.elementJax;if(!n){continue}n.PHTML={display:(n.root.Get("display")==="block")};v=o=e.Element("span",{className:"MathJax_PHTML",id:n.inputID+"-Frame",isMathJax:true,jaxID:this.id,oncontextmenu:j.Menu,onmousedown:j.Mousedown,onmouseover:j.Mouseover,onmouseout:j.Mouseout,onmousemove:j.Mousemove,onclick:j.Click,ondblclick:j.DblClick,onkeydown:j.Keydown,tabIndex:b.getTabOrder(n)});if(b.Browser.noContextMenu){v.ontouchstart=a.start;v.ontouchend=a.end}if(n.PHTML.display){o=e.Element("div",{className:"MathJax_PHTML_Display"});o.appendChild(v)}o.className+=" MathJax_Processing";u.parentNode.insertBefore(o,u)}},Translate:function(o,s){if(!o.parentNode){return}var n=o.MathJax.elementJax,r=n.root,p=document.getElementById(n.inputID+"-Frame"),t=(n.PHTML.display?p.parentNode:p);this.initPHTML(r,p);try{r.toPreviewHTML(p)}catch(q){if(q.restart){while(p.firstChild){p.removeChild(p.firstChild)}}throw q}t.className=t.className.split(/ /)[0];if(this.hideProcessedMath){t.className+=" MathJax_Processed";if(o.MathJax.preview){n.PHTML.preview=o.MathJax.preview;delete o.MathJax.preview}}},postTranslate:function(s){var o=s.jax[this.id];if(!this.hideProcessedMath){return}for(var q=0,n=o.length;q<n;q++){var p=o[q];if(p&&p.MathJax.elementJax){p.previousSibling.className=p.previousSibling.className.split(/ /)[0];var r=p.MathJax.elementJax.PHTML;if(r.preview){r.preview.innerHTML="";p.MathJax.preview=r.preview;delete r.preview}}}},getJaxFromMath:function(n){if(n.parentNode.className==="MathJax_PHTML_Display"){n=n.parentNode}do{n=n.nextSibling}while(n&&n.nodeName.toLowerCase()!=="script");return b.getJaxFor(n)},getHoverSpan:function(n,o){return n.root.PHTMLspanElement()},getHoverBBox:function(n,q,r){var s=n.root.PHTML,p=n.PHTML.outerEm;var o={w:s.w*p,h:s.h*p,d:s.d*p};if(s.width){o.width=s.width}return o},Zoom:function(o,u,s,n,r){u.className="MathJax";this.idPostfix="-zoom";o.root.toPHTML(u,u);this.idPostfix="";u.style.position="absolute";if(!width){s.style.position="absolute"}var t=u.offsetWidth,q=u.offsetHeight,v=s.offsetHeight,p=s.offsetWidth;if(p===0){p=s.parentNode.offsetWidth}u.style.position=s.style.position="";return{Y:-j.getBBox(u).h,mW:p,mH:v,zW:t,zH:q}},initPHTML:function(o,n){},Remove:function(n){var o=document.getElementById(n.inputID+"-Frame");if(o){if(n.PHTML.display){o=o.parentNode}o.parentNode.removeChild(o)}delete n.PHTML},ID:0,idPostfix:"",GetID:function(){this.ID++;return this.ID},VARIANT:{bold:"MJXp-bold",italic:"MJXp-italic","bold-italic":"MJXp-bold MJXp-italic",script:"MJXp-scr","bold-script":"MJXp-scr MJXp-bold",fraktur:"MJXp-frak","bold-fraktur":"MJXp-frak MJXp-bold",monospace:"MJXp-mono","sans-serif":"MJXp-sf","-tex-caligraphic":"MJXp-cal"},MATHSPACE:{veryverythinmathspace:1/18,verythinmathspace:2/18,thinmathspace:3/18,mediummathspace:4/18,thickmathspace:5/18,verythickmathspace:6/18,veryverythickmathspace:7/18,negativeveryverythinmathspace:-1/18,negativeverythinmathspace:-2/18,negativethinmathspace:-3/18,negativemediummathspace:-4/18,negativethickmathspace:-5/18,negativeverythickmathspace:-6/18,negativeveryverythickmathspace:-7/18,thin:0.08,medium:0.1,thick:0.15,infinity:k},TeX:{x_height:0.430554},pxPerInch:72,em:16,DELIMITERS:{"(":{dir:c},"{":{dir:c,w:0.58},"[":{dir:c},"|":{dir:c,w:0.275},")":{dir:c},"}":{dir:c,w:0.58},"]":{dir:c},"/":{dir:c},"\\":{dir:c},"\u2223":{dir:c,w:0.275},"\u2225":{dir:c,w:0.55},"\u230A":{dir:c,w:0.5},"\u230B":{dir:c,w:0.5},"\u2308":{dir:c,w:0.5},"\u2309":{dir:c,w:0.5},"\u27E8":{dir:c,w:0.5},"\u27E9":{dir:c,w:0.5},"\u2191":{dir:c,w:0.65},"\u2193":{dir:c,w:0.65},"\u21D1":{dir:c,w:0.75},"\u21D3":{dir:c,w:0.75},"\u2195":{dir:c,w:0.65},"\u21D5":{dir:c,w:0.75},"\u27EE":{dir:c,w:0.275},"\u27EF":{dir:c,w:0.275},"\u23B0":{dir:c,w:0.6},"\u23B1":{dir:c,w:0.6}},REMAPACCENT:{"\u20D7":"\u2192","'":"\u02CB","`":"\u02CA",".":"\u02D9","^":"\u02C6","-":"\u02C9","~":"\u02DC","\u00AF":"\u02C9","\u00B0":"\u02DA","\u00B4":"\u02CA","\u0300":"\u02CB","\u0301":"\u02CA","\u0302":"\u02C6","\u0303":"\u02DC","\u0304":"\u02C9","\u0305":"\u02C9","\u0306":"\u02D8","\u0307":"\u02D9","\u0308":"\u00A8","\u030C":"\u02C7"},REMAPACCENTUNDER:{},length2em:function(r,p){if(typeof(r)!=="string"){r=r.toString()}if(r===""){return""}if(r===h.SIZE.NORMAL){return 1}if(r===h.SIZE.BIG){return 2}if(r===h.SIZE.SMALL){return 0.71}if(this.MATHSPACE[r]){return this.MATHSPACE[r]}var o=r.match(/^\s*([-+]?(?:\.\d+|\d+(?:\.\d*)?))?(pt|em|ex|mu|px|pc|in|mm|cm|%)?/);var n=parseFloat(o[1]||"1"),q=o[2];if(p==null){p=1}if(q==="em"){return n}if(q==="ex"){return n*this.TeX.x_height}if(q==="%"){return n/100*p}if(q==="px"){return n/this.em}if(q==="pt"){return n/10}if(q==="pc"){return n*1.2}if(q==="in"){return n*this.pxPerInch/this.em}if(q==="cm"){return n*this.pxPerInch/this.em/2.54}if(q==="mm"){return n*this.pxPerInch/this.em/25.4}if(q==="mu"){return n/18}return n*p},Em:function(n){if(Math.abs(n)<0.001){return"0em"}return(n.toFixed(3).replace(/\.?0+$/,""))+"em"},arrayEntry:function(n,o){return n[Math.max(0,Math.min(o,n.length-1))]}});MathJax.Hub.Register.StartupHook("mml Jax Ready",function(){h=MathJax.ElementJax.mml;h.mbase.Augment({toPreviewHTML:function(o,n){return this.PHTMLdefaultSpan(o,n)},PHTMLdefaultSpan:function(q,o){if(!o){o={}}q=this.PHTMLcreateSpan(q);this.PHTMLhandleStyle(q);this.PHTMLhandleColor(q);if(this.isToken){this.PHTMLhandleToken(q)}for(var p=0,n=this.data.length;p<n;p++){this.PHTMLaddChild(q,p,o)}return q},PHTMLaddChild:function(p,o,n){var q=this.data[o];if(q){if(n.childSpans){p=e.addElement(p,"span",{className:n.className})}q.toPreviewHTML(p);if(!n.noBBox){this.PHTML.w+=q.PHTML.w+q.PHTML.l+q.PHTML.r;if(q.PHTML.h>this.PHTML.h){this.PHTML.h=q.PHTML.h}if(q.PHTML.d>this.PHTML.d){this.PHTML.d=q.PHTML.d}if(q.PHTML.t>this.PHTML.t){this.PHTML.t=q.PHTML.t}if(q.PHTML.b>this.PHTML.b){this.PHTML.b=q.PHTML.b}}}else{if(n.forceChild){e.addElement(p,"span")}}},PHTMLstretchChild:function(q,p,s){var r=this.data[q];if(r&&r.PHTMLcanStretch("Vertical",p,s)){var t=this.PHTML,o=r.PHTML,n=o.w;r.PHTMLstretchV(p,s);t.w+=o.w-n;if(o.h>t.h){t.h=o.h}if(o.d>t.d){t.d=o.d}}},PHTMLcreateSpan:function(n){if(!this.PHTML){this.PHTML={}}this.PHTML={w:0,h:0,d:0,l:0,r:0,t:0,b:0};if(this.inferred){return n}if(this.type==="mo"&&this.data.join("")==="\u222B"){g.lastIsInt=true}else{if(this.type!=="mspace"||this.width!=="negativethinmathspace"){g.lastIsInt=false}}if(!this.PHTMLspanID){this.PHTMLspanID=g.GetID()}var o=(this.id||"MJXp-Span-"+this.PHTMLspanID);return e.addElement(n,"span",{className:"MJXp-"+this.type,id:o})},PHTMLspanElement:function(){if(!this.PHTMLspanID){return null}return document.getElementById(this.id||"MJXp-Span-"+this.PHTMLspanID)},PHTMLhandleToken:function(o){var n=this.getValues("mathvariant");if(n.mathvariant!==h.VARIANT.NORMAL){o.className+=" "+g.VARIANT[n.mathvariant]}},PHTMLhandleStyle:function(n){if(this.style){n.style.cssText=this.style}},PHTMLhandleColor:function(n){if(this.mathcolor){n.style.color=this.mathcolor}if(this.mathbackground){n.style.backgroundColor=this.mathbackground}},PHTMLhandleScriptlevel:function(n){var o=this.Get("scriptlevel");if(o){n.className+=" MJXp-script"}},PHTMLhandleText:function(y,A){var v,p;var z=0,o=0,q=0;for(var s=0,r=A.length;s<r;s++){p=A.charCodeAt(s);v=A.charAt(s);if(p>=55296&&p<56319){s++;p=(((p-55296)<<10)+(A.charCodeAt(s)-56320))+65536}var t=0.7,u=0.22,x=0.5;if(p<127){if(v.match(/[A-Za-ehik-or-xz0-9]/)){u=0}if(v.match(/[A-HK-Z]/)){x=0.67}else{if(v.match(/[IJ]/)){x=0.36}}if(v.match(/[acegm-su-z]/)){t=0.45}else{if(v.match(/[ij]/)){t=0.75}}if(v.match(/[ijlt]/)){x=0.28}}if(g.DELIMITERS[v]){x=g.DELIMITERS[v].w||0.4}if(t>z){z=t}if(u>o){o=u}q+=x}if(!this.CHML){this.PHTML={}}this.PHTML={h:0.9,d:0.3,w:q,l:0,r:0,t:z,b:o};e.addText(y,A)},PHTMLbboxFor:function(o){if(this.data[o]&&this.data[o].PHTML){return this.data[o].PHTML}return{w:0,h:0,d:0,l:0,r:0,t:0,b:0}},PHTMLcanStretch:function(q,o,p){if(this.isEmbellished()){var n=this.Core();if(n&&n!==this){return n.PHTMLcanStretch(q,o,p)}}return false},PHTMLstretchV:function(n,o){},PHTMLstretchH:function(n){},CoreParent:function(){var n=this;while(n&&n.isEmbellished()&&n.CoreMO()===this&&!n.isa(h.math)){n=n.Parent()}return n},CoreText:function(n){if(!n){return""}if(n.isEmbellished()){return n.CoreMO().data.join("")}while((n.isa(h.mrow)||n.isa(h.TeXAtom)||n.isa(h.mstyle)||n.isa(h.mphantom))&&n.data.length===1&&n.data[0]){n=n.data[0]}if(!n.isToken){return""}else{return n.data.join("")}}});h.chars.Augment({toPreviewHTML:function(n){var o=this.toString().replace(/[\u2061-\u2064]/g,"");this.PHTMLhandleText(n,o)}});h.entity.Augment({toPreviewHTML:function(n){var o=this.toString().replace(/[\u2061-\u2064]/g,"");this.PHTMLhandleText(n,o)}});h.math.Augment({toPreviewHTML:function(n){n=this.PHTMLdefaultSpan(n);if(this.Get("display")==="block"){n.className+=" MJXp-display"}return n}});h.mo.Augment({toPreviewHTML:function(o){o=this.PHTMLdefaultSpan(o);this.PHTMLadjustAccent(o);var n=this.getValues("lspace","rspace","scriptlevel","displaystyle","largeop");if(n.scriptlevel===0){this.PHTML.l=g.length2em(n.lspace);this.PHTML.r=g.length2em(n.rspace);o.style.marginLeft=g.Em(this.PHTML.l);o.style.marginRight=g.Em(this.PHTML.r)}else{this.PHTML.l=0.15;this.PHTML.r=0.1}if(n.displaystyle&&n.largeop){var p=e.Element("span",{className:"MJXp-largeop"});p.appendChild(o.firstChild);o.appendChild(p);this.PHTML.h*=1.2;this.PHTML.d*=1.2;if(this.data.join("")==="\u222B"){p.className+=" MJXp-int"}}return o},PHTMLadjustAccent:function(p){var o=this.CoreParent();if(o&&o.isa(h.munderover)&&this.CoreText(o.data[o.base]).length===1){var q=o.data[o.over],n=o.data[o.under];var s=this.data.join(""),r;if(q&&this===q.CoreMO()&&o.Get("accent")){r=g.REMAPACCENT[s]}else{if(n&&this===n.CoreMO()&&o.Get("accentunder")){r=g.REMAPACCENTUNDER[s]}}if(r){s=p.innerHTML=r}if(s.match(/[\u02C6-\u02DC\u00A8]/)){this.PHTML.acc=-0.52}else{if(s==="\u2192"){this.PHTML.acc=-0.15;this.PHTML.vec=true}}}},PHTMLcanStretch:function(q,o,p){if(!this.Get("stretchy")){return false}var r=this.data.join("");if(r.length>1){return false}r=g.DELIMITERS[r];var n=(r&&r.dir===q.substr(0,1));if(n){n=(this.PHTML.h!==o||this.PHTML.d!==p||(this.Get("minsize",true)||this.Get("maxsize",true)))}return n},PHTMLstretchV:function(p,u){var o=this.PHTMLspanElement(),t=this.PHTML;var n=this.getValues("symmetric","maxsize","minsize");if(n.symmetric){l=2*Math.max(p-0.25,u+0.25)}else{l=p+u}n.maxsize=g.length2em(n.maxsize,t.h+t.d);n.minsize=g.length2em(n.minsize,t.h+t.d);l=Math.max(n.minsize,Math.min(n.maxsize,l));var s=l/(t.h+t.d-0.3);var q=e.Element("span",{style:{"font-size":g.Em(s)}});if(s>1.25){var r=Math.ceil(1.25/s*10);q.className="MJXp-right MJXp-scale"+r;q.style.marginLeft=g.Em(t.w*(r/10-1)+0.07);t.w*=s*r/10}q.appendChild(o.firstChild);o.appendChild(q);if(n.symmetric){o.style.verticalAlign=g.Em(0.25*(1-s))}}});h.mspace.Augment({toPreviewHTML:function(q){q=this.PHTMLdefaultSpan(q);var o=this.getValues("height","depth","width");var n=g.length2em(o.width),p=g.length2em(o.height),s=g.length2em(o.depth);var r=this.PHTML;r.w=n;r.h=p;r.d=s;if(n<0){if(!g.lastIsInt){q.style.marginLeft=g.Em(n)}n=0}q.style.width=g.Em(n);q.style.height=g.Em(p+s);if(s){q.style.verticalAlign=g.Em(-s)}return q}});h.mpadded.Augment({toPreviewHTML:function(u){u=this.PHTMLdefaultSpan(u,{childSpans:true,className:"MJXp-box",forceChild:true});var o=u.firstChild;var v=this.getValues("width","height","depth","lspace","voffset");var s=this.PHTMLdimen(v.lspace);var q=0,n=0,t=s.len,r=-s.len,p=0;if(v.width!==""){s=this.PHTMLdimen(v.width,"w",0);if(s.pm){r+=s.len}else{u.style.width=g.Em(s.len)}}if(v.height!==""){s=this.PHTMLdimen(v.height,"h",0);if(!s.pm){q+=-this.PHTMLbboxFor(0).h}q+=s.len}if(v.depth!==""){s=this.PHTMLdimen(v.depth,"d",0);if(!s.pm){n+=-this.PHTMLbboxFor(0).d;p+=-s.len}n+=s.len}if(v.voffset!==""){s=this.PHTMLdimen(v.voffset);q-=s.len;n+=s.len;p+=s.len}if(q){o.style.marginTop=g.Em(q)}if(n){o.style.marginBottom=g.Em(n)}if(t){o.style.marginLeft=g.Em(t)}if(r){o.style.marginRight=g.Em(r)}if(p){u.style.verticalAlign=g.Em(p)}return u},PHTMLdimen:function(q,r,n){if(n==null){n=-k}q=String(q);var o=q.match(/width|height|depth/);var p=(o?this.PHTML[o[0].charAt(0)]:(r?this.PHTML[r]:0));return{len:g.length2em(q,p)||0,pm:!!q.match(/^[-+]/)}}});h.munderover.Augment({toPreviewHTML:function(r){var t=this.getValues("displaystyle","accent","accentunder","align");var n=this.data[this.base];if(!t.displaystyle&&n!=null&&(n.movablelimits||n.CoreMO().Get("movablelimits"))){r=h.msubsup.prototype.toPreviewHTML.call(this,r);r.className=r.className.replace(/munderover/,"msubsup");return r}r=this.PHTMLdefaultSpan(r,{childSpans:true,className:"",noBBox:true});var p=this.PHTMLbboxFor(this.over),v=this.PHTMLbboxFor(this.under),u=this.PHTMLbboxFor(this.base),s=this.PHTML,o=p.acc;if(this.data[this.over]){r.lastChild.firstChild.style.marginLeft=p.l=r.lastChild.firstChild.style.marginRight=p.r=0;var q=e.Element("span",{},[["span",{className:"MJXp-over"}]]);q.firstChild.appendChild(r.lastChild);if(r.childNodes.length>(this.data[this.under]?1:0)){q.firstChild.appendChild(r.firstChild)}this.data[this.over].PHTMLhandleScriptlevel(q.firstChild.firstChild);if(o!=null){if(p.vec){q.firstChild.firstChild.firstChild.style.fontSize="60%";p.h*=0.6;p.d*=0.6;p.w*=0.6}o=o-p.d+0.1;if(u.t!=null){o+=u.t-u.h}q.firstChild.firstChild.style.marginBottom=g.Em(o)}if(r.firstChild){r.insertBefore(q,r.firstChild)}else{r.appendChild(q)}}if(this.data[this.under]){r.lastChild.firstChild.style.marginLeft=v.l=r.lastChild.firstChild.marginRight=v.r=0;this.data[this.under].PHTMLhandleScriptlevel(r.lastChild)}s.w=Math.max(0.8*p.w,0.8*v.w,u.w);s.h=0.8*(p.h+p.d+(o||0))+u.h;s.d=u.d+0.8*(v.h+v.d);return r}});h.msubsup.Augment({toPreviewHTML:function(q){q=this.PHTMLdefaultSpan(q,{noBBox:true});if(!this.data[this.base]){if(q.firstChild){q.insertBefore(e.Element("span"),q.firstChild)}else{q.appendChild(e.Element("span"))}}var s=this.data[this.base],p=this.data[this.sub],n=this.data[this.sup];if(!s){s={bbox:{h:0.8,d:0.2}}}q.firstChild.style.marginRight=".05em";var o=Math.max(0.4,s.PHTML.h-0.4),u=Math.max(0.2,s.PHTML.d+0.1);var t=this.PHTML;if(n&&p){var r=e.Element("span",{className:"MJXp-script-box",style:{height:g.Em(o+n.PHTML.h*0.8+u+p.PHTML.d*0.8),"vertical-align":g.Em(-u-p.PHTML.d*0.8)}},[["span",{},[["span",{},[["span",{style:{"margin-bottom":g.Em(-(n.PHTML.d-0.05))}}]]]]],["span",{},[["span",{},[["span",{style:{"margin-top":g.Em(-(n.PHTML.h-0.05))}}]]]]]]);p.PHTMLhandleScriptlevel(r.firstChild);n.PHTMLhandleScriptlevel(r.lastChild);r.firstChild.firstChild.firstChild.appendChild(q.lastChild);r.lastChild.firstChild.firstChild.appendChild(q.lastChild);q.appendChild(r);t.h=Math.max(s.PHTML.h,n.PHTML.h*0.8+o);t.d=Math.max(s.PHTML.d,p.PHTML.d*0.8+u);t.w=s.PHTML.w+Math.max(n.PHTML.w,p.PHTML.w)+0.07}else{if(n){q.lastChild.style.verticalAlign=g.Em(o);n.PHTMLhandleScriptlevel(q.lastChild);t.h=Math.max(s.PHTML.h,n.PHTML.h*0.8+o);t.d=Math.max(s.PHTML.d,n.PHTML.d*0.8-o);t.w=s.PHTML.w+n.PHTML.w+0.07}else{if(p){q.lastChild.style.verticalAlign=g.Em(-u);p.PHTMLhandleScriptlevel(q.lastChild);t.h=Math.max(s.PHTML.h,p.PHTML.h*0.8-u);t.d=Math.max(s.PHTML.d,p.PHTML.d*0.8+u);t.w=s.PHTML.w+p.PHTML.w+0.07}}}return q}});h.mfrac.Augment({toPreviewHTML:function(r){r=this.PHTMLdefaultSpan(r,{childSpans:true,className:"MJXp-box",forceChild:true,noBBox:true});var o=this.getValues("linethickness","displaystyle");if(!o.displaystyle){if(this.data[0]){this.data[0].PHTMLhandleScriptlevel(r.firstChild)}if(this.data[1]){this.data[1].PHTMLhandleScriptlevel(r.lastChild)}}var n=e.Element("span",{className:"MJXp-box"},[["span",{className:"MJXp-denom"},[["span",{},[["span",{className:"MJXp-rule",style:{height:"1em"}}]]],["span"]]]]);n.firstChild.lastChild.appendChild(r.lastChild);r.appendChild(n);var s=this.PHTMLbboxFor(0),p=this.PHTMLbboxFor(1),v=this.PHTML;v.w=Math.max(s.w,p.w)*0.8;v.h=s.h+s.d+0.1+0.25;v.d=p.h+p.d-0.25;v.l=v.r=0.125;o.linethickness=Math.max(0,g.length2em(o.linethickness||"0",0));if(o.linethickness){var u=n.firstChild.firstChild.firstChild;var q=g.Em(o.linethickness);u.style.borderTop="none";u.style.borderBottom=(o.linethickness<0.15?"1px":q)+" solid";u.style.margin=q+" 0";q=o.linethickness;n.style.marginTop=g.Em(3*q-1.2);r.style.verticalAlign=g.Em(1.5*q+0.1);v.h+=1.5*q-0.1;v.d+=1.5*q}else{n.style.marginTop="-.7em"}return r}});h.msqrt.Augment({toPreviewHTML:function(n){n=this.PHTMLdefaultSpan(n,{childSpans:true,className:"MJXp-box",forceChild:true,noBBox:true});this.PHTMLlayoutRoot(n,n.firstChild);return n},PHTMLlayoutRoot:function(u,n){var v=this.PHTMLbboxFor(0);var q=Math.ceil((v.h+v.d+0.14)*100),w=g.Em(14/q);var r=e.Element("span",{className:"MJXp-surd"},[["span",{style:{"font-size":q+"%","margin-top":w}},["\u221A"]]]);var s=e.Element("span",{className:"MJXp-root"},[["span",{className:"MJXp-rule",style:{"border-top":".08em solid"}}]]);var p=(1.2/2.2)*q/100;if(q>150){var o=Math.ceil(150/q*10);r.firstChild.className="MJXp-right MJXp-scale"+o;r.firstChild.style.marginLeft=g.Em(p*(o/10-1)/q*100);p=p*o/10;s.firstChild.style.borderTopWidth=g.Em(0.08/Math.sqrt(o/10))}s.appendChild(n);u.appendChild(r);u.appendChild(s);this.PHTML.h=v.h+0.18;this.PHTML.d=v.d;this.PHTML.w=v.w+p;return u}});h.mroot.Augment({toPreviewHTML:function(q){q=this.PHTMLdefaultSpan(q,{childSpans:true,className:"MJXp-box",forceChild:true,noBBox:true});var p=this.PHTMLbboxFor(1),n=q.removeChild(q.lastChild);var t=this.PHTMLlayoutRoot(e.Element("span"),q.firstChild);n.className="MJXp-script";var u=parseInt(t.firstChild.firstChild.style.fontSize);var o=0.55*(u/120)+p.d*0.8,s=-0.6*(u/120);if(u>150){s*=0.95*Math.ceil(150/u*10)/10}n.style.marginRight=g.Em(s);n.style.verticalAlign=g.Em(o);if(-s>p.w*0.8){n.style.marginLeft=g.Em(-s-p.w*0.8)}q.appendChild(n);q.appendChild(t);this.PHTML.w+=Math.max(0,p.w*0.8+s);this.PHTML.h=Math.max(this.PHTML.h,p.h*0.8+o);return q},PHTMLlayoutRoot:h.msqrt.prototype.PHTMLlayoutRoot});h.mfenced.Augment({toPreviewHTML:function(q){q=this.PHTMLcreateSpan(q);this.PHTMLhandleStyle(q);this.PHTMLhandleColor(q);this.addFakeNodes();this.PHTMLaddChild(q,"open",{});for(var p=0,n=this.data.length;p<n;p++){this.PHTMLaddChild(q,"sep"+p,{});this.PHTMLaddChild(q,p,{})}this.PHTMLaddChild(q,"close",{});var o=this.PHTML.h,r=this.PHTML.d;this.PHTMLstretchChild("open",o,r);for(p=0,n=this.data.length;p<n;p++){this.PHTMLstretchChild("sep"+p,o,r);this.PHTMLstretchChild(p,o,r)}this.PHTMLstretchChild("close",o,r);return q}});h.mrow.Augment({toPreviewHTML:function(q){q=this.PHTMLdefaultSpan(q);var p=this.PHTML.h,r=this.PHTML.d;for(var o=0,n=this.data.length;o<n;o++){this.PHTMLstretchChild(o,p,r)}return q}});h.mstyle.Augment({toPreviewHTML:function(n){n=this.PHTMLdefaultSpan(n);this.PHTMLhandleScriptlevel(n);return n}});h.TeXAtom.Augment({toPreviewHTML:function(n){n=this.PHTMLdefaultSpan(n);n.className="MJXp-mrow";return n}});h.mtable.Augment({toPreviewHTML:function(E){E=this.PHTMLdefaultSpan(E,{noBBox:true});var r=this.getValues("columnalign","rowalign","columnspacing","rowspacing","columnwidth","equalcolumns","equalrows","columnlines","rowlines","frame","framespacing","align","width");var u=MathJax.Hub.SplitList,F,A,D,z;var N=u(r.columnspacing),w=u(r.rowspacing),L=u(r.columnalign),t=u(r.rowalign);for(F=0,A=N.length;F<A;F++){N[F]=g.length2em(N[F])}for(F=0,A=w.length;F<A;F++){w[F]=g.length2em(w[F])}var K=e.Element("span");while(E.firstChild){K.appendChild(E.firstChild)}E.appendChild(K);var y=0,s=0;for(F=0,A=this.data.length;F<A;F++){var v=this.data[F];if(v){var J=g.arrayEntry(w,F-1),C=g.arrayEntry(t,F);var x=v.PHTML,q=v.PHTMLspanElement();q.style.verticalAlign=C;var B=(v.type==="mlabeledtr"?1:0);for(D=0,z=v.data.length;D<z-B;D++){var p=v.data[D+B];if(p){var M=g.arrayEntry(N,D-1),G=g.arrayEntry(L,D);var I=p.PHTMLspanElement();if(D){x.w+=M;I.style.paddingLeft=g.Em(M)}if(F){I.style.paddingTop=g.Em(J)}I.style.textAlign=G}}y+=x.h+x.d;if(F){y+=J}if(x.w>s){s=x.w}}}var o=this.PHTML;o.w=s;o.h=y/2+0.25;o.d=y/2-0.25;o.l=o.r=0.125;return E}});h.mlabeledtr.Augment({PHTMLdefaultSpan:function(q,o){if(!o){o={}}q=this.PHTMLcreateSpan(q);this.PHTMLhandleStyle(q);this.PHTMLhandleColor(q);if(this.isToken){this.PHTMLhandleToken(q)}for(var p=1,n=this.data.length;p<n;p++){this.PHTMLaddChild(q,p,o)}return q}});h.semantics.Augment({toPreviewHTML:function(n){n=this.PHTMLcreateSpan(n);if(this.data[0]){this.data[0].toPreviewHTML(n);MathJax.Hub.Insert(this.data[0].PHTML||{},this.PHTML)}return n}});h.annotation.Augment({toPreviewHTML:function(n){}});h["annotation-xml"].Augment({toPreviewHTML:function(n){}});MathJax.Hub.Register.StartupHook("onLoad",function(){setTimeout(MathJax.Callback(["loadComplete",g,"jax.js"]),0)})});MathJax.Hub.Register.StartupHook("End Cookie",function(){if(b.config.menuSettings.zoom!=="None"){i.Require("[MathJax]/extensions/MathZoom.js")}})})(MathJax.Ajax,MathJax.Hub,MathJax.HTML,MathJax.OutputJax.PreviewHTML);
	(function(b,g,f){var c=b.config.menuSettings;var e=MathJax.OutputJax;var a=f.isMSIE&&(document.documentMode||0)<8;var d=MathJax.Extension["fast-preview"]={version:"2.6.0",enabled:true,config:b.CombineConfig("fast-preview",{Chunks:{EqnChunk:10000,EqnChunkFactor:1,EqnChunkDelay:0},color:"inherit!important",updateTime:30,updateDelay:6,messageStyle:"none",disabled:f.isMSIE&&!f.versionAtLeast("8.0")}),Config:function(){if(b.config["CHTML-preview"]){MathJax.Hub.Config({"fast-preview":b.config["CHTML-preview"]})}var m,j,k,h,l;var i=this.config;if(!i.disabled&&c.FastPreview==null){b.Config({menuSettings:{FastPreview:true}})}if(c.FastPreview){MathJax.Ajax.Styles({".MathJax_Preview .MJXf-math":{color:i.color}});b.Config({"HTML-CSS":i.Chunks,CommonHTML:i.Chunks,SVG:i.Chunks})}b.Register.MessageHook("Begin Math Output",function(){if(!h&&d.Active()){m=b.processUpdateTime;j=b.processUpdateDelay;k=b.config.messageStyle;b.processUpdateTime=i.updateTime;b.processUpdateDelay=i.updateDelay;b.Config({messageStyle:i.messageStyle});MathJax.Message.Clear(0,0);l=true}});b.Register.MessageHook("End Math Output",function(){if(!h&&l){b.processUpdateTime=m;b.processUpdateDelay=j;b.Config({messageStyle:k});h=true}})},Disable:function(){this.enabled=false},Enable:function(){this.enabled=true},Active:function(){return c.FastPreview&&this.enabled&&!(e[c.renderer]||{}).noFastPreview},Preview:function(h){if(!this.Active()){return}var i=h.script.MathJax.preview||h.script.previousSibling;if(!i||i.className!==MathJax.Hub.config.preRemoveClass){i=g.Element("span",{className:MathJax.Hub.config.preRemoveClass});h.script.parentNode.insertBefore(i,h.script);h.script.MathJax.preview=i}i.innerHTML="";i.style.color=(a?"black":"inherit");return this.postFilter(i,h)},postFilter:function(j,i){if(!i.math.root.toPreviewHTML){var h=MathJax.Callback.Queue();h.Push(["Require",MathJax.Ajax,"[MathJax]/jax/output/PreviewHTML/config.js"],["Require",MathJax.Ajax,"[MathJax]/jax/output/PreviewHTML/jax.js"]);b.RestartAfter(h.Push({}))}i.math.root.toPreviewHTML(j)},Register:function(h){b.Register.StartupHook(h+" Jax Require",function(){var i=MathJax.InputJax[h];i.postfilterHooks.Add(["Preview",MathJax.Extension["fast-preview"]],50)})}};d.Register("TeX");d.Register("MathML");d.Register("AsciiMath");b.Register.StartupHook("End Config",["Config",d]);b.Startup.signal.Post("fast-preview Ready")})(MathJax.Hub,MathJax.HTML,MathJax.Hub.Browser);MathJax.Ajax.loadComplete("[MathJax]/extensions/fast-preview.js");
	(function(a,e,b,f){var c=b.config.menuSettings;var d=MathJax.Extension.AssistiveMML={version:"2.6.1",config:b.CombineConfig("AssistiveMML",{disabled:false,styles:{".MJX_Assistive_MathML":{position:"absolute!important",top:0,left:0,clip:(b.Browser.isMSIE&&(document.documentMode||0)<8?"rect(1px 1px 1px 1px)":"rect(1px, 1px, 1px, 1px)"),padding:"1px 0 0 0!important",border:"0!important",height:"1px!important",width:"1px!important",overflow:"hidden!important",display:"block!important","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none"},".MJX_Assistive_MathML.MJX_Assistive_MathML_Block":{width:"100%!important"}}}),Config:function(){if(!this.config.disabled&&c.assistiveMML==null){b.Config({menuSettings:{assistiveMML:true}})}a.Styles(this.config.styles);b.Register.MessageHook("End Math",function(g){if(c.assistiveMML){return d.AddAssistiveMathML(g[1])}})},AddAssistiveMathML:function(g){var h={jax:b.getAllJax(g),i:0,callback:MathJax.Callback({})};this.HandleMML(h);return h.callback},RemoveAssistiveMathML:function(k){var h=b.getAllJax(k),l;for(var j=0,g=h.length;j<g;j++){l=document.getElementById(h[j].inputID+"-Frame");if(l&&l.getAttribute("data-mathml")){l.removeAttribute("data-mathml");if(l.lastChild&&l.lastChild.className.match(/MJX_Assistive_MathML/)){l.removeChild(l.lastChild)}}}},HandleMML:function(l){var g=l.jax.length,h,i,n,j;while(l.i<g){h=l.jax[l.i];n=document.getElementById(h.inputID+"-Frame");if(h.outputJax!=="NativeMML"&&n&&!n.getAttribute("data-mathml")){try{i=h.root.toMathML("").replace(/\n */g,"").replace(/<!--.*?-->/g,"")}catch(k){if(!k.restart){throw k}return MathJax.Callback.After(["HandleMML",this,l],k.restart)}n.setAttribute("data-mathml",i);j=f.addElement(n,"span",{isMathJax:true,unselectable:"on",className:"MJX_Assistive_MathML"+(h.root.Get("display")==="block"?" MJX_Assistive_MathML_Block":"")});j.innerHTML=i;n.style.position="relative";n.setAttribute("role","presentation");n.firstChild.setAttribute("aria-hidden","true");j.setAttribute("role","presentation")}l.i++}l.callback()}};b.Startup.signal.Post("AssistiveMML Ready")})(MathJax.Ajax,MathJax.Callback,MathJax.Hub,MathJax.HTML);MathJax.Callback.Queue(["Require",MathJax.Ajax,"[MathJax]/extensions/toMathML.js"],["loadComplete",MathJax.Ajax,"[MathJax]/extensions/AssistiveMML.js"],function(){MathJax.Hub.Register.StartupHook("End Config",["Config",MathJax.Extension.AssistiveMML])});
	MathJax.Ajax.loadComplete("[MathJax]/config/TeX-AMS-MML_HTMLorMML.js");


/***/ },
/* 71 */
/***/ function(module, exports) {

	/*
	 *  /MathJax/extensions/MathMenu.js
	 *
	 *  Copyright (c) 2009-2015 The MathJax Consortium
	 *
	 *  Licensed under the Apache License, Version 2.0 (the "License");
	 *  you may not use this file except in compliance with the License.
	 *  You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 *  Unless required by applicable law or agreed to in writing, software
	 *  distributed under the License is distributed on an "AS IS" BASIS,
	 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *  See the License for the specific language governing permissions and
	 *  limitations under the License.
	 */

	(function(f,n,p,e,q){var o="2.6.1";var d=MathJax.Callback.Signal("menu");MathJax.Extension.MathMenu={version:o,signal:d};var s=function(t){return MathJax.Localization._.apply(MathJax.Localization,[["MathMenu",t]].concat([].slice.call(arguments,1)))};var a=f.Browser.isPC,k=f.Browser.isMSIE,l=((document.documentMode||0)>8);var i=(a?null:"5px");var r=f.CombineConfig("MathMenu",{delay:150,showRenderer:true,showMathPlayer:true,showFontMenu:false,showContext:false,showDiscoverable:false,showLocale:true,showLocaleURL:false,semanticsAnnotations:{TeX:["TeX","LaTeX","application/x-tex"],StarMath:["StarMath 5.0"],Maple:["Maple"],ContentMathML:["MathML-Content","application/mathml-content+xml"],OpenMath:["OpenMath"]},windowSettings:{status:"no",toolbar:"no",locationbar:"no",menubar:"no",directories:"no",personalbar:"no",resizable:"yes",scrollbars:"yes",width:400,height:300,left:Math.round((screen.width-400)/2),top:Math.round((screen.height-300)/3)},styles:{"#MathJax_About":{position:"fixed",left:"50%",width:"auto","text-align":"center",border:"3px outset",padding:"1em 2em","background-color":"#DDDDDD",color:"black",cursor:"default","font-family":"message-box","font-size":"120%","font-style":"normal","text-indent":0,"text-transform":"none","line-height":"normal","letter-spacing":"normal","word-spacing":"normal","word-wrap":"normal","white-space":"nowrap","float":"none","z-index":201,"border-radius":"15px","-webkit-border-radius":"15px","-moz-border-radius":"15px","-khtml-border-radius":"15px","box-shadow":"0px 10px 20px #808080","-webkit-box-shadow":"0px 10px 20px #808080","-moz-box-shadow":"0px 10px 20px #808080","-khtml-box-shadow":"0px 10px 20px #808080",filter:"progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')"},"#MathJax_About.MathJax_MousePost":{outline:"none"},".MathJax_Menu":{position:"absolute","background-color":"white",color:"black",width:"auto",padding:(a?"2px":"5px 0px"),border:"1px solid #CCCCCC",margin:0,cursor:"default",font:"menu","text-align":"left","text-indent":0,"text-transform":"none","line-height":"normal","letter-spacing":"normal","word-spacing":"normal","word-wrap":"normal","white-space":"nowrap","float":"none","z-index":201,"border-radius":i,"-webkit-border-radius":i,"-moz-border-radius":i,"-khtml-border-radius":i,"box-shadow":"0px 10px 20px #808080","-webkit-box-shadow":"0px 10px 20px #808080","-moz-box-shadow":"0px 10px 20px #808080","-khtml-box-shadow":"0px 10px 20px #808080",filter:"progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')"},".MathJax_MenuItem":{padding:(a?"2px 2em":"1px 2em"),background:"transparent"},".MathJax_MenuArrow":{position:"absolute",right:".5em","padding-top":".25em",color:"#666666","font-family":(k?"'Arial unicode MS'":null),"font-size":".75em"},".MathJax_MenuActive .MathJax_MenuArrow":{color:"white"},".MathJax_MenuArrow.RTL":{left:".5em",right:"auto"},".MathJax_MenuCheck":{position:"absolute",left:".7em","font-family":(k?"'Arial unicode MS'":null)},".MathJax_MenuCheck.RTL":{right:".7em",left:"auto"},".MathJax_MenuRadioCheck":{position:"absolute",left:(a?"1em":".7em")},".MathJax_MenuRadioCheck.RTL":{right:(a?"1em":".7em"),left:"auto"},".MathJax_MenuLabel":{padding:(a?"2px 2em 4px 1.33em":"1px 2em 3px 1.33em"),"font-style":"italic"},".MathJax_MenuRule":{"border-top":(a?"1px solid #CCCCCC":"1px solid #DDDDDD"),margin:(a?"4px 1px 0px":"4px 3px")},".MathJax_MenuDisabled":{color:"GrayText"},".MathJax_MenuActive":{"background-color":(a?"Highlight":"#606872"),color:(a?"HighlightText":"white")},".MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus":{"background-color":"#E8E8E8"},".MathJax_ContextMenu:focus":{outline:"none"},".MathJax_ContextMenu .MathJax_MenuItem:focus":{outline:"none"},"#MathJax_AboutClose":{top:".2em",right:".2em"},".MathJax_Menu .MathJax_MenuClose":{top:"-10px",left:"-10px"},".MathJax_MenuClose":{position:"absolute",cursor:"pointer",display:"inline-block",border:"2px solid #AAA","border-radius":"18px","-webkit-border-radius":"18px","-moz-border-radius":"18px","-khtml-border-radius":"18px","font-family":"'Courier New',Courier","font-size":"24px",color:"#F0F0F0"},".MathJax_MenuClose span":{display:"block","background-color":"#AAA",border:"1.5px solid","border-radius":"18px","-webkit-border-radius":"18px","-moz-border-radius":"18px","-khtml-border-radius":"18px","line-height":0,padding:"8px 0 6px"},".MathJax_MenuClose:hover":{color:"white!important",border:"2px solid #CCC!important"},".MathJax_MenuClose:hover span":{"background-color":"#CCC!important"},".MathJax_MenuClose:hover:focus":{outline:"none"}}});var m,j,b;f.Register.StartupHook("MathEvents Ready",function(){m=MathJax.Extension.MathEvents.Event.False;j=MathJax.Extension.MathEvents.Hover;b=MathJax.Extension.MathEvents.Event.KEY});var h=MathJax.Object.Subclass({Keydown:function(t,u){switch(t.keyCode){case b.ESCAPE:this.Remove(t,u);break;case b.RIGHT:this.Right(t,u);break;case b.LEFT:this.Left(t,u);break;case b.UP:this.Up(t,u);break;case b.DOWN:this.Down(t,u);break;case b.RETURN:case b.SPACE:this.Space(t,u);break;default:return;break}return m(t)},Escape:function(t,u){},Right:function(t,u){},Left:function(t,u){},Up:function(t,u){},Down:function(t,u){},Space:function(t,u){}},{});var g=MathJax.Menu=h.Subclass({version:o,items:[],posted:false,title:null,margin:5,Init:function(t){this.items=[].slice.call(arguments,0)},With:function(t){if(t){f.Insert(this,t)}return this},Post:function(u,I,G){if(!u){u=window.event||{}}var t=document.getElementById("MathJax_MenuFrame");if(!t){t=g.Background(this);delete c.lastItem;delete c.lastMenu;delete g.skipUp;d.Post(["post",g.jax]);g.isRTL=(MathJax.Localization.fontDirection()==="rtl")}var v=n.Element("div",{onmouseup:g.Mouseup,ondblclick:m,ondragstart:m,onselectstart:m,oncontextmenu:m,menuItem:this,className:"MathJax_Menu",onkeydown:g.Keydown,role:"menu"});if(u.type==="contextmenu"||u.type==="mouseover"){v.className+=" MathJax_ContextMenu"}if(!G){MathJax.Localization.setCSS(v)}for(var B=0,z=this.items.length;B<z;B++){this.items[B].Create(v)}if(g.isMobile){n.addElement(v,"span",{className:"MathJax_MenuClose",menu:I,ontouchstart:g.Close,ontouchend:m,onmousedown:g.Close,onmouseup:m},[["span",{},"\u00D7"]])}t.appendChild(v);this.posted=true;if(v.offsetWidth){v.style.width=(v.offsetWidth+2)+"px"}var H=u.pageX,F=u.pageY;if(!H&&!F&&"clientX" in u){H=u.clientX+document.body.scrollLeft+document.documentElement.scrollLeft;F=u.clientY+document.body.scrollTop+document.documentElement.scrollTop}if(!I){var w=g.CurrentNode()||u.target;if((u.type==="keydown"||(!H&&!F))&&w){var C=window.pageXOffset||document.documentElement.scrollLeft;var A=window.pageYOffset||document.documentElement.scrollTop;var E=w.getBoundingClientRect();H=(E.right+E.left)/2+C;F=(E.bottom+E.top)/2+A}if(H+v.offsetWidth>document.body.offsetWidth-this.margin){H=document.body.offsetWidth-v.offsetWidth-this.margin}if(g.isMobile){H=Math.max(5,H-Math.floor(v.offsetWidth/2));F-=20}g.skipUp=u.isContextMenu}else{var D="left",L=I.offsetWidth;H=(g.isMobile?30:L-2);F=0;while(I&&I!==t){H+=I.offsetLeft;F+=I.offsetTop;I=I.parentNode}if(!g.isMobile){if((g.isRTL&&H-L-v.offsetWidth>this.margin)||(!g.isRTL&&H+v.offsetWidth>document.body.offsetWidth-this.margin)){D="right";H=Math.max(this.margin,H-L-v.offsetWidth+6)}}if(!a){v.style["borderRadiusTop"+D]=0;v.style["WebkitBorderRadiusTop"+D]=0;v.style["MozBorderRadiusTop"+D]=0;v.style["KhtmlBorderRadiusTop"+D]=0}}v.style.left=H+"px";v.style.top=F+"px";if(document.selection&&document.selection.empty){document.selection.empty()}var K=window.pageXOffset||document.documentElement.scrollLeft;var J=window.pageYOffset||document.documentElement.scrollTop;g.Focus(v);if(u.type==="keydown"){g.skipMouseoverFromKey=true;setTimeout(function(){delete g.skipMouseoverFromKey},r.delay)}window.scrollTo(K,J);return m(u)},Remove:function(t,u){d.Post(["unpost",g.jax]);var v=document.getElementById("MathJax_MenuFrame");if(v){v.parentNode.removeChild(v);if(this.msieFixedPositionBug){detachEvent("onresize",g.Resize)}}if(g.jax.hover){delete g.jax.hover.nofade;j.UnHover(g.jax)}g.Unfocus(u);if(t.type==="mousedown"){g.CurrentNode().blur()}return m(t)},Find:function(t){return this.FindN(1,t,[].slice.call(arguments,1))},FindId:function(t){return this.FindN(0,t,[].slice.call(arguments,1))},FindN:function(x,u,w){for(var v=0,t=this.items.length;v<t;v++){if(this.items[v].name[x]===u){if(w.length){if(!this.items[v].submenu){return null}return this.items[v].submenu.FindN(x,w[0],w.slice(1))}return this.items[v]}}return null},IndexOf:function(t){return this.IndexOfN(1,t)},IndexOfId:function(t){return this.IndexOfN(0,t)},IndexOfN:function(w,u){for(var v=0,t=this.items.length;v<t;v++){if(this.items[v].name[w]===u){return v}}return null},Right:function(t,u){g.Right(t,u)},Left:function(t,u){g.Left(t,u)},Up:function(u,v){var t=v.lastChild;t.menuItem.Activate(u,t)},Down:function(u,v){var t=v.firstChild;t.menuItem.Activate(u,t)},Space:function(t,u){this.Remove(t,u)}},{config:r,Remove:function(t){return g.Event(t,this,"Remove")},Mouseover:function(t){return g.Event(t,this,"Mouseover")},Mouseout:function(t){return g.Event(t,this,"Mouseout")},Mousedown:function(t){return g.Event(t,this,"Mousedown")},Mouseup:function(t){return g.Event(t,this,"Mouseup")},Keydown:function(t){return g.Event(t,this,"Keydown")},Touchstart:function(t){return g.Event(t,this,"Touchstart")},Touchend:function(t){return g.Event(t,this,"Touchend")},Close:function(t){return g.Event(t,this.menu||this.parentNode,(this.menu?"Touchend":"Remove"))},Event:function(v,x,t,w){if(g.skipMouseover&&t==="Mouseover"&&!w){return m(v)}if(g.skipMouseoverFromKey&&t==="Mouseover"){delete g.skipMouseoverFromKey;return m(v)}if(g.skipUp){if(t.match(/Mouseup|Touchend/)){delete g.skipUp;return m(v)}if(t==="Touchstart"||(t==="Mousedown"&&!g.skipMousedown)){delete g.skipUp}}if(!v){v=window.event}var u=x.menuItem;if(u&&u[t]){return u[t](v,x)}return null},BGSTYLE:{position:"absolute",left:0,top:0,"z-index":200,width:"100%",height:"100%",border:0,padding:0,margin:0},Background:function(u){var v=n.addElement(document.body,"div",{style:this.BGSTYLE,id:"MathJax_MenuFrame"},[["div",{style:this.BGSTYLE,menuItem:u,onmousedown:this.Remove}]]);var t=v.firstChild;if(g.msieBackgroundBug){t.style.backgroundColor="white";t.style.filter="alpha(opacity=0)"}if(g.msieFixedPositionBug){v.width=v.height=0;this.Resize();attachEvent("onresize",this.Resize)}else{t.style.position="fixed"}return v},Resize:function(){setTimeout(g.SetWH,0)},SetWH:function(){var t=document.getElementById("MathJax_MenuFrame");if(t){t=t.firstChild;t.style.width=t.style.height="1px";t.style.width=document.body.scrollWidth+"px";t.style.height=document.body.scrollHeight+"px"}},posted:false,active:null,GetNode:function(t){var u=document.getElementById(t.inputID+"-Frame");return u.isMathJax?u:u.firstChild},CurrentNode:function(){return g.GetNode(g.jax)},AllNodes:function(){var u=MathJax.Hub.getAllJax();var v=[];for(var w=0,t;t=u[w];w++){v.push(g.GetNode(t))}return v},ActiveNode:function(){return g.active},FocusNode:function(t){g.active=t;t.focus()},Focus:function(t){!g.posted?g.Activate(t):g.ActiveNode().tabIndex=-1;t.tabIndex=0;g.FocusNode(t)},Activate:function(t,u){g.UnsetTabIndex();g.posted=true},Unfocus:function(){g.ActiveNode().tabIndex=-1;g.SetTabIndex();g.FocusNode(g.CurrentNode());g.posted=false},MoveHorizontal:function(x,y,v){if(!x.shiftKey){return}var u=g.AllNodes();var t=u.length;if(t===0){return}var w=u[g.Mod(v(g.IndexOf(u,g.CurrentNode())),t)];if(w===g.CurrentNode()){return}g.menu.Remove(x,y);g.jax=MathJax.Hub.getJaxFor(w);g.FocusNode(w);g.menu.Post(null)},Right:function(t,u){g.MoveHorizontal(t,u,function(v){return v+1})},Left:function(t,u){g.MoveHorizontal(t,u,function(v){return v-1})},UnsetTabIndex:function(){var u=g.AllNodes();for(var v=0,t;t=u[v];v++){if(t.tabIndex>0){t.oldTabIndex=t.tabIndex}t.tabIndex=-1}},SetTabIndex:function(){var u=g.AllNodes();for(var v=0,t;t=u[v];v++){if(t.oldTabIndex!==undefined){t.tabIndex=t.oldTabIndex;delete t.oldTabIndex}else{t.tabIndex=f.getTabOrder(t)}}},Mod:function(t,u){return((t%u)+u)%u},IndexOf:(Array.prototype.indexOf?function(t,u,v){return t.indexOf(u,v)}:function(t,w,x){for(var v=(x||0),u=t.length;v<u;v++){if(w===t[v]){return v}}return -1}),saveCookie:function(){n.Cookie.Set("menu",this.cookie)},getCookie:function(){this.cookie=n.Cookie.Get("menu")}});MathJax.Menu.NAV=h;var c=g.ITEM=h.Subclass({name:"",node:null,menu:null,Attributes:function(t){return f.Insert({onmouseup:g.Mouseup,ondragstart:m,onselectstart:m,onselectend:m,ontouchstart:g.Touchstart,ontouchend:g.Touchend,className:"MathJax_MenuItem",role:this.role,menuItem:this},t)},Create:function(v){if(!this.hidden){var u=this.Attributes();var t=this.Label(u,v);n.addElement(v,"div",u,t)}},Name:function(){return s(this.name[0],this.name[1])},Mouseover:function(t,u){if(u.parentNode===g.ActiveNode().parentNode){this.Deactivate(g.ActiveNode())}this.Activate(t,u)},Mouseout:function(t,u){this.Deactivate(u)},Mouseup:function(t,u){return this.Remove(t,u)},DeactivateSubmenus:function(y){var x=document.getElementById("MathJax_MenuFrame").childNodes,u=c.GetMenuNode(y).childNodes;for(var v=0,t=u.length;v<t;v++){var w=u[v].menuItem;if(w&&w.submenu&&w.submenu.posted&&w!==y.menuItem){w.Deactivate(u[v])}}this.RemoveSubmenus(y,x)},RemoveSubmenus:function(v,u){u=u||document.getElementById("MathJax_MenuFrame").childNodes;var t=u.length-1;while(t>=0&&c.GetMenuNode(v).menuItem!==u[t].menuItem){u[t].menuItem.posted=false;u[t].parentNode.removeChild(u[t]);t--}},Touchstart:function(t,u){return this.TouchEvent(t,u,"Mousedown")},Touchend:function(t,u){return this.TouchEvent(t,u,"Mouseup")},TouchEvent:function(u,v,t){if(this!==c.lastItem){if(c.lastMenu){g.Event(u,c.lastMenu,"Mouseout")}g.Event(u,v,"Mouseover",true);c.lastItem=this;c.lastMenu=v}if(this.nativeTouch){return null}g.Event(u,v,t);return false},Remove:function(t,u){u=u.parentNode.menuItem;return u.Remove(t,u)},With:function(t){if(t){f.Insert(this,t)}return this},isRTL:function(){return g.isRTL},rtlClass:function(){return(this.isRTL()?" RTL":"")}},{GetMenuNode:function(t){return t.parentNode}});g.ENTRY=g.ITEM.Subclass({role:"menuitem",Attributes:function(t){t=f.Insert({onmouseover:g.Mouseover,onmouseout:g.Mouseout,onmousedown:g.Mousedown,onkeydown:g.Keydown,"aria-disabled":!!this.disabled},t);t=this.SUPER(arguments).Attributes.call(this,t);if(this.disabled){t.className+=" MathJax_MenuDisabled"}return t},MoveVertical:function(t,D,v){var w=c.GetMenuNode(D);var C=[];for(var y=0,B=w.menuItem.items,x;x=B[y];y++){if(!x.hidden){C.push(x)}}var A=g.IndexOf(C,this);if(A===-1){return}var z=C.length;var u=w.childNodes;do{A=g.Mod(v(A),z)}while(C[A].hidden||!u[A].role||u[A].role==="separator");this.Deactivate(D);C[A].Activate(t,u[A])},Up:function(u,t){this.MoveVertical(u,t,function(v){return v-1})},Down:function(u,t){this.MoveVertical(u,t,function(v){return v+1})},Right:function(u,t){this.MoveHorizontal(u,t,g.Right,!this.isRTL())},Left:function(u,t){this.MoveHorizontal(u,t,g.Left,this.isRTL())},MoveHorizontal:function(z,y,t,A){var w=c.GetMenuNode(y);if(w.menuItem===g.menu&&z.shiftKey){t(z,y)}if(A){return}if(w.menuItem!==g.menu){this.Deactivate(y)}var u=w.previousSibling.childNodes;var x=u.length;while(x--){var v=u[x];if(v.menuItem.submenu&&v.menuItem.submenu===w.menuItem){g.Focus(v);break}}this.RemoveSubmenus(y)},Space:function(t,u){this.Mouseup(t,u)},Activate:function(t,u){this.Deactivate(u);if(!this.disabled){u.className+=" MathJax_MenuActive"}this.DeactivateSubmenus(u);g.Focus(u)},Deactivate:function(t){t.className=t.className.replace(/ MathJax_MenuActive/,"")}});g.ITEM.COMMAND=g.ENTRY.Subclass({action:function(){},Init:function(t,v,u){if(!(t instanceof Array)){t=[t,t]}this.name=t;this.action=v;this.With(u)},Label:function(t,u){return[this.Name()]},Mouseup:function(t,u){if(!this.disabled){this.Remove(t,u);d.Post(["command",this]);this.action.call(this,t)}return m(t)}});g.ITEM.SUBMENU=g.ENTRY.Subclass({submenu:null,marker:"\u25BA",markerRTL:"\u25C4",Attributes:function(t){t=f.Insert({"aria-haspopup":"true"},t);t=this.SUPER(arguments).Attributes.call(this,t);return t},Init:function(t,v){if(!(t instanceof Array)){t=[t,t]}this.name=t;var u=1;if(!(v instanceof g.ITEM)){this.With(v),u++}this.submenu=g.apply(g,[].slice.call(arguments,u))},Label:function(t,u){this.submenu.posted=false;return[this.Name()+" ",["span",{className:"MathJax_MenuArrow"+this.rtlClass()},[this.isRTL()?this.markerRTL:this.marker]]]},Timer:function(t,u){this.ClearTimer();t={type:t.type,clientX:t.clientX,clientY:t.clientY};this.timer=setTimeout(e(["Mouseup",this,t,u]),r.delay)},ClearTimer:function(){if(this.timer){clearTimeout(this.timer)}},Touchend:function(u,w){var v=this.submenu.posted;var t=this.SUPER(arguments).Touchend.apply(this,arguments);if(v){this.Deactivate(w);delete c.lastItem;delete c.lastMenu}return t},Mouseout:function(t,u){if(!this.submenu.posted){this.Deactivate(u)}this.ClearTimer()},Mouseover:function(t,u){this.Activate(t,u)},Mouseup:function(t,u){if(!this.disabled){if(!this.submenu.posted){this.ClearTimer();this.submenu.Post(t,u,this.ltr);g.Focus(u)}else{this.DeactivateSubmenus(u)}}return m(t)},Activate:function(t,u){if(!this.disabled){this.Deactivate(u);u.className+=" MathJax_MenuActive"}if(!this.submenu.posted){this.DeactivateSubmenus(u);if(!g.isMobile){this.Timer(t,u)}}g.Focus(u)},MoveVertical:function(v,u,t){this.ClearTimer();this.SUPER(arguments).MoveVertical.apply(this,arguments)},MoveHorizontal:function(v,x,u,w){if(!w){this.SUPER(arguments).MoveHorizontal.apply(this,arguments);return}if(this.disabled){return}if(!this.submenu.posted){this.Activate(v,x);return}var t=c.GetMenuNode(x).nextSibling.childNodes;if(t.length>0){this.submenu.items[0].Activate(v,t[0])}}});g.ITEM.RADIO=g.ENTRY.Subclass({variable:null,marker:(a?"\u25CF":"\u2713"),role:"menuitemradio",Attributes:function(u){var t=r.settings[this.variable]===this.value?"true":"false";u=f.Insert({"aria-checked":t},u);u=this.SUPER(arguments).Attributes.call(this,u);return u},Init:function(u,t,v){if(!(u instanceof Array)){u=[u,u]}this.name=u;this.variable=t;this.With(v);if(this.value==null){this.value=this.name[0]}},Label:function(u,v){var t={className:"MathJax_MenuRadioCheck"+this.rtlClass()};if(r.settings[this.variable]!==this.value){t={style:{display:"none"}}}return[["span",t,[this.marker]]," "+this.Name()]},Mouseup:function(w,x){if(!this.disabled){var y=x.parentNode.childNodes;for(var u=0,t=y.length;u<t;u++){var v=y[u].menuItem;if(v&&v.variable===this.variable){y[u].firstChild.style.display="none"}}x.firstChild.display="";r.settings[this.variable]=this.value;g.cookie[this.variable]=r.settings[this.variable];g.saveCookie();d.Post(["radio button",this])}this.Remove(w,x);if(this.action&&!this.disabled){this.action.call(g,this)}return m(w)}});g.ITEM.CHECKBOX=g.ENTRY.Subclass({variable:null,marker:"\u2713",role:"menuitemcheckbox",Attributes:function(u){var t=r.settings[this.variable]?"true":"false";u=f.Insert({"aria-checked":t},u);u=this.SUPER(arguments).Attributes.call(this,u);return u},Init:function(u,t,v){if(!(u instanceof Array)){u=[u,u]}this.name=u;this.variable=t;this.With(v)},Label:function(u,v){var t={className:"MathJax_MenuCheck"+this.rtlClass()};if(!r.settings[this.variable]){t={style:{display:"none"}}}return[["span",t,[this.marker]]," "+this.Name()]},Mouseup:function(t,u){if(!this.disabled){u.firstChild.display=(r.settings[this.variable]?"none":"");r.settings[this.variable]=!r.settings[this.variable];g.cookie[this.variable]=r.settings[this.variable];g.saveCookie();d.Post(["checkbox",this])}this.Remove(t,u);if(this.action&&!this.disabled){this.action.call(g,this)}return m(t)}});g.ITEM.LABEL=g.ENTRY.Subclass({role:"menuitem",Init:function(t,u){if(!(t instanceof Array)){t=[t,t]}this.name=t;this.With(u)},Label:function(t,u){t.className+=" MathJax_MenuLabel";return[this.Name()]},Activate:function(t,u){this.Deactivate(u);g.Focus(u)},Mouseup:function(t,u){}});g.ITEM.RULE=g.ITEM.Subclass({role:"separator",Attributes:function(t){t=f.Insert({"aria-orientation":"vertical"},t);t=this.SUPER(arguments).Attributes.call(this,t);return t},Label:function(t,u){t.className+=" MathJax_MenuRule";return null}});g.About=function(x){var u=g.About.GetFont();var z=g.About.GetFormat();var t=["MathJax.js v"+MathJax.fileversion,["br"]];t.push(["div",{style:{"border-top":"groove 2px",margin:".25em 0"}}]);g.About.GetJax(t,MathJax.InputJax,["InputJax","%1 Input Jax v%2"]);g.About.GetJax(t,MathJax.OutputJax,["OutputJax","%1 Output Jax v%2"]);g.About.GetJax(t,MathJax.ElementJax,["ElementJax","%1 Element Jax v%2"]);t.push(["div",{style:{"border-top":"groove 2px",margin:".25em 0"}}]);g.About.GetJax(t,MathJax.Extension,["Extension","%1 Extension v%2"],true);t.push(["div",{style:{"border-top":"groove 2px",margin:".25em 0"}}],["center",{},[f.Browser+" v"+f.Browser.version+(z?" \u2014 "+s(z.replace(/ /g,""),z):"")]]);g.About.div=g.Background(g.About);var w=n.addElement(g.About.div,"div",{id:"MathJax_About",tabIndex:0,onkeydown:g.About.Keydown},[["b",{style:{fontSize:"120%"}},["MathJax"]]," v"+MathJax.version,["br"],s(u.replace(/ /g,""),"using "+u),["br"],["br"],["span",{style:{display:"inline-block","text-align":"left","font-size":"80%","max-height":"20em",overflow:"auto","background-color":"#E4E4E4",padding:".4em .6em",border:"1px inset"},tabIndex:0},t],["br"],["br"],["a",{href:"http://www.mathjax.org/"},["www.mathjax.org"]],["span",{className:"MathJax_MenuClose",id:"MathJax_AboutClose",onclick:g.About.Remove,onkeydown:g.About.Keydown,tabIndex:0,role:"button","aria-label":s("CloseAboutDialog","Close about MathJax dialog")},[["span",{},"\u00D7"]]]]);if(x.type==="mouseup"){w.className+=" MathJax_MousePost"}w.focus();MathJax.Localization.setCSS(w);var y=(document.documentElement||{});var v=window.innerHeight||y.clientHeight||y.scrollHeight||0;if(g.prototype.msieAboutBug){w.style.width="20em";w.style.position="absolute";w.style.left=Math.floor((document.documentElement.scrollWidth-w.offsetWidth)/2)+"px";w.style.top=(Math.floor((v-w.offsetHeight)/3)+document.body.scrollTop)+"px"}else{w.style.marginLeft=Math.floor(-w.offsetWidth/2)+"px";w.style.top=Math.floor((v-w.offsetHeight)/3)+"px"}};g.About.Remove=function(t){if(g.About.div){document.body.removeChild(g.About.div);delete g.About.div}};g.About.Keydown=function(t){if(t.keyCode===b.ESCAPE||(this.id==="MathJax_AboutClose"&&(t.keyCode===b.SPACE||t.keyCode===b.RETURN))){g.About.Remove(t);g.CurrentNode().focus();m(t)}},g.About.GetJax=function(u,z,x,w){var y=[];for(var A in z){if(z.hasOwnProperty(A)&&z[A]){if((w&&z[A].version)||(z[A].isa&&z[A].isa(z))){y.push(s(x[0],x[1],(z[A].id||A),z[A].version))}}}y.sort();for(var v=0,t=y.length;v<t;v++){u.push(y[v],["br"])}return u};g.About.GetFont=function(){var t=MathJax.Hub.outputJax["jax/mml"][0]||{};var u={SVG:"web SVG",CommonHTML:"web TeX","HTML-CSS":(t.imgFonts?"image":(t.webFonts?"web":"local")+" "+t.fontInUse)}[t.id]||"generic";return u+" fonts"};g.About.GetFormat=function(){var t=MathJax.Hub.outputJax["jax/mml"][0]||{};if(t.id!=="HTML-CSS"||!t.webFonts||t.imgFonts){return}return t.allowWebFonts.replace(/otf/,"woff or otf")+" fonts"};g.Help=function(t){p.Require("[MathJax]/extensions/HelpDialog.js",function(){MathJax.Extension.Help.Dialog({type:t.type})})};g.ShowSource=function(x){if(!x){x=window.event}var w={screenX:x.screenX,screenY:x.screenY};if(!g.jax){return}if(this.format==="MathML"){var u=MathJax.ElementJax.mml;if(u&&typeof(u.mbase.prototype.toMathML)!=="undefined"){try{g.ShowSource.Text(g.jax.root.toMathML("",g.jax),x)}catch(v){if(!v.restart){throw v}e.After([this,g.ShowSource,w],v.restart)}}else{if(!p.loadingToMathML){p.loadingToMathML=true;g.ShowSource.Window(x);e.Queue(p.Require("[MathJax]/extensions/toMathML.js"),function(){delete p.loadingToMathML;if(!u.mbase.prototype.toMathML){u.mbase.prototype.toMathML=function(){}}},[this,g.ShowSource,w]);return}}}else{if(this.format==="Error"){g.ShowSource.Text(g.jax.errorText,x)}else{if(r.semanticsAnnotations[this.format]){var t=g.jax.root.getAnnotation(this.format);if(t.data[0]){g.ShowSource.Text(t.data[0].toString())}}else{if(g.jax.originalText==null){alert(s("NoOriginalForm","No original form available"));return}g.ShowSource.Text(g.jax.originalText,x)}}}};g.ShowSource.Window=function(u){if(!g.ShowSource.w){var v=[],t=r.windowSettings;for(var w in t){if(t.hasOwnProperty(w)){v.push(w+"="+t[w])}}g.ShowSource.w=window.open("","_blank",v.join(","))}return g.ShowSource.w};g.ShowSource.Text=function(y,v){var t=g.ShowSource.Window(v);delete g.ShowSource.w;y=y.replace(/^\s*/,"").replace(/\s*$/,"");y=y.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");var x=s("EqSource","MathJax Equation Source");if(g.isMobile){t.document.open();t.document.write("<html><head><meta name='viewport' content='width=device-width, initial-scale=1.0' /><title>"+x+"</title></head><body style='font-size:85%'>");t.document.write("<pre>"+y+"</pre>");t.document.write("<hr><input type='button' value='"+s("Close","Close")+"' onclick='window.close()' />");t.document.write("</body></html>");t.document.close()}else{t.document.open();t.document.write("<html><head><title>"+x+"</title></head><body style='font-size:85%'>");t.document.write("<table><tr><td><pre>"+y+"</pre></td></tr></table>");t.document.write("</body></html>");t.document.close();var u=t.document.body.firstChild;setTimeout(function(){var A=(t.outerHeight-t.innerHeight)||30,z=(t.outerWidth-t.innerWidth)||30,w,D;z=Math.max(140,Math.min(Math.floor(0.5*screen.width),u.offsetWidth+z+25));A=Math.max(40,Math.min(Math.floor(0.5*screen.height),u.offsetHeight+A+25));if(g.prototype.msieHeightBug){A+=35}t.resizeTo(z,A);var C;try{C=v.screenX}catch(B){}if(v&&C!=null){w=Math.max(0,Math.min(v.screenX-Math.floor(z/2),screen.width-z-20));D=Math.max(0,Math.min(v.screenY-Math.floor(A/2),screen.height-A-20));t.moveTo(w,D)}},50)}};g.Scale=function(){var y=["CommonHTML","HTML-CSS","SVG","NativeMML","PreviewHTML"],t=y.length,x=100,v,u;for(v=0;v<t;v++){u=q[y[v]];if(u){x=u.config.scale;break}}var w=prompt(s("ScaleMath","Scale all mathematics (compared to surrounding text) by"),x+"%");if(w){if(w.match(/^\s*\d+(\.\d*)?\s*%?\s*$/)){w=parseFloat(w);if(w){if(w!==x){for(v=0;v<t;v++){u=q[y[v]];if(u){u.config.scale=w}}g.cookie.scale=f.config.scale=w;g.saveCookie();f.Queue(["Rerender",f])}}else{alert(s("NonZeroScale","The scale should not be zero"))}}else{alert(s("PercentScale","The scale should be a percentage (e.g., 120%%)"))}}};g.Zoom=function(){if(!MathJax.Extension.MathZoom){p.Require("[MathJax]/extensions/MathZoom.js")}};g.Renderer=function(){var u=f.outputJax["jax/mml"];if(u[0]!==r.settings.renderer){var x=f.Browser,w,t=g.Renderer.Messages,v;switch(r.settings.renderer){case"NativeMML":if(!r.settings.warnedMML){if(x.isChrome&&x.version.substr(0,3)!=="24."){w=t.MML.WebKit}else{if(x.isSafari&&!x.versionAtLeast("5.0")){w=t.MML.WebKit}else{if(x.isMSIE){if(!x.hasMathPlayer){w=t.MML.MSIE}}else{if(x.isEdge){w=t.MML.WebKit}else{w=t.MML[x]}}}}v="warnedMML"}break;case"SVG":if(!r.settings.warnedSVG){if(x.isMSIE&&!l){w=t.SVG.MSIE}}break}if(w){w=s(w[0],w[1]);w+="\n\n";w+=s("SwitchAnyway","Switch the renderer anyway?\n\n(Press OK to switch, CANCEL to continue with the current renderer)");g.cookie.renderer=u[0].id;g.saveCookie();if(!confirm(w)){g.cookie.renderer=r.settings.renderer=n.Cookie.Get("menu").renderer;g.saveCookie();return}if(v){g.cookie.warned=r.settings.warned=true}g.cookie.renderer=r.settings.renderer;g.saveCookie()}f.Queue(["setRenderer",f,r.settings.renderer,"jax/mml"],["Rerender",f])}};g.Renderer.Messages={MML:{WebKit:["WebkitNativeMMLWarning","Your browser doesn't seem to support MathML natively, so switching to MathML output may cause the mathematics on the page to become unreadable."],MSIE:["MSIENativeMMLWarning","Internet Explorer requires the MathPlayer plugin in order to process MathML output."],Opera:["OperaNativeMMLWarning","Opera's support for MathML is limited, so switching to MathML output may cause some expressions to render poorly."],Safari:["SafariNativeMMLWarning","Your browser's native MathML does not implement all the features used by MathJax, so some expressions may not render properly."],Firefox:["FirefoxNativeMMLWarning","Your browser's native MathML does not implement all the features used by MathJax, so some expressions may not render properly."]},SVG:{MSIE:["MSIESVGWarning","SVG is not implemented in Internet Explorer prior to IE9 or when it is emulating IE8 or below. Switching to SVG output will cause the mathematics to not display properly."]}};g.AssistiveMML=function(v,t){var u=MathJax.Extension.AssistiveMML;if(!u){if(!t){p.Require("[MathJax]/extensions/AssistiveMML.js",["AssistiveMML",g,v,true])}return}MathJax.Hub.Queue([(r.settings.assistiveMML?"Add":"Remove")+"AssistiveMathML",u])};g.Font=function(){var t=q["HTML-CSS"];if(!t){return}document.location.reload()};g.Locale=function(){MathJax.Localization.setLocale(r.settings.locale);MathJax.Hub.Queue(["Reprocess",MathJax.Hub])};g.LoadLocale=function(){var t=prompt(s("LoadURL","Load translation data from this URL:"));if(t){if(!t.match(/\.js$/)){alert(s("BadURL","The URL should be for a javascript file that defines MathJax translation data.  Javascript file names should end with '.js'"))}p.Require(t,function(u){if(u!=p.STATUS.OK){alert(s("BadData","Failed to load translation data from %1",t))}})}};g.MPEvents=function(v){var u=r.settings.discoverable,t=g.MPEvents.Messages;if(!l){if(r.settings.mpMouse&&!confirm(s.apply(s,t.IE8warning))){delete g.cookie.mpContext;delete r.settings.mpContext;delete g.cookie.mpMouse;delete r.settings.mpMouse;g.saveCookie();return}r.settings.mpContext=r.settings.mpMouse;g.cookie.mpContext=g.cookie.mpMouse=r.settings.mpMouse;g.saveCookie();MathJax.Hub.Queue(["Rerender",MathJax.Hub])}else{if(!u&&v.name[1]==="Menu Events"&&r.settings.mpContext){alert(s.apply(s,t.IE9warning))}}};g.MPEvents.Messages={IE8warning:["IE8warning","This will disable the MathJax menu and zoom features, but you can Alt-Click on an expression to obtain the MathJax menu instead.\n\nReally change the MathPlayer settings?"],IE9warning:["IE9warning","The MathJax contextual menu will be disabled, but you can Alt-Click on an expression to obtain the MathJax menu instead."]};f.Browser.Select({MSIE:function(t){var u=(document.compatMode==="BackCompat");var v=t.versionAtLeast("8.0")&&document.documentMode>7;g.Augment({margin:20,msieBackgroundBug:((document.documentMode||0)<9),msieFixedPositionBug:(u||!v),msieAboutBug:u,msieHeightBug:((document.documentMode||0)<9)});if(l){delete r.styles["#MathJax_About"].filter;delete r.styles[".MathJax_Menu"].filter}},Firefox:function(t){g.skipMouseover=t.isMobile&&t.versionAtLeast("6.0");g.skipMousedown=t.isMobile}});g.isMobile=f.Browser.isMobile;g.noContextMenu=f.Browser.noContextMenu;g.CreateLocaleMenu=function(){if(!g.menu){return}var y=g.menu.Find("Language").submenu,v=y.items;var u=[],A=MathJax.Localization.strings;for(var z in A){if(A.hasOwnProperty(z)){u.push(z)}}u=u.sort();y.items=[];for(var w=0,t=u.length;w<t;w++){var x=A[u[w]].menuTitle;if(x){x+=" ("+u[w]+")"}else{x=u[w]}y.items.push(c.RADIO([u[w],x],"locale",{action:g.Locale}))}y.items.push(v[v.length-2],v[v.length-1])};g.CreateAnnotationMenu=function(){if(!g.menu){return}var v=g.menu.Find("Show Math As","Annotation").submenu;var u=r.semanticsAnnotations;for(var t in u){if(u.hasOwnProperty(t)){v.items.push(c.COMMAND([t,t],g.ShowSource,{hidden:true,nativeTouch:true,format:t}))}}};f.Register.StartupHook("End Config",function(){r.settings=f.config.menuSettings;if(typeof(r.settings.showRenderer)!=="undefined"){r.showRenderer=r.settings.showRenderer}if(typeof(r.settings.showFontMenu)!=="undefined"){r.showFontMenu=r.settings.showFontMenu}if(typeof(r.settings.showContext)!=="undefined"){r.showContext=r.settings.showContext}g.getCookie();g.menu=g(c.SUBMENU(["Show","Show Math As"],c.COMMAND(["MathMLcode","MathML Code"],g.ShowSource,{nativeTouch:true,format:"MathML"}),c.COMMAND(["Original","Original Form"],g.ShowSource,{nativeTouch:true}),c.SUBMENU(["Annotation","Annotation"],{disabled:true}),c.RULE(),c.CHECKBOX(["texHints","Show TeX hints in MathML"],"texHints"),c.CHECKBOX(["semantics","Add original form as annotation"],"semantics")),c.RULE(),c.SUBMENU(["Settings","Math Settings"],c.SUBMENU(["ZoomTrigger","Zoom Trigger"],c.RADIO(["Hover","Hover"],"zoom",{action:g.Zoom}),c.RADIO(["Click","Click"],"zoom",{action:g.Zoom}),c.RADIO(["DoubleClick","Double-Click"],"zoom",{action:g.Zoom}),c.RADIO(["NoZoom","No Zoom"],"zoom",{value:"None"}),c.RULE(),c.LABEL(["TriggerRequires","Trigger Requires:"]),c.CHECKBOX((f.Browser.isMac?["Option","Option"]:["Alt","Alt"]),"ALT"),c.CHECKBOX(["Command","Command"],"CMD",{hidden:!f.Browser.isMac}),c.CHECKBOX(["Control","Control"],"CTRL",{hidden:f.Browser.isMac}),c.CHECKBOX(["Shift","Shift"],"Shift")),c.SUBMENU(["ZoomFactor","Zoom Factor"],c.RADIO("125%","zscale"),c.RADIO("133%","zscale"),c.RADIO("150%","zscale"),c.RADIO("175%","zscale"),c.RADIO("200%","zscale"),c.RADIO("250%","zscale"),c.RADIO("300%","zscale"),c.RADIO("400%","zscale")),c.RULE(),c.SUBMENU(["Renderer","Math Renderer"],{hidden:!r.showRenderer},c.RADIO(["HTML-CSS","HTML-CSS"],"renderer",{action:g.Renderer}),c.RADIO(["CommonHTML","Common HTML"],"renderer",{action:g.Renderer,value:"CommonHTML"}),c.RADIO(["PreviewHTML","Preview HTML"],"renderer",{action:g.Renderer,value:"PreviewHTML"}),c.RADIO(["MathML","MathML"],"renderer",{action:g.Renderer,value:"NativeMML"}),c.RADIO(["SVG","SVG"],"renderer",{action:g.Renderer}),c.RADIO(["PlainSource","Plain Source"],"renderer",{action:g.Renderer,value:"PlainSource"}),c.RULE(),c.CHECKBOX(["FastPreview","Fast Preview"],"FastPreview"),c.CHECKBOX(["AssistiveMML","Assistive MathML"],"assistiveMML",{action:g.AssistiveMML}),c.CHECKBOX(["InTabOrder","Include in Tab Order"],"inTabOrder")),c.SUBMENU("MathPlayer",{hidden:!f.Browser.isMSIE||!r.showMathPlayer,disabled:!f.Browser.hasMathPlayer},c.LABEL(["MPHandles","Let MathPlayer Handle:"]),c.CHECKBOX(["MenuEvents","Menu Events"],"mpContext",{action:g.MPEvents,hidden:!l}),c.CHECKBOX(["MouseEvents","Mouse Events"],"mpMouse",{action:g.MPEvents,hidden:!l}),c.CHECKBOX(["MenuAndMouse","Mouse and Menu Events"],"mpMouse",{action:g.MPEvents,hidden:l})),c.SUBMENU(["FontPrefs","Font Preference"],{hidden:!r.showFontMenu},c.LABEL(["ForHTMLCSS","For HTML-CSS:"]),c.RADIO(["Auto","Auto"],"font",{action:g.Font}),c.RULE(),c.RADIO(["TeXLocal","TeX (local)"],"font",{action:g.Font}),c.RADIO(["TeXWeb","TeX (web)"],"font",{action:g.Font}),c.RADIO(["TeXImage","TeX (image)"],"font",{action:g.Font}),c.RULE(),c.RADIO(["STIXLocal","STIX (local)"],"font",{action:g.Font}),c.RADIO(["STIXWeb","STIX (web)"],"font",{action:g.Font}),c.RULE(),c.RADIO(["AsanaMathWeb","Asana Math (web)"],"font",{action:g.Font}),c.RADIO(["GyrePagellaWeb","Gyre Pagella (web)"],"font",{action:g.Font}),c.RADIO(["GyreTermesWeb","Gyre Termes (web)"],"font",{action:g.Font}),c.RADIO(["LatinModernWeb","Latin Modern (web)"],"font",{action:g.Font}),c.RADIO(["NeoEulerWeb","Neo Euler (web)"],"font",{action:g.Font})),c.SUBMENU(["ContextMenu","Contextual Menu"],{hidden:!r.showContext},c.RADIO(["MathJax","MathJax"],"context"),c.RADIO(["Browser","Browser"],"context")),c.COMMAND(["Scale","Scale All Math ..."],g.Scale),c.RULE().With({hidden:!r.showDiscoverable,name:["","discover_rule"]}),c.CHECKBOX(["Discoverable","Highlight on Hover"],"discoverable",{hidden:!r.showDiscoverable})),c.SUBMENU(["Locale","Language"],{hidden:!r.showLocale,ltr:true},c.RADIO("en","locale",{action:g.Locale}),c.RULE().With({hidden:!r.showLocaleURL,name:["","localURL_rule"]}),c.COMMAND(["LoadLocale","Load from URL ..."],g.LoadLocale,{hidden:!r.showLocaleURL})),c.RULE(),c.COMMAND(["About","About MathJax"],g.About),c.COMMAND(["Help","MathJax Help"],g.Help));if(g.isMobile){(function(){var u=r.settings;var t=g.menu.Find("Math Settings","Zoom Trigger").submenu;t.items[0].disabled=t.items[1].disabled=true;if(u.zoom==="Hover"||u.zoom=="Click"){u.zoom="None"}t.items=t.items.slice(0,4);if(navigator.appVersion.match(/[ (]Android[) ]/)){g.ITEM.SUBMENU.Augment({marker:"\u00BB"})}})()}g.CreateLocaleMenu();g.CreateAnnotationMenu()});g.showRenderer=function(t){g.cookie.showRenderer=r.showRenderer=t;g.saveCookie();g.menu.Find("Math Settings","Math Renderer").hidden=!t};g.showMathPlayer=function(t){g.cookie.showMathPlayer=r.showMathPlayer=t;g.saveCookie();g.menu.Find("Math Settings","MathPlayer").hidden=!t};g.showFontMenu=function(t){g.cookie.showFontMenu=r.showFontMenu=t;g.saveCookie();g.menu.Find("Math Settings","Font Preference").hidden=!t};g.showContext=function(t){g.cookie.showContext=r.showContext=t;g.saveCookie();g.menu.Find("Math Settings","Contextual Menu").hidden=!t};g.showDiscoverable=function(t){g.cookie.showDiscoverable=r.showDiscoverable=t;g.saveCookie();g.menu.Find("Math Settings","Highlight on Hover").hidden=!t;g.menu.Find("Math Settings","discover_rule").hidden=!t};g.showLocale=function(t){g.cookie.showLocale=r.showLocale=t;g.saveCookie();g.menu.Find("Language").hidden=!t};MathJax.Hub.Register.StartupHook("HTML-CSS Jax Ready",function(){if(!MathJax.OutputJax["HTML-CSS"].config.imageFont){g.menu.Find("Math Settings","Font Preference","TeX (image)").disabled=true}});e.Queue(f.Register.StartupHook("End Config",{}),["Styles",p,r.styles],["Post",f.Startup.signal,"MathMenu Ready"],["loadComplete",p,"[MathJax]/extensions/MathMenu.js"])})(MathJax.Hub,MathJax.HTML,MathJax.Ajax,MathJax.CallBack,MathJax.OutputJax);


/***/ },
/* 72 */
/***/ function(module, exports) {

	/*
	 *  /MathJax/extensions/MathZoom.js
	 *
	 *  Copyright (c) 2009-2015 The MathJax Consortium
	 *
	 *  Licensed under the Apache License, Version 2.0 (the "License");
	 *  you may not use this file except in compliance with the License.
	 *  You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 *  Unless required by applicable law or agreed to in writing, software
	 *  distributed under the License is distributed on an "AS IS" BASIS,
	 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *  See the License for the specific language governing permissions and
	 *  limitations under the License.
	 */

	(function(a,d,f,c,j){var k="2.6.0";var i=a.CombineConfig("MathZoom",{styles:{"#MathJax_Zoom":{position:"absolute","background-color":"#F0F0F0",overflow:"auto",display:"block","z-index":301,padding:".5em",border:"1px solid black",margin:0,"font-weight":"normal","font-style":"normal","text-align":"left","text-indent":0,"text-transform":"none","line-height":"normal","letter-spacing":"normal","word-spacing":"normal","word-wrap":"normal","white-space":"nowrap","float":"none","-webkit-box-sizing":"content-box","-moz-box-sizing":"content-box","box-sizing":"content-box","box-shadow":"5px 5px 15px #AAAAAA","-webkit-box-shadow":"5px 5px 15px #AAAAAA","-moz-box-shadow":"5px 5px 15px #AAAAAA","-khtml-box-shadow":"5px 5px 15px #AAAAAA",filter:"progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')"},"#MathJax_ZoomOverlay":{position:"absolute",left:0,top:0,"z-index":300,display:"inline-block",width:"100%",height:"100%",border:0,padding:0,margin:0,"background-color":"white",opacity:0,filter:"alpha(opacity=0)"},"#MathJax_ZoomFrame":{position:"relative",display:"inline-block",height:0,width:0},"#MathJax_ZoomEventTrap":{position:"absolute",left:0,top:0,"z-index":302,display:"inline-block",border:0,padding:0,margin:0,"background-color":"white",opacity:0,filter:"alpha(opacity=0)"}}});var e,b,g;MathJax.Hub.Register.StartupHook("MathEvents Ready",function(){g=MathJax.Extension.MathEvents.Event;e=MathJax.Extension.MathEvents.Event.False;b=MathJax.Extension.MathEvents.Hover});var h=MathJax.Extension.MathZoom={version:k,settings:a.config.menuSettings,scrollSize:18,HandleEvent:function(n,l,m){if(h.settings.CTRL&&!n.ctrlKey){return true}if(h.settings.ALT&&!n.altKey){return true}if(h.settings.CMD&&!n.metaKey){return true}if(h.settings.Shift&&!n.shiftKey){return true}if(!h[l]){return true}return h[l](n,m)},Click:function(m,l){if(this.settings.zoom==="Click"){return this.Zoom(m,l)}},DblClick:function(m,l){if(this.settings.zoom==="Double-Click"||this.settings.zoom==="DoubleClick"){return this.Zoom(m,l)}},Hover:function(m,l){if(this.settings.zoom==="Hover"){this.Zoom(m,l);return true}return false},Zoom:function(o,u){this.Remove();b.ClearHoverTimer();g.ClearSelection();var s=MathJax.OutputJax[u.jaxID];var p=s.getJaxFromMath(u);if(p.hover){b.UnHover(p)}var q=this.findContainer(u);var l=Math.floor(0.85*q.clientWidth),t=Math.max(document.body.clientHeight,document.documentElement.clientHeight);if(this.getOverflow(q)!=="visible"){t=Math.min(q.clientHeight,t)}t=Math.floor(0.85*t);var n=d.Element("span",{id:"MathJax_ZoomFrame"},[["span",{id:"MathJax_ZoomOverlay",onmousedown:this.Remove}],["span",{id:"MathJax_Zoom",onclick:this.Remove,style:{visibility:"hidden",fontSize:this.settings.zscale}},[["span",{style:{display:"inline-block","white-space":"nowrap"}}]]]]);var z=n.lastChild,w=z.firstChild,r=n.firstChild;u.parentNode.insertBefore(n,u);u.parentNode.insertBefore(u,n);if(w.addEventListener){w.addEventListener("mousedown",this.Remove,true)}var m=z.offsetWidth||z.clientWidth;l-=m;t-=m;z.style.maxWidth=l+"px";z.style.maxHeight=t+"px";if(this.msieTrapEventBug){var y=d.Element("span",{id:"MathJax_ZoomEventTrap",onmousedown:this.Remove});n.insertBefore(y,z)}if(this.msieZIndexBug){var v=d.addElement(document.body,"img",{src:"about:blank",id:"MathJax_ZoomTracker",width:0,height:0,style:{width:0,height:0,position:"relative"}});n.style.position="relative";n.style.zIndex=i.styles["#MathJax_ZoomOverlay"]["z-index"];n=v}var x=s.Zoom(p,w,u,l,t);if(this.msiePositionBug){if(this.msieSizeBug){z.style.height=x.zH+"px";z.style.width=x.zW+"px"}if(z.offsetHeight>t){z.style.height=t+"px";z.style.width=(x.zW+this.scrollSize)+"px"}if(z.offsetWidth>l){z.style.width=l+"px";z.style.height=(x.zH+this.scrollSize)+"px"}}if(this.operaPositionBug){z.style.width=Math.min(l,x.zW)+"px"}if(z.offsetWidth>m&&z.offsetWidth-m<l&&z.offsetHeight-m<t){z.style.overflow="visible"}this.Position(z,x);if(this.msieTrapEventBug){y.style.height=z.clientHeight+"px";y.style.width=z.clientWidth+"px";y.style.left=(parseFloat(z.style.left)+z.clientLeft)+"px";y.style.top=(parseFloat(z.style.top)+z.clientTop)+"px"}z.style.visibility="";if(this.settings.zoom==="Hover"){r.onmouseover=this.Remove}if(window.addEventListener){addEventListener("resize",this.Resize,false)}else{if(window.attachEvent){attachEvent("onresize",this.Resize)}else{this.onresize=window.onresize;window.onresize=this.Resize}}a.signal.Post(["math zoomed",p]);return e(o)},Position:function(p,r){p.style.display="none";var q=this.Resize(),m=q.x,s=q.y,l=r.mW;p.style.display="";var o=-l-Math.floor((p.offsetWidth-l)/2),n=r.Y;p.style.left=Math.max(o,10-m)+"px";p.style.top=Math.max(n,10-s)+"px";if(!h.msiePositionBug){h.SetWH()}},Resize:function(m){if(h.onresize){h.onresize(m)}var q=document.getElementById("MathJax_ZoomFrame"),l=document.getElementById("MathJax_ZoomOverlay");var o=h.getXY(q),n=h.findContainer(q);if(h.getOverflow(n)!=="visible"){l.scroll_parent=n;var p=h.getXY(n);o.x-=p.x;o.y-=p.y;p=h.getBorder(n);o.x-=p.x;o.y-=p.y}l.style.left=(-o.x)+"px";l.style.top=(-o.y)+"px";if(h.msiePositionBug){setTimeout(h.SetWH,0)}else{h.SetWH()}return o},SetWH:function(){var l=document.getElementById("MathJax_ZoomOverlay");if(!l){return}l.style.display="none";var m=l.scroll_parent||document.documentElement||document.body;l.style.width=m.scrollWidth+"px";l.style.height=Math.max(m.clientHeight,m.scrollHeight)+"px";l.style.display=""},findContainer:function(l){l=l.parentNode;while(l.parentNode&&l!==document.body&&h.getOverflow(l)==="visible"){l=l.parentNode}return l},getOverflow:(window.getComputedStyle?function(l){return getComputedStyle(l).overflow}:function(l){return(l.currentStyle||{overflow:"visible"}).overflow}),getBorder:function(o){var m={thin:1,medium:2,thick:3};var n=(window.getComputedStyle?getComputedStyle(o):(o.currentStyle||{borderLeftWidth:0,borderTopWidth:0}));var l=n.borderLeftWidth,p=n.borderTopWidth;if(m[l]){l=m[l]}else{l=parseInt(l)}if(m[p]){p=m[p]}else{p=parseInt(p)}return{x:l,y:p}},getXY:function(o){var l=0,n=0,m;m=o;while(m.offsetParent){l+=m.offsetLeft;m=m.offsetParent}if(h.operaPositionBug){o.style.border="1px solid"}m=o;while(m.offsetParent){n+=m.offsetTop;m=m.offsetParent}if(h.operaPositionBug){o.style.border=""}return{x:l,y:n}},Remove:function(n){var p=document.getElementById("MathJax_ZoomFrame");if(p){var o=MathJax.OutputJax[p.previousSibling.jaxID];var l=o.getJaxFromMath(p.previousSibling);a.signal.Post(["math unzoomed",l]);p.parentNode.removeChild(p);p=document.getElementById("MathJax_ZoomTracker");if(p){p.parentNode.removeChild(p)}if(h.operaRefreshBug){var m=d.addElement(document.body,"div",{style:{position:"fixed",left:0,top:0,width:"100%",height:"100%",backgroundColor:"white",opacity:0},id:"MathJax_OperaDiv"});document.body.removeChild(m)}if(window.removeEventListener){removeEventListener("resize",h.Resize,false)}else{if(window.detachEvent){detachEvent("onresize",h.Resize)}else{window.onresize=h.onresize;delete h.onresize}}}return e(n)}};a.Browser.Select({MSIE:function(l){var n=(document.documentMode||0);var m=(n>=9);h.msiePositionBug=!m;h.msieSizeBug=l.versionAtLeast("7.0")&&(!document.documentMode||n===7||n===8);h.msieZIndexBug=(n<=7);h.msieInlineBlockAlignBug=(n<=7);h.msieTrapEventBug=!window.addEventListener;if(document.compatMode==="BackCompat"){h.scrollSize=52}if(m){delete i.styles["#MathJax_Zoom"].filter}},Opera:function(l){h.operaPositionBug=true;h.operaRefreshBug=true}});h.topImg=(h.msieInlineBlockAlignBug?d.Element("img",{style:{width:0,height:0,position:"relative"},src:"about:blank"}):d.Element("span",{style:{width:0,height:0,display:"inline-block"}}));if(h.operaPositionBug||h.msieTopBug){h.topImg.style.border="1px solid"}MathJax.Callback.Queue(["StartupHook",MathJax.Hub.Register,"Begin Styles",{}],["Styles",f,i.styles],["Post",a.Startup.signal,"MathZoom Ready"],["loadComplete",f,"[MathJax]/extensions/MathZoom.js"])})(MathJax.Hub,MathJax.HTML,MathJax.Ajax,MathJax.OutputJax["HTML-CSS"],MathJax.OutputJax.NativeMML);


/***/ },
/* 73 */
/***/ function(module, exports) {

	/*
	 *  /MathJax/jax/output/HTML-CSS/jax.js
	 *
	 *  Copyright (c) 2009-2015 The MathJax Consortium
	 *
	 *  Licensed under the Apache License, Version 2.0 (the "License");
	 *  you may not use this file except in compliance with the License.
	 *  You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 *  Unless required by applicable law or agreed to in writing, software
	 *  distributed under the License is distributed on an "AS IS" BASIS,
	 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *  See the License for the specific language governing permissions and
	 *  limitations under the License.
	 */

	(function(h,b,d){var g,i=b.Browser.isMobile;var e=function(){var k=[].slice.call(arguments,0);k[0][0]=["HTML-CSS",k[0][0]];return MathJax.Message.Set.apply(MathJax.Message,k)};var f=MathJax.Object.Subclass({timeout:(i?15:8)*1000,comparisonFont:["sans-serif","monospace","script","Times","Courier","Arial","Helvetica"],testSize:["40px","50px","60px","30px","20px"],FedoraSTIXcheck:{family:"STIXSizeOneSym",testString:"abcABC",noStyleChar:true},Init:function(){this.div=MathJax.HTML.addElement(document.body,"div",{style:{position:"absolute",width:0,height:0,overflow:"hidden",padding:0,border:0,margin:0}},[["div",{id:"MathJax_Font_Test",style:{position:"absolute",visibility:"hidden",top:0,left:0,width:"auto",padding:0,border:0,margin:0,whiteSpace:"nowrap",textAlign:"left",textIndent:0,textTransform:"none",lineHeight:"normal",letterSpacing:"normal",wordSpacing:"normal",fontSize:this.testSize[0],fontWeight:"normal",fontStyle:"normal",fontSizeAdjust:"none"}},[""]]]).firstChild;this.text=this.div.firstChild},findFont:function(p,l){var o=null;if(l&&this.testCollection(l)){o=l}else{for(var n=0,k=p.length;n<k;n++){if(p[n]===l){continue}if(this.testCollection(p[n])){o=p[n];break}}}if(o==="STIX"&&this.testFont(this.FedoraSTIXcheck)){o=null}return o},testCollection:function(l){var k={testString:"() {} []"};k.family={TeX:"MathJax_Size1",STIX:"STIXSizeOneSym"}[l]||l.replace(/-(Math)?/,"")+"MathJax_Size1";if(l==="STIX"){k.noStyleChar=true}return this.testFont(k)},testFont:function(n){if(n.isWebFont&&d.FontFaceBug){this.div.style.fontWeight=this.div.style.fontStyle="normal"}else{this.div.style.fontWeight=(n.weight||"normal");this.div.style.fontStyle=(n.style||"normal")}var p=n.familyFixed||n.family;if(!n.isWebFont&&!p.match(/^(STIX|MathJax)|'/)){p=p.replace(/_/g," ").replace(/([a-z])([A-Z])/g,"$1 $2").replace(/ Jax/,"Jax")+"','"+p+"','"+p+"-";if(n.weight){p+="Bold"}if(n.style){p+="Italic"}if(!n.weight&&!n.style){p+="Regular"}n.familyFixed=p="'"+p+"'"}var l=this.getComparisonWidths(n.testString,n.noStyleChar);var q=null;if(l){this.div.style.fontFamily=p+","+this.comparisonFont[0];if(this.div.offsetWidth==l[0]){this.div.style.fontFamily=p+","+this.comparisonFont[l[2]];if(this.div.offsetWidth==l[1]){q=false}}if(q===null&&(this.div.offsetWidth!=l[3]||this.div.offsetHeight!=l[4])){if(!n.noStyleChar&&d.FONTDATA&&d.FONTDATA.hasStyleChar){for(var o=0,k=this.testSize.length;o<k;o++){if(this.testStyleChar(n,this.testSize[o])){q=true;k=0}}}else{q=true}}}if(d.safariTextNodeBug){this.div.innerHTML=""}else{this.text.nodeValue=""}return q},styleChar:"\uEFFD",versionChar:"\uEFFE",compChar:"\uEFFF",testStyleChar:function(m,p){var s=3+(m.weight?2:0)+(m.style?4:0);var l="",o=0;var r=this.div.style.fontSize;this.div.style.fontSize=p;if(d.msieItalicWidthBug&&m.style==="italic"){this.text.nodeValue=l=this.compChar;o=this.div.offsetWidth}if(d.safariTextNodeBug){this.div.innerHTML=this.compChar+l}else{this.text.nodeValue=this.compChar+l}var k=this.div.offsetWidth-o;if(d.safariTextNodeBug){this.div.innerHTML=this.styleChar+l}else{this.text.nodeValue=this.styleChar+l}var q=Math.floor((this.div.offsetWidth-o)/k+0.5);if(q===s){if(d.safariTextNodeBug){this.div.innerHTML=this.versionChar+l}else{this.text.nodeValue=this.versionChar+l}m.version=Math.floor((this.div.offsetWidth-o)/k+1.5)/2}this.div.style.fontSize=r;return(q===s)},getComparisonWidths:function(p,n){if(d.FONTDATA&&d.FONTDATA.hasStyleChar&&!n){p+=this.styleChar+" "+this.compChar}if(d.safariTextNodeBug){this.div.innerHTML=p}else{this.text.nodeValue=p}this.div.style.fontFamily=this.comparisonFont[0];var l=this.div.offsetWidth;this.div.style.fontFamily=d.webFontDefault;var r=this.div.offsetWidth,o=this.div.offsetHeight;for(var q=1,k=this.comparisonFont.length;q<k;q++){this.div.style.fontFamily=this.comparisonFont[q];if(this.div.offsetWidth!=l){return[l,this.div.offsetWidth,q,r,o]}}return null},loadWebFont:function(l){b.Startup.signal.Post("HTML-CSS Jax - Web-Font "+d.fontInUse+"/"+l.directory);var o=e(["LoadWebFont","Loading web-font %1",d.fontInUse+"/"+l.directory]);var k=MathJax.Callback({});var m=MathJax.Callback(["loadComplete",this,l,o,k]);h.timer.start(h,[this.checkWebFont,l,m],0,this.timeout);return k},loadComplete:function(m,p,l,k){MathJax.Message.Clear(p);if(k===h.STATUS.OK){this.webFontLoaded=true;l();return}this.loadError(m);if(b.Browser.isFirefox&&d.allowWebFonts){var o=document.location.protocol+"//"+document.location.hostname;if(document.location.port!=""){o+=":"+document.location.port}o+="/";if(h.fileURL(d.webfontDir).substr(0,o.length)!==o){this.firefoxFontError(m)}}if(!this.webFontLoaded){d.loadWebFontError(m,l)}else{l()}},loadError:function(k){e(["CantLoadWebFont","Can't load web font %1",d.fontInUse+"/"+k.directory],null,2000);b.Startup.signal.Post(["HTML-CSS Jax - web font error",d.fontInUse+"/"+k.directory,k])},firefoxFontError:function(k){e(["FirefoxCantLoadWebFont","Firefox can't load web fonts from a remote host"],null,3000);b.Startup.signal.Post("HTML-CSS Jax - Firefox web fonts on remote host error")},checkWebFont:function(k,l,m){if(k.time(m)){return}if(d.Font.testFont(l)){m(k.STATUS.OK)}else{setTimeout(k,k.delay)}},fontFace:function(o){var p=d.allowWebFonts;var r=d.FONTDATA.FONTS[o];if(d.msieFontCSSBug&&!r.family.match(/-Web$/)){r.family+="-Web"}if(r.isWebFont){delete r.familyFixed}var k=d.webfontDir+"/"+p;var n=h.fileURL(k);var m=o.replace(/-b/,"-B").replace(/-i/,"-I").replace(/-Bold-/,"-Bold");if(!m.match(/-/)){m+="-Regular"}if(p==="svg"){m+=".svg#"+m}else{m+="."+p}var l=h.fileRev(k+"/"+m.replace(/#.*/,""));var q={"font-family":r.family,src:"url('"+n+"/"+m+l+"')"};if(p==="otf"){m=m.replace(/otf$/,"woff");l=h.fileRev(k+"/"+m);q.src+=" format('opentype')";n=h.fileURL(d.webfontDir+"/woff");q.src="url('"+n+"/"+m+l+"') format('woff'), "+q.src}else{if(p!=="eot"){q.src+=" format('"+p+"')"}}if(!(d.FontFaceBug&&r.isWebFont)){if(o.match(/-bold/)){q["font-weight"]="bold"}if(o.match(/-italic/)){q["font-style"]="italic"}}return q}});var j,a,c;d.Augment({config:{styles:{".MathJax":{display:"inline","font-style":"normal","font-weight":"normal","line-height":"normal","font-size":"100%","font-size-adjust":"none","text-indent":0,"text-align":"left","text-transform":"none","letter-spacing":"normal","word-spacing":"normal","word-wrap":"normal","white-space":"nowrap","float":"none",direction:"ltr","max-width":"none","max-height":"none","min-width":0,"min-height":0,border:0,padding:0,margin:0},".MathJax:focus, body :focus .MathJax":{display:"inline-table"},".MathJax_Display":{position:"relative",display:"block!important","text-indent":0,"max-width":"none","max-height":"none","min-width":0,"min-height":0,width:"100%"},".MathJax img, .MathJax nobr, .MathJax a":{border:0,padding:0,margin:0,"max-width":"none","max-height":"none","min-width":0,"min-height":0,"vertical-align":0,"line-height":"normal","text-decoration":"none"},"img.MathJax_strut":{border:"0!important",padding:"0!important",margin:"0!important","vertical-align":"0!important"},".MathJax span":{display:"inline",position:"static",border:0,padding:0,margin:0,"vertical-align":0,"line-height":"normal","text-decoration":"none"},".MathJax nobr":{"white-space":"nowrap!important"},".MathJax img":{display:"inline!important","float":"none!important"},".MathJax *":{transition:"none","-webkit-transition":"none","-moz-transition":"none","-ms-transition":"none","-o-transition":"none"},".MathJax_Processing":{visibility:"hidden",position:"fixed",width:0,height:0,overflow:"hidden"},".MathJax_Processed":{display:"none!important"},".MathJax_ExBox":{display:"block!important",overflow:"hidden",width:"1px",height:"60ex","min-height":0,"max-height":"none"},".MathJax .MathJax_EmBox":{display:"block!important",overflow:"hidden",width:"1px",height:"60em","min-height":0,"max-height":"none"},".MathJax .MathJax_HitBox":{cursor:"text",background:"white",opacity:0,filter:"alpha(opacity=0)"},".MathJax .MathJax_HitBox *":{filter:"none",opacity:1,background:"transparent"},"#MathJax_Tooltip":{position:"absolute",left:0,top:0,width:"auto",height:"auto",display:"none"},"#MathJax_Tooltip *":{filter:"none",opacity:1,background:"transparent"},"@font-face":{"font-family":"MathJax_Blank",src:"url('about:blank')"}}},settings:b.config.menuSettings,Font:null,webFontDefault:"MathJax_Blank",allowWebFonts:"otf",maxStretchyParts:1000,fontName:{TeXLocal:"TeX",TeXWeb:["","TeX"],TeXImage:["",""],STIXLocal:["STIX","STIX-Web"],STIXWeb:"STIX-Web",AsanaMathWeb:"Asana-Math",GyrePagellaWeb:"Gyre-Pagella",GyreTermesWeb:"Gyre-Termes",LatinModernWeb:"Latin-Modern",NeoEulerWeb:"Neo-Euler"},fontInUse:"generic",FONTDATA:{TeX_factor:1,baselineskip:1.2,lineH:0.8,lineD:0.2,ffLineH:0.8,FONTS:{},VARIANT:{normal:{fonts:[]},"-generic-variant":{},"-largeOp":{},"-smallOp":{}},RANGES:[],DELIMITERS:{},RULECHAR:45,REMAP:{}},Config:function(){if(!this.require){this.require=[]}this.Font=f();this.SUPER(arguments).Config.call(this);var m=this.settings,l=this.config,k=m.font;if(this.adjustAvailableFonts){this.adjustAvailableFonts(l.availableFonts)}if(m.scale){l.scale=m.scale}if(k&&k!=="Auto"&&this.fontName[k]){l.availableFonts=[];delete l.fonts;if(this.fontName[k] instanceof Array){l.preferredFont=this.fontName[k][0];l.webFont=this.fontName[k][1]}else{l.preferredFont=l.webFont=this.fontName[k]}if(l.preferredFont){l.availableFonts[0]=l.preferredFont}}if(l.fonts){l.availableFonts=l.fonts;l.preferredFont=l.webFont=l.fonts[0];if(l.webFont==="STIX"){l.webFont+="-Web"}}k=this.Font.findFont(l.availableFonts,l.preferredFont);if(!k&&this.allowWebFonts){k=l.webFont;if(k){this.webFonts=true}}if(!k&&this.config.imageFont){k=l.imageFont;this.imgFonts=true}if(k){this.fontInUse=k;this.fontDir+="/"+k;this.webfontDir+="/"+k;this.require.push(this.fontDir+"/fontdata.js");if(this.imgFonts){this.require.push(this.directory+"/imageFonts.js");b.Startup.signal.Post("HTML-CSS Jax - using image fonts")}}else{e(["CantFindFontUsing","Can't find a valid font using %1","["+this.config.availableFonts.join(", ")+"]"],null,3000);b.Startup.signal.Post("HTML-CSS Jax - no valid font")}this.require.push(MathJax.OutputJax.extensionDir+"/MathEvents.js")},Startup:function(){j=MathJax.Extension.MathEvents.Event;a=MathJax.Extension.MathEvents.Touch;c=MathJax.Extension.MathEvents.Hover;this.ContextMenu=j.ContextMenu;this.Mousedown=j.AltContextMenu;this.Mouseover=c.Mouseover;this.Mouseout=c.Mouseout;this.Mousemove=c.Mousemove;this.hiddenDiv=this.Element("div",{style:{visibility:"hidden",overflow:"hidden",position:"absolute",top:0,height:"1px",width:"auto",padding:0,border:0,margin:0,textAlign:"left",textIndent:0,textTransform:"none",lineHeight:"normal",letterSpacing:"normal",wordSpacing:"normal"}});if(!document.body.firstChild){document.body.appendChild(this.hiddenDiv)}else{document.body.insertBefore(this.hiddenDiv,document.body.firstChild)}this.hiddenDiv=this.addElement(this.hiddenDiv,"div",{id:"MathJax_Hidden"});var l=this.addElement(this.hiddenDiv,"div",{style:{width:"5in"}});this.pxPerInch=l.offsetWidth/5;this.hiddenDiv.removeChild(l);this.startMarker=this.createStrut(this.Element("span"),10,true);this.endMarker=this.addText(this.Element("span"),"x").parentNode;this.HDspan=this.Element("span");if(this.operaHeightBug){this.createStrut(this.HDspan,0)}if(this.msieInlineBlockAlignBug){this.HDimg=this.addElement(this.HDspan,"img",{style:{height:"0px",width:"1px"}});try{this.HDimg.src="about:blank"}catch(k){}}else{this.HDimg=this.createStrut(this.HDspan,0)}this.EmExSpan=this.Element("span",{style:{position:"absolute","font-size-adjust":"none"}},[["span",{className:"MathJax_ExBox"}],["span",{className:"MathJax"},[["span",{className:"MathJax_EmBox"}]]]]);this.linebreakSpan=this.Element("span",null,[["hr",{style:{width:"100%",size:1,padding:0,border:0,margin:0}}]]);return h.Styles(this.config.styles,["InitializeHTML",this])},removeSTIXfonts:function(n){for(var l=0,k=n.length;l<k;l++){if(n[l]==="STIX"){n.splice(l,1);k--;l--}}if(this.config.preferredFont==="STIX"){this.config.preferredFont=n[0]}},PreloadWebFonts:function(){if(!d.allowWebFonts||!d.config.preloadWebFonts){return}for(var l=0,k=d.config.preloadWebFonts.length;l<k;l++){var n=d.FONTDATA.FONTS[d.config.preloadWebFonts[l]];if(!n.available){d.Font.testFont(n)}}},InitializeHTML:function(){this.PreloadWebFonts();this.getDefaultExEm();if(this.defaultEm){return}var k=MathJax.Callback();h.timer.start(h,function(l){if(l.time(k)){b.signal.Post(["HTML-CSS Jax - no default em size"]);return}d.getDefaultExEm();if(d.defaultEm){k()}else{setTimeout(l,l.delay)}},this.defaultEmDelay,this.defaultEmTimeout);return k},defaultEmDelay:100,defaultEmTimeout:1000,getDefaultExEm:function(){document.body.appendChild(this.EmExSpan);document.body.appendChild(this.linebreakSpan);this.defaultEx=this.EmExSpan.firstChild.offsetHeight/60;this.defaultEm=this.EmExSpan.lastChild.firstChild.offsetHeight/60;this.defaultWidth=this.linebreakSpan.firstChild.offsetWidth;document.body.removeChild(this.linebreakSpan);document.body.removeChild(this.EmExSpan)},preTranslate:function(q){var p=q.jax[this.id],B,x=p.length,w,E,u,A,s,C,l,D,k,F,t,r=false,y,o=this.config.linebreaks.automatic,v=this.config.linebreaks.width;if(o){r=(v.match(/^\s*(\d+(\.\d*)?%\s*)?container\s*$/)!=null);if(r){v=v.replace(/\s*container\s*/,"")}else{t=this.defaultWidth}if(v===""){v="100%"}}else{t=100000}for(B=0;B<x;B++){E=p[B];if(!E.parentNode){continue}u=E.previousSibling;if(u&&String(u.className).match(/^MathJax(_Display)?( MathJax_Processing)?$/)){u.parentNode.removeChild(u)}l=E.MathJax.elementJax;if(!l){continue}l.HTMLCSS={display:(l.root.Get("display")==="block")};A=s=this.Element("span",{className:"MathJax",id:l.inputID+"-Frame",isMathJax:true,jaxID:this.id,oncontextmenu:j.Menu,onmousedown:j.Mousedown,onmouseover:j.Mouseover,onmouseout:j.Mouseout,onmousemove:j.Mousemove,onclick:j.Click,ondblclick:j.DblClick,onkeydown:j.Keydown,tabIndex:b.getTabOrder(l)});if(b.Browser.noContextMenu){A.ontouchstart=a.start;A.ontouchend=a.end}if(l.HTMLCSS.display){s=this.Element("div",{className:"MathJax_Display"});s.appendChild(A)}else{if(this.msieDisappearingBug){A.style.display="inline-block"}}s.className+=" MathJax_Processing";E.parentNode.insertBefore(s,E);E.parentNode.insertBefore(this.EmExSpan.cloneNode(true),E);s.parentNode.insertBefore(this.linebreakSpan.cloneNode(true),s)}var z=[];for(B=0;B<x;B++){E=p[B];if(!E.parentNode){continue}C=E.previousSibling;s=C.previousSibling;l=E.MathJax.elementJax;if(!l){continue}D=C.firstChild.offsetHeight/60;k=C.lastChild.firstChild.offsetHeight/60;y=s.previousSibling.firstChild.offsetWidth;if(r){t=y}if(D===0||D==="NaN"){z.push(s);l.HTMLCSS.isHidden=true;D=this.defaultEx;k=this.defaultEm;y=this.defaultWidth;if(r){t=y}}F=(this.config.matchFontHeight?D/this.TeX.x_height/k:1);F=Math.floor(Math.max(this.config.minScaleAdjust/100,F)*this.config.scale);l.HTMLCSS.scale=F/100;l.HTMLCSS.fontSize=F+"%";l.HTMLCSS.em=l.HTMLCSS.outerEm=k;this.em=k*F/100;l.HTMLCSS.ex=D;l.HTMLCSS.cwidth=y/this.em;l.HTMLCSS.lineWidth=(o?this.length2em(v,1,t/this.em):1000000)}for(B=0,w=z.length;B<w;B++){this.hiddenDiv.appendChild(z[B]);this.addElement(this.hiddenDiv,"br")}for(B=0;B<x;B++){E=p[B];if(!E.parentNode){continue}C=p[B].previousSibling;l=p[B].MathJax.elementJax;if(!l){continue}A=C.previousSibling;if(!l.HTMLCSS.isHidden){A=A.previousSibling}A.parentNode.removeChild(A);C.parentNode.removeChild(C)}q.HTMLCSSeqn=q.HTMLCSSlast=0;q.HTMLCSSi=-1;q.HTMLCSSchunk=this.config.EqnChunk;q.HTMLCSSdelay=false},PHASE:{I:1,II:2,III:3},Translate:function(l,p){if(!l.parentNode){return}if(p.HTMLCSSdelay){p.HTMLCSSdelay=false;b.RestartAfter(MathJax.Callback.Delay(this.config.EqnChunkDelay))}var k=l.MathJax.elementJax,o=k.root,m=document.getElementById(k.inputID+"-Frame"),q=(k.HTMLCSS.display?(m||{}).parentNode:m);if(!q){return}this.getMetrics(k);if(this.scale!==1){m.style.fontSize=k.HTMLCSS.fontSize}this.initImg(m);this.initHTML(o,m);this.savePreview(l);try{o.setTeXclass();k.HTMLCSS.span=m;k.HTMLCSS.div=q;o.toHTML(m,q,this.PHASE.I)}catch(n){if(n.restart){while(m.firstChild){m.removeChild(m.firstChild)}}this.restorePreview(l);throw n}this.restorePreview(l);q.className=q.className.split(/ /)[0]+" MathJax_Processed";b.signal.Post(["New Math Pending",k.inputID]);p.HTMLCSSeqn+=(p.i-p.HTMLCSSi);p.HTMLCSSi=p.i;if(p.HTMLCSSeqn>=p.HTMLCSSlast+p.HTMLCSSchunk){this.postTranslate(p,true);p.HTMLCSSchunk=Math.floor(p.HTMLCSSchunk*this.config.EqnChunkFactor);p.HTMLCSSdelay=true}return false},savePreview:function(k){var l=k.MathJax.preview;if(l){k.MathJax.tmpPreview=document.createElement("span");l.parentNode.replaceChild(k.MathJax.tmpPreview,l)}},restorePreview:function(k){var l=k.MathJax.tmpPreview;if(l){l.parentNode.replaceChild(k.MathJax.preview,l);delete k.MathJax.tmpPreview}},getMetrics:function(k){var l=k.HTMLCSS;this.em=g.mbase.prototype.em=l.em*l.scale;this.outerEm=l.em;this.scale=l.scale;this.cwidth=l.cwidth;this.linebreakWidth=l.lineWidth},postTranslate:function(l,s){var p=l.jax[this.id],t,n,q,o;for(q=l.HTMLCSSlast,o=l.HTMLCSSeqn;q<o;q++){t=p[q];if(t&&t.MathJax.elementJax){var k=t.MathJax.elementJax.HTMLCSS.div;k.className=k.className.split(/ /)[0];if(t.MathJax.preview){t.MathJax.preview.innerHTML=""}}}for(q=l.HTMLCSSlast,o=l.HTMLCSSeqn;q<o;q++){t=p[q];if(t&&t.MathJax.elementJax){n=t.MathJax.elementJax;this.getMetrics(n);n.root.toHTML(n.HTMLCSS.span,n.HTMLCSS.div,this.PHASE.II)}}for(q=l.HTMLCSSlast,o=l.HTMLCSSeqn;q<o;q++){t=p[q];if(t&&t.MathJax.elementJax){n=t.MathJax.elementJax;this.getMetrics(n);n.root.toHTML(n.HTMLCSS.span,n.HTMLCSS.div,this.PHASE.III);if(n.HTMLCSS.isHidden){t.parentNode.insertBefore(n.HTMLCSS.div,t)}delete n.HTMLCSS.span;delete n.HTMLCSS.div;t.MathJax.state=n.STATE.PROCESSED;b.signal.Post(["New Math",t.MathJax.elementJax.inputID])}}if(this.forceReflow){var r=(document.styleSheets||[])[0]||{};r.disabled=true;r.disabled=false}l.HTMLCSSlast=l.HTMLCSSeqn},getJaxFromMath:function(k){if(k.parentNode.className==="MathJax_Display"){k=k.parentNode}do{k=k.nextSibling}while(k&&k.nodeName.toLowerCase()!=="script");return b.getJaxFor(k)},getHoverSpan:function(k,l){return k.root.HTMLspanElement()},getHoverBBox:function(k,n,o){var p=n.bbox,m=k.HTMLCSS.outerEm;var l={w:p.w*m,h:p.h*m,d:p.d*m};if(p.width){l.width=p.width}return l},Zoom:function(l,w,v,k,t){w.className="MathJax";w.style.fontSize=l.HTMLCSS.fontSize;var z=w.appendChild(this.EmExSpan.cloneNode(true));var o=z.lastChild.firstChild.offsetHeight/60;this.em=g.mbase.prototype.em=o;this.outerEm=o/l.HTMLCSS.scale;z.parentNode.removeChild(z);this.scale=l.HTMLCSS.scale;this.linebreakWidth=l.HTMLCSS.lineWidth;this.cwidth=l.HTMLCSS.cwidth;this.zoomScale=parseInt(b.config.menuSettings.zscale)/100;this.idPostfix="-zoom";l.root.toHTML(w,w);this.idPostfix="";this.zoomScale=1;var x=l.root.HTMLspanElement().bbox,n=x.width;if(n){if(x.tw){k=x.tw*o}if(x.w*o<k){k=x.w*o}w.style.width=Math.floor(k-1.5*d.em)+"px";w.style.display="inline-block";var m=(l.root.id||"MathJax-Span-"+l.root.spanID)+"-zoom";var p=document.getElementById(m).firstChild;while(p&&p.style.width!==n){p=p.nextSibling}if(p){var s=p.offsetWidth;p.style.width="100%";if(s>k){w.style.width=(s+100)+"px"}}}p=w.firstChild.firstChild.style;if(x.H!=null&&x.H>x.h){p.marginTop=d.Em(x.H-Math.max(x.h,d.FONTDATA.lineH))}if(x.D!=null&&x.D>x.d){p.marginBottom=d.Em(x.D-Math.max(x.d,d.FONTDATA.lineD))}if(x.lw<0){p.paddingLeft=d.Em(-x.lw)}if(x.rw>x.w){p.marginRight=d.Em(x.rw-x.w)}w.style.position="absolute";if(!n){v.style.position="absolute"}var u=w.offsetWidth,r=w.offsetHeight,y=v.offsetHeight,q=v.offsetWidth;w.style.position=v.style.position="";return{Y:-j.getBBox(w).h,mW:q,mH:y,zW:u,zH:r}},initImg:function(k){},initHTML:function(l,k){},initFont:function(k){var m=d.FONTDATA.FONTS,l=d.config.availableFonts;if(l&&l.length&&d.Font.testFont(m[k])){m[k].available=true;if(m[k].familyFixed){m[k].family=m[k].familyFixed;delete m[k].familyFixed}return null}if(!this.allowWebFonts){return null}m[k].isWebFont=true;if(d.FontFaceBug){m[k].family=k;if(d.msieFontCSSBug){m[k].family+="-Web"}}return h.Styles({"@font-face":this.Font.fontFace(k)})},Remove:function(k){var l=document.getElementById(k.inputID+"-Frame");if(l){if(k.HTMLCSS.display){l=l.parentNode}l.parentNode.removeChild(l)}delete k.HTMLCSS},getHD:function(l,m){if(l.bbox&&this.config.noReflows&&!m){return{h:l.bbox.h,d:l.bbox.d}}var k=l.style.position;l.style.position="absolute";this.HDimg.style.height="0px";l.appendChild(this.HDspan);var n={h:l.offsetHeight};this.HDimg.style.height=n.h+"px";n.d=l.offsetHeight-n.h;n.h-=n.d;n.h/=this.em;n.d/=this.em;l.removeChild(this.HDspan);l.style.position=k;return n},getW:function(o){var l,n,m=(o.bbox||{}).w,p=o;if(o.bbox&&this.config.noReflows&&o.bbox.exactW!==false){if(!o.bbox.exactW){if(o.style.paddingLeft){m+=this.unEm(o.style.paddingLeft)*(o.scale||1)}if(o.style.paddingRight){m+=this.unEm(o.style.paddingRight)*(o.scale||1)}}return m}if(o.bbox&&o.bbox.exactW){return m}if((o.bbox&&m>=0&&!this.initialSkipBug&&!this.msieItalicWidthBug)||this.negativeBBoxes||!o.firstChild){l=o.offsetWidth;n=o.parentNode.offsetHeight}else{if(o.bbox&&m<0&&this.msieNegativeBBoxBug){l=-o.offsetWidth,n=o.parentNode.offsetHeight}else{var k=o.style.position;o.style.position="absolute";p=this.startMarker;o.insertBefore(p,o.firstChild);o.appendChild(this.endMarker);l=this.endMarker.offsetLeft-p.offsetLeft;o.removeChild(this.endMarker);o.removeChild(p);o.style.position=k}}if(n!=null){o.parentNode.HH=n/this.em}return l/this.em},Measured:function(m,l){var n=m.bbox;if(n.width==null&&n.w&&!n.isMultiline){var k=this.getW(m);n.rw+=k-n.w;n.w=k;n.exactW=true}if(!l){l=m.parentNode}if(!l.bbox){l.bbox=n}return m},Remeasured:function(l,k){k.bbox=this.Measured(l,k).bbox},MeasureSpans:function(o){var r=[],t,q,n,u,k,p,l,s;for(q=0,n=o.length;q<n;q++){t=o[q];if(!t){continue}u=t.bbox;s=this.parentNode(t);if(u.exactW||u.width||u.w===0||u.isMultiline||(this.config.noReflows&&u.exactW!==false)){if(!s.bbox){s.bbox=u}continue}if(this.negativeBBoxes||!t.firstChild||(u.w>=0&&!this.initialSkipBug)||(u.w<0&&this.msieNegativeBBoxBug)){r.push([t])}else{if(this.initialSkipBug){k=this.startMarker.cloneNode(true);p=this.endMarker.cloneNode(true);t.insertBefore(k,t.firstChild);t.appendChild(p);r.push([t,k,p,t.style.position]);t.style.position="absolute"}else{p=this.endMarker.cloneNode(true);t.appendChild(p);r.push([t,null,p])}}}for(q=0,n=r.length;q<n;q++){t=r[q][0];u=t.bbox;s=this.parentNode(t);if((u.w>=0&&!this.initialSkipBug)||this.negativeBBoxes||!t.firstChild){l=t.offsetWidth;s.HH=s.offsetHeight/this.em}else{if(u.w<0&&this.msieNegativeBBoxBug){l=-t.offsetWidth,s.HH=s.offsetHeight/this.em}else{l=r[q][2].offsetLeft-((r[q][1]||{}).offsetLeft||0)}}l/=this.em;u.rw+=l-u.w;u.w=l;u.exactW=true;if(!s.bbox){s.bbox=u}}for(q=0,n=r.length;q<n;q++){t=r[q];if(t[1]){t[1].parentNode.removeChild(t[1]),t[0].style.position=t[3]}if(t[2]){t[2].parentNode.removeChild(t[2])}}},Em:function(k){if(Math.abs(k)<0.0006){return"0em"}return k.toFixed(3).replace(/\.?0+$/,"")+"em"},EmRounded:function(k){k=(Math.round(k*d.em)+0.05)/d.em;if(Math.abs(k)<0.0006){return"0em"}return k.toFixed(3).replace(/\.?0+$/,"")+"em"},unEm:function(k){return parseFloat(k)},Px:function(k){k*=this.em;var l=(k<0?"-":"");return l+Math.abs(k).toFixed(1).replace(/\.?0+$/,"")+"px"},unPx:function(k){return parseFloat(k)/this.em},Percent:function(k){return(100*k).toFixed(1).replace(/\.?0+$/,"")+"%"},length2em:function(r,l,p){if(typeof(r)!=="string"){r=r.toString()}if(r===""){return""}if(r===g.SIZE.NORMAL){return 1}if(r===g.SIZE.BIG){return 2}if(r===g.SIZE.SMALL){return 0.71}if(r==="infinity"){return d.BIGDIMEN}var o=this.FONTDATA.TeX_factor,s=(d.zoomScale||1)/d.em;if(r.match(/mathspace$/)){return d.MATHSPACE[r]*o}var n=r.match(/^\s*([-+]?(?:\.\d+|\d+(?:\.\d*)?))?(pt|em|ex|mu|px|pc|in|mm|cm|%)?/);var k=parseFloat(n[1]||"1"),q=n[2];if(p==null){p=1}if(l==null){l=1}if(q==="em"){return k*o}if(q==="ex"){return k*d.TeX.x_height*o}if(q==="%"){return k/100*p}if(q==="px"){return k*s}if(q==="pt"){return k/10*o}if(q==="pc"){return k*1.2*o}if(q==="in"){return k*this.pxPerInch*s}if(q==="cm"){return k*this.pxPerInch*s/2.54}if(q==="mm"){return k*this.pxPerInch*s/25.4}if(q==="mu"){return k/18*o*l}return k*p},thickness2em:function(l,k){var m=d.TeX.rule_thickness;if(l===g.LINETHICKNESS.MEDIUM){return m}if(l===g.LINETHICKNESS.THIN){return 0.67*m}if(l===g.LINETHICKNESS.THICK){return 1.67*m}return this.length2em(l,k,m)},getPadding:function(l){var n={top:0,right:0,bottom:0,left:0},k=false;for(var o in n){if(n.hasOwnProperty(o)){var m=l.style["padding"+o.charAt(0).toUpperCase()+o.substr(1)];if(m){n[o]=this.length2em(m);k=true}}}return(k?n:false)},getBorders:function(p){var m={top:0,right:0,bottom:0,left:0},n={},l=false;for(var q in m){if(m.hasOwnProperty(q)){var k="border"+q.charAt(0).toUpperCase()+q.substr(1);var o=p.style[k+"Style"];if(o){l=true;m[q]=this.length2em(p.style[k+"Width"]);n[k]=[p.style[k+"Width"],p.style[k+"Style"],p.style[k+"Color"]].join(" ")}}}m.css=n;return(l?m:false)},setBorders:function(k,l){if(l){for(var m in l.css){if(l.css.hasOwnProperty(m)){k.style[m]=l.css[m]}}}},createStrut:function(m,l,n){var k=this.Element("span",{isMathJax:true,style:{display:"inline-block",overflow:"hidden",height:l+"px",width:"1px",marginRight:"-1px"}});if(n){m.insertBefore(k,m.firstChild)}else{m.appendChild(k)}return k},createBlank:function(l,k,m){var n=this.Element("span",{isMathJax:true,style:{display:"inline-block",overflow:"hidden",height:"1px",width:this.Em(k)}});if(k<0){n.style.marginRight=n.style.width;n.style.width=0}if(m){l.insertBefore(n,l.firstChild)}else{l.appendChild(n)}return n},createShift:function(l,k,n){var m=this.Element("span",{style:{marginLeft:this.Em(k)},isMathJax:true});if(n){l.insertBefore(m,l.firstChild)}else{l.appendChild(m)}return m},createSpace:function(p,n,o,q,m,s){if(n<-o){o=-n}var r=this.Em(n+o),k=this.Em(-o);if(this.msieInlineBlockAlignBug){k=this.Em(d.getHD(p.parentNode,true).d-o)}if(p.isBox||s){var l=(p.scale==null?1:p.scale);p.bbox={exactW:true,h:n*l,d:o*l,w:q*l,rw:q*l,lw:0};p.style.height=r;p.style.verticalAlign=k;p.HH=(n+o)*l}else{p=this.addElement(p,"span",{style:{height:r,verticalAlign:k},isMathJax:true})}if(q>=0){p.style.width=this.Em(q);p.style.display="inline-block";p.style.overflow="hidden"}else{if(this.msieNegativeSpaceBug){p.style.height=""}p.style.marginLeft=this.Em(q);if(d.safariNegativeSpaceBug&&p.parentNode.firstChild==p){this.createBlank(p,0,true)}}if(m&&m!==g.COLOR.TRANSPARENT){p.style.backgroundColor=m;p.style.position="relative"}return p},createRule:function(r,n,p,s,l){if(n<-p){p=-n}var m=d.TeX.min_rule_thickness,o=1;if(s>0&&s*this.em<m){s=m/this.em}if(n+p>0&&(n+p)*this.em<m){o=1/(n+p)*(m/this.em);n*=o;p*=o}if(!l){l="solid"}else{l="solid "+l}var k={display:"inline-block",overflow:"hidden",verticalAlign:this.Em(-p)};if(s>n+p){k.borderTop=this.Px(n+p)+" "+l;k.width=this.Em(s);k.height=(this.msieRuleBug&&n+p>0?this.Em(n+p):0)}else{k.borderLeft=this.Px(s)+" "+l;k.width=(this.msieRuleBug&&s>0?this.Em(s):0);k.height=this.Em(n+p)}var q=this.addElement(r,"span",{style:k,noAdjust:true,HH:n+p,isMathJax:true,bbox:{h:n,d:p,w:s,rw:s,lw:0,exactW:true}});if(r.isBox||r.className=="mspace"){r.bbox=q.bbox,r.HH=n+p}return q},createFrame:function(s,q,r,u,x,l){if(q<-r){r=-q}var p=2*x;if(this.msieFrameSizeBug){if(u<p){u=p}if(q+r<p){q=p-r}}if(this.msieBorderWidthBug){p=0}var v=this.Em(q+r-p),k=this.Em(-r-x),o=this.Em(u-p);var m=this.Px(x)+" "+l;var n=this.addElement(s,"span",{style:{border:m,display:"inline-block",overflow:"hidden",width:o,height:v},bbox:{h:q,d:r,w:u,rw:u,lw:0,exactW:true},noAdjust:true,HH:q+r,isMathJax:true});if(k){n.style.verticalAlign=k}return n},parentNode:function(l){var k=l.parentNode;if(k.nodeName.toLowerCase()==="a"){k=k.parentNode}return k},createStack:function(m,o,l){if(this.msiePaddingWidthBug){this.createStrut(m,0)}var n=String(l).match(/%$/);var k=(!n&&l!=null?l:0);m=this.addElement(m,"span",{noAdjust:true,HH:0,isMathJax:true,style:{display:"inline-block",position:"relative",width:(n?"100%":this.Em(k)),height:0}});if(!o){m.parentNode.bbox=m.bbox={exactW:true,h:-this.BIGDIMEN,d:-this.BIGDIMEN,w:k,lw:this.BIGDIMEN,rw:(!n&&l!=null?l:-this.BIGDIMEN)};if(n){m.bbox.width=l}}return m},createBox:function(l,k){var m=this.addElement(l,"span",{style:{position:"absolute"},isBox:true,isMathJax:true});if(k!=null){m.style.width=k}return m},addBox:function(k,l){l.style.position="absolute";l.isBox=l.isMathJax=true;return k.appendChild(l)},placeBox:function(u,s,q,o){u.isMathJax=true;var v=d.parentNode(u),C=u.bbox,z=v.bbox;if(this.msiePlaceBoxBug){this.addText(u,this.NBSP)}if(this.imgSpaceBug){this.addText(u,this.imgSpace)}var w,F=0;if(u.HH!=null){w=u.HH}else{if(C){w=Math.max(3,C.h+C.d)}else{w=u.offsetHeight/this.em}}if(!u.noAdjust){w+=1;w=Math.round(w*this.em)/this.em;if(this.msieInlineBlockAlignBug){this.addElement(u,"img",{className:"MathJax_strut",border:0,src:"about:blank",isMathJax:true,style:{width:0,height:this.Em(w)}})}else{this.addElement(u,"span",{isMathJax:true,style:{display:"inline-block",width:0,height:this.Em(w)}});if(d.chromeHeightBug){w-=(u.lastChild.offsetHeight-Math.round(w*this.em))/this.em}}}if(C){if(this.initialSkipBug){if(C.lw<0){F=C.lw;d.createBlank(u,-F,true)}if(C.rw>C.w){d.createBlank(u,C.rw-C.w+0.1)}}if(!this.msieClipRectBug&&!C.noclip&&!o){var B=3/this.em;var A=(C.H==null?C.h:C.H),m=(C.D==null?C.d:C.D);var E=w-A-B,p=w+m+B,n=-1000,k=C.rw+1000;u.style.clip="rect("+this.Em(E)+" "+this.Em(k)+" "+this.Em(p)+" "+this.Em(n)+")"}}u.style.top=this.Em(-q-w);u.style.left=this.Em(s+F);if(C&&z){if(C.H!=null&&(z.H==null||C.H+q>z.H)){z.H=C.H+q}if(C.D!=null&&(z.D==null||C.D-q>z.D)){z.D=C.D-q}if(C.h+q>z.h){z.h=C.h+q}if(C.d-q>z.d){z.d=C.d-q}if(z.H!=null&&z.H<=z.h){delete z.H}if(z.D!=null&&z.D<=z.d){delete z.D}if(C.w+s>z.w){z.w=C.w+s;if(z.width==null){v.style.width=this.Em(z.w)}}if(C.rw+s>z.rw){z.rw=C.rw+s}if(C.lw+s<z.lw){z.lw=C.lw+s}if(C.width!=null&&!C.isFixed){if(z.width==null){v.style.width=z.width="100%";if(C.minWidth){v.style.minWidth=z.minWidth=C.minWidth}}u.style.width=C.width}if(C.tw){z.tw=C.tw}}},alignBox:function(s,o,q,v){if(v==null){v=0}this.placeBox(s,v,q);if(this.msiePlaceBoxBug){var m=s.lastChild;while(m&&m.nodeName!=="#text"){m=m.previousSibling}if(m){s.removeChild(m)}}var u=s.bbox;if(u.isMultiline){return}var t=u.width!=null&&!u.isFixed;var k=0,p=v-u.w/2,n="50%";if(this.initialSkipBug){k=u.w-u.rw-0.1;p+=u.lw}if(this.msieMarginScaleBug){p=(p*this.em)+"px"}else{p=this.Em(p)}if(t){p=(v===0?"":this.Em(v));n=(50-parseFloat(u.width)/2)+"%"}b.Insert(s.style,({right:{left:"",right:this.Em(k-v)},center:{left:n,marginLeft:p}})[o])},setStackWidth:function(l,k){if(typeof(k)==="number"){l.style.width=this.Em(Math.max(0,k));var m=l.bbox;if(m){m.w=k;m.exactW=true}m=l.parentNode.bbox;if(m){m.w=k;m.exactW=true}}else{l.style.width=l.parentNode.style.width="100%";if(l.bbox){l.bbox.width=k}if(l.parentNode.bbox){l.parentNode.bbox.width=k}}},createDelimiter:function(u,k,n,q,o){if(!k){u.bbox={h:0,d:0,w:this.TeX.nulldelimiterspace,lw:0};u.bbox.rw=u.bbox.w;this.createSpace(u,u.bbox.h,u.bbox.d,u.bbox.w);return}if(!q){q=1}if(!(n instanceof Array)){n=[n,n]}var t=n[1];n=n[0];var l={alias:k};while(l.alias){k=l.alias;l=this.FONTDATA.DELIMITERS[k];if(!l){l={HW:[0,this.FONTDATA.VARIANT[g.VARIANT.NORMAL]]}}}if(l.load){b.RestartAfter(h.Require(this.fontDir+"/fontdata-"+l.load+".js"))}for(var s=0,p=l.HW.length;s<p;s++){if(l.HW[s][0]*q>=n-0.01||(s==p-1&&!l.stretch)){if(l.HW[s][2]){q*=l.HW[s][2]}if(l.HW[s][3]){k=l.HW[s][3]}var r=this.addElement(u,"span");this.createChar(r,[k,l.HW[s][1]],q,o);u.bbox=r.bbox;u.offset=0.65*u.bbox.w;u.scale=q;return}}if(l.stretch){this["extendDelimiter"+l.dir](u,t,l.stretch,q,o)}},extendDelimiterV:function(A,t,E,F,w){var o=this.createStack(A,true);var v=this.createBox(o),u=this.createBox(o);this.createChar(v,(E.top||E.ext),F,w);this.createChar(u,(E.bot||E.ext),F,w);var m={bbox:{w:0,lw:0,rw:0}},D=m,p;var B=v.bbox.h+v.bbox.d+u.bbox.h+u.bbox.d;var r=-v.bbox.h;this.placeBox(v,0,r,true);r-=v.bbox.d;if(E.mid){D=this.createBox(o);this.createChar(D,E.mid,F,w);B+=D.bbox.h+D.bbox.d}if(E.min&&t<B*E.min){t=B*E.min}if(t>B){m=this.Element("span");this.createChar(m,E.ext,F,w);var C=m.bbox.h+m.bbox.d,l=C-0.05,x,q,z=(E.mid?2:1);q=x=Math.min(Math.ceil((t-B)/(z*l)),this.maxStretchyParts);if(!E.fullExtenders){l=(t-B)/(z*x)}var s=(x/(x+1))*(C-l);l=C-s;r+=s+l-m.bbox.h;while(z-->0){while(x-->0){if(!this.msieCloneNodeBug){p=m.cloneNode(true)}else{p=this.Element("span");this.createChar(p,E.ext,F,w)}p.bbox=m.bbox;r-=l;this.placeBox(this.addBox(o,p),0,r,true)}r+=s-m.bbox.d;if(E.mid&&z){this.placeBox(D,0,r-D.bbox.h,true);x=q;r+=-(D.bbox.h+D.bbox.d)+s+l-m.bbox.h}}}else{r+=(B-t)/2;if(E.mid){this.placeBox(D,0,r-D.bbox.h,true);r+=-(D.bbox.h+D.bbox.d)}r+=(B-t)/2}this.placeBox(u,0,r-u.bbox.h,true);r-=u.bbox.h+u.bbox.d;A.bbox={w:Math.max(v.bbox.w,m.bbox.w,u.bbox.w,D.bbox.w),lw:Math.min(v.bbox.lw,m.bbox.lw,u.bbox.lw,D.bbox.lw),rw:Math.max(v.bbox.rw,m.bbox.rw,u.bbox.rw,D.bbox.rw),h:0,d:-r,exactW:true};A.scale=F;A.offset=0.55*A.bbox.w;A.isMultiChar=true;this.setStackWidth(o,A.bbox.w)},extendDelimiterH:function(B,o,E,G,y){var r=this.createStack(B,true);var p=this.createBox(r),C=this.createBox(r);this.createChar(p,(E.left||E.rep),G,y);this.createChar(C,(E.right||E.rep),G,y);var l=this.Element("span");this.createChar(l,E.rep,G,y);var D={bbox:{h:-this.BIGDIMEN,d:-this.BIGDIMEN}},m;this.placeBox(p,-p.bbox.lw,0,true);var u=(p.bbox.rw-p.bbox.lw)+(C.bbox.rw-C.bbox.lw)-0.05,t=p.bbox.rw-p.bbox.lw-0.025,v;if(E.mid){D=this.createBox(r);this.createChar(D,E.mid,G,y);u+=D.bbox.w}if(E.min&&o<u*E.min){o=u*E.min}if(o>u){var F=l.bbox.rw-l.bbox.lw,q=F-0.05,z,s,A=(E.mid?2:1);s=z=Math.min(Math.ceil((o-u)/(A*q)),this.maxStretchyParts);if(!E.fillExtenders){q=(o-u)/(A*z)}v=(z/(z+1))*(F-q);q=F-v;t-=l.bbox.lw+v;while(A-->0){while(z-->0){if(!this.cloneNodeBug){m=l.cloneNode(true)}else{m=this.Element("span");this.createChar(m,E.rep,G,y)}m.bbox=l.bbox;this.placeBox(this.addBox(r,m),t,0,true);t+=q}if(E.mid&&A){this.placeBox(D,t,0,true);t+=D.bbox.w-v;z=s}}}else{t-=(u-o)/2;if(E.mid){this.placeBox(D,t,0,true);t+=D.bbox.w}t-=(u-o)/2}this.placeBox(C,t,0,true);B.bbox={w:t+C.bbox.rw,lw:0,rw:t+C.bbox.rw,h:Math.max(p.bbox.h,l.bbox.h,C.bbox.h,D.bbox.h),d:Math.max(p.bbox.d,l.bbox.d,C.bbox.d,D.bbox.d),exactW:true};B.scale=G;B.isMultiChar=true;this.setStackWidth(r,B.bbox.w)},createChar:function(s,p,n,k){s.isMathJax=true;var r=s,t="",o={fonts:[p[1]],noRemap:true};if(k&&k===g.VARIANT.BOLD){o.fonts=[p[1]+"-bold",p[1]]}if(typeof(p[1])!=="string"){o=p[1]}if(p[0] instanceof Array){for(var q=0,l=p[0].length;q<l;q++){t+=String.fromCharCode(p[0][q])}}else{t=String.fromCharCode(p[0])}if(p[4]){n*=p[4]}if(n!==1||p[3]){r=this.addElement(s,"span",{style:{fontSize:this.Percent(n)},scale:n,isMathJax:true});this.handleVariant(r,o,t);s.bbox=r.bbox}else{this.handleVariant(s,o,t)}if(p[2]){s.style.marginLeft=this.Em(p[2])}if(p[3]){s.firstChild.style.verticalAlign=this.Em(p[3]);s.bbox.h+=p[3];if(s.bbox.h<0){s.bbox.h=0}}if(p[5]){s.bbox.h+=p[5]}if(p[6]){s.bbox.d+=p[6]}if(this.AccentBug&&s.bbox.w===0){r.firstChild.nodeValue+=this.NBSP}},positionDelimiter:function(l,k){k-=l.bbox.h;l.bbox.d-=k;l.bbox.h+=k;if(k){if(this.safariVerticalAlignBug||this.konquerorVerticalAlignBug||(this.operaVerticalAlignBug&&l.isMultiChar)){if(l.firstChild.style.display===""&&l.style.top!==""){l=l.firstChild;k-=d.unEm(l.style.top)}l.style.position="relative";l.style.top=this.Em(-k)}else{l.style.verticalAlign=this.Em(k);if(d.ffVerticalAlignBug){d.createRule(l.parentNode,l.bbox.h,0,0);delete l.parentNode.bbox}}}},handleVariant:function(z,o,r){var y="",w,B,s,C,k=z,l=!!z.style.fontFamily;if(r.length===0){return}if(!z.bbox){z.bbox={w:0,h:-this.BIGDIMEN,d:-this.BIGDIMEN,rw:-this.BIGDIMEN,lw:this.BIGDIMEN}}if(!o){o=this.FONTDATA.VARIANT[g.VARIANT.NORMAL]}C=o;for(var A=0,x=r.length;A<x;A++){o=C;w=r.charCodeAt(A);B=r.charAt(A);if(w>=55296&&w<56319){A++;w=(((w-55296)<<10)+(r.charCodeAt(A)-56320))+65536;if(this.FONTDATA.RemapPlane1){var D=this.FONTDATA.RemapPlane1(w,o);w=D.n;o=D.variant}}else{var t,q,u=this.FONTDATA.RANGES;for(t=0,q=u.length;t<q;t++){if(u[t].name==="alpha"&&o.noLowerCase){continue}var p=o["offset"+u[t].offset];if(p&&w>=u[t].low&&w<=u[t].high){if(u[t].remap&&u[t].remap[w]){w=p+u[t].remap[w]}else{w=w-u[t].low+p;if(u[t].add){w+=u[t].add}}if(o["variant"+u[t].offset]){o=this.FONTDATA.VARIANT[o["variant"+u[t].offset]]}break}}}if(o.remap&&o.remap[w]){w=o.remap[w];if(o.remap.variant){o=this.FONTDATA.VARIANT[o.remap.variant]}}else{if(this.FONTDATA.REMAP[w]&&!o.noRemap){w=this.FONTDATA.REMAP[w]}}if(w instanceof Array){o=this.FONTDATA.VARIANT[w[1]];w=w[0]}if(typeof(w)==="string"){r=w+r.substr(A+1);x=r.length;A=-1;continue}s=this.lookupChar(o,w);B=s[w];if(l||(!this.checkFont(s,k.style)&&!B[5].img)){if(y.length){this.addText(k,y);y=""}var v=!!k.style.fontFamily||!!z.style.fontStyle||!!z.style.fontWeight||!s.directory||l;l=false;if(k!==z){v=!this.checkFont(s,z.style);k=z}if(v){k=this.addElement(z,"span",{isMathJax:true,subSpan:true})}this.handleFont(k,s,k!==z)}y=this.handleChar(k,s,B,w,y);if(!(B[5]||{}).space){if(B[0]/1000>z.bbox.h){z.bbox.h=B[0]/1000}if(B[1]/1000>z.bbox.d){z.bbox.d=B[1]/1000}}if(z.bbox.w+B[3]/1000<z.bbox.lw){z.bbox.lw=z.bbox.w+B[3]/1000}if(z.bbox.w+B[4]/1000>z.bbox.rw){z.bbox.rw=z.bbox.w+B[4]/1000}z.bbox.w+=B[2]/1000;if((B[5]||{}).isUnknown){z.bbox.exactW=false}}if(y.length){this.addText(k,y)}if(z.scale&&z.scale!==1){z.bbox.h*=z.scale;z.bbox.d*=z.scale;z.bbox.w*=z.scale;z.bbox.lw*=z.scale;z.bbox.rw*=z.scale}if(r.length==1&&s.skew&&s.skew[w]){z.bbox.skew=s.skew[w]}},checkFont:function(k,l){var m=(l.fontWeight||"normal");if(m.match(/^\d+$/)){m=(parseInt(m)>=600?"bold":"normal")}return(k.family.replace(/'/g,"")===l.fontFamily.replace(/'/g,"")&&(k.style||"normal")===(l.fontStyle||"normal")&&(k.weight||"normal")===m)},handleFont:function(m,k,o){m.style.fontFamily=k.family;if(!k.directory){m.style.fontSize=Math.floor(d.config.scale/d.scale+0.5)+"%"}if(!(d.FontFaceBug&&k.isWebFont)){var l=k.style||"normal",n=k.weight||"normal";if(l!=="normal"||o){m.style.fontStyle=l}if(n!=="normal"||o){m.style.fontWeight=n}}},handleChar:function(l,k,s,r,q){var p=s[5];if(p.space){if(q.length){this.addText(l,q)}d.createShift(l,s[2]/1000);return""}if(p.img){return this.handleImg(l,k,s,r,q)}if(p.isUnknown&&this.FONTDATA.DELIMITERS[r]){if(q.length){this.addText(l,q)}var o=l.scale;d.createDelimiter(l,r,0,1,k);if(this.FONTDATA.DELIMITERS[r].dir==="V"){l.style.verticalAlign=this.Em(l.bbox.d);l.bbox.h+=l.bbox.d;l.bbox.d=0}l.scale=o;s[0]=l.bbox.h*1000;s[1]=l.bbox.d*1000;s[2]=l.bbox.w*1000;s[3]=l.bbox.lw*1000;s[4]=l.bbox.rw*1000;return""}if(p.c==null){if(r<=65535){p.c=String.fromCharCode(r)}else{var m=r-65536;p.c=String.fromCharCode((m>>10)+55296)+String.fromCharCode((m&1023)+56320)}}if(d.ffFontOptimizationBug&&s[4]-s[2]>125){l.style.textRendering="optimizeLegibility"}if(p.rfix){this.addText(l,q+p.c);d.createShift(l,p.rfix/1000);return""}if(s[2]||!this.msieAccentBug||q.length){return q+p.c}d.createShift(l,s[3]/1000);d.createShift(l,(s[4]-s[3])/1000);this.addText(l,p.c);d.createShift(l,-s[4]/1000);return""},handleImg:function(l,k,p,o,m){return m},lookupChar:function(p,s){var o,k;if(!p.FONTS){var r=this.FONTDATA.FONTS;var q=(p.fonts||this.FONTDATA.VARIANT.normal.fonts);if(!(q instanceof Array)){q=[q]}if(p.fonts!=q){p.fonts=q}p.FONTS=[];for(o=0,k=q.length;o<k;o++){if(r[q[o]]){p.FONTS.push(r[q[o]]);r[q[o]].name=q[o]}}}for(o=0,k=p.FONTS.length;o<k;o++){var l=p.FONTS[o];if(typeof(l)==="string"){delete p.FONTS;this.loadFont(l)}if(l[s]){if(l[s].length===5){l[s][5]={}}if(d.allowWebFonts&&!l.available){this.loadWebFont(l)}else{return l}}else{this.findBlock(l,s)}}return this.unknownChar(p,s)},unknownChar:function(k,m){var l=(k.defaultFont||{family:d.config.undefinedFamily});if(k.bold){l.weight="bold"}if(k.italic){l.style="italic"}if(!l[m]){l[m]=[800,200,500,0,500,{isUnknown:true}]}b.signal.Post(["HTML-CSS Jax - unknown char",m,k]);return l},findBlock:function(l,q){if(l.Ranges){for(var p=0,k=l.Ranges.length;p<k;p++){if(q<l.Ranges[p][0]){return}if(q<=l.Ranges[p][1]){var o=l.Ranges[p][2];for(var n=l.Ranges.length-1;n>=0;n--){if(l.Ranges[n][2]==o){l.Ranges.splice(n,1)}}this.loadFont(l.directory+"/"+o+".js")}}}},loadFont:function(l){var k=MathJax.Callback.Queue();k.Push(["Require",h,this.fontDir+"/"+l]);if(this.imgFonts){if(!MathJax.isPacked){l=l.replace(/\/([^\/]*)$/,d.imgPacked+"/$1")}k.Push(["Require",h,this.webfontDir+"/png/"+l])}b.RestartAfter(k.Push({}))},loadWebFont:function(k){k.available=k.isWebFont=true;if(d.FontFaceBug){k.family=k.name;if(d.msieFontCSSBug){k.family+="-Web"}}b.RestartAfter(this.Font.loadWebFont(k))},loadWebFontError:function(l,k){b.Startup.signal.Post("HTML-CSS Jax - disable web fonts");l.isWebFont=false;if(this.config.imageFont&&this.config.imageFont===this.fontInUse){this.imgFonts=true;b.Startup.signal.Post("HTML-CSS Jax - switch to image fonts");b.Startup.signal.Post("HTML-CSS Jax - using image fonts");e(["WebFontNotAvailable","Web-Fonts not available -- using image fonts instead"],null,3000);h.Require(this.directory+"/imageFonts.js",k)}else{this.allowWebFonts=false;k()}},Element:MathJax.HTML.Element,addElement:MathJax.HTML.addElement,TextNode:MathJax.HTML.TextNode,addText:MathJax.HTML.addText,ucMatch:MathJax.HTML.ucMatch,BIGDIMEN:10000000,ID:0,idPostfix:"",GetID:function(){this.ID++;return this.ID},MATHSPACE:{veryverythinmathspace:1/18,verythinmathspace:2/18,thinmathspace:3/18,mediummathspace:4/18,thickmathspace:5/18,verythickmathspace:6/18,veryverythickmathspace:7/18,negativeveryverythinmathspace:-1/18,negativeverythinmathspace:-2/18,negativethinmathspace:-3/18,negativemediummathspace:-4/18,negativethickmathspace:-5/18,negativeverythickmathspace:-6/18,negativeveryverythickmathspace:-7/18},TeX:{x_height:0.430554,quad:1,num1:0.676508,num2:0.393732,num3:0.44373,denom1:0.685951,denom2:0.344841,sup1:0.412892,sup2:0.362892,sup3:0.288888,sub1:0.15,sub2:0.247217,sup_drop:0.386108,sub_drop:0.05,delim1:2.39,delim2:1,axis_height:0.25,rule_thickness:0.06,big_op_spacing1:0.111111,big_op_spacing2:0.166666,big_op_spacing3:0.2,big_op_spacing4:0.6,big_op_spacing5:0.1,scriptspace:0.1,nulldelimiterspace:0.12,delimiterfactor:901,delimitershortfall:0.3,min_rule_thickness:1.25},NBSP:"\u00A0",rfuzz:0});MathJax.Hub.Register.StartupHook("mml Jax Ready",function(){g=MathJax.ElementJax.mml;g.mbase.Augment({toHTML:function(o){o=this.HTMLcreateSpan(o);if(this.type!="mrow"){o=this.HTMLhandleSize(o)}for(var l=0,k=this.data.length;l<k;l++){if(this.data[l]){this.data[l].toHTML(o)}}var s=this.HTMLcomputeBBox(o);var n=o.bbox.h,r=o.bbox.d,p=false,q;for(l=0,k=s.length;l<k;l++){q=s[l].HTMLspanElement().bbox;if(s[l].forceStretch||q.h!==n||q.d!==r){s[l].HTMLstretchV(o,n,r);p=true}else{if(s[l].needsBBox){p=true}}}if(p){this.HTMLcomputeBBox(o,true)}if(this.HTMLlineBreaks(o)){o=this.HTMLmultiline(o)}this.HTMLhandleSpace(o);this.HTMLhandleColor(o);if(this.data.length===1&&this.data[0]){q=this.data[0].HTMLspanElement().bbox;if(q.skew){o.bbox.skew=q.skew}}return o},HTMLlineBreaks:function(){return false},HTMLmultiline:function(){g.mbase.HTMLautoloadFile("multiline")},HTMLcomputeBBox:function(q,p,o,k){if(o==null){o=0}if(k==null){k=this.data.length}var n=q.bbox={exactW:true},r=[];while(o<k){var l=this.data[o];if(!l){continue}if(!p&&l.HTMLcanStretch("Vertical")){r.push(l);l=(l.CoreMO()||l);r[r.length-1].needsBBox=(l!==this.data[o])}this.HTMLcombineBBoxes(l,n);o++}this.HTMLcleanBBox(n);return r},HTMLcombineBBoxes:function(k,l){if(l.w==null){this.HTMLemptyBBox(l)}var n=(k.bbox?k:k.HTMLspanElement());if(!n||!n.bbox){return}var m=n.bbox;if(m.d>l.d){l.d=m.d}if(m.h>l.h){l.h=m.h}if(m.D!=null&&m.D>l.D){l.D=m.D}if(m.H!=null&&m.H>l.H){l.H=m.H}if(n.style.paddingLeft){l.w+=d.unEm(n.style.paddingLeft)*(n.scale||1)}if(l.w+m.lw<l.lw){l.lw=l.w+m.lw}if(l.w+m.rw>l.rw){l.rw=l.w+m.rw}l.w+=m.w;if(n.style.paddingRight){l.w+=d.unEm(n.style.paddingRight)*(n.scale||1)}if(m.width){l.width=m.width;l.minWidth=m.minWidth}if(m.tw){l.tw=m.tw}if(m.ic){l.ic=m.ic}else{delete l.ic}if(l.exactW&&!m.exactW){l.exactW=m.exactW}},HTMLemptyBBox:function(k){k.h=k.d=k.H=k.D=k.rw=-d.BIGDIMEN;k.w=0;k.lw=d.BIGDIMEN;return k},HTMLcleanBBox:function(k){if(k.h===this.BIGDIMEN){k.h=k.d=k.H=k.D=k.w=k.rw=k.lw=0}if(k.D<=k.d){delete k.D}if(k.H<=k.h){delete k.H}},HTMLzeroBBox:function(){return{h:0,d:0,w:0,lw:0,rw:0}},HTMLcanStretch:function(l){if(this.isEmbellished()){var k=this.Core();if(k&&k!==this){return k.HTMLcanStretch(l)}}return false},HTMLstretchH:function(l,k){return this.HTMLspanElement()},HTMLstretchV:function(l,k,m){return this.HTMLspanElement()},HTMLnotEmpty:function(k){while(k){if((k.type!=="mrow"&&k.type!=="texatom")||k.data.length>1){return true}k=k.data[0]}return false},HTMLmeasureChild:function(l,k){if(this.data[l]){d.Measured(this.data[l].toHTML(k),k)}else{k.bbox=this.HTMLzeroBBox()}},HTMLboxChild:function(l,k){if(!this.data[l]){this.SetData(l,g.mrow())}return this.data[l].toHTML(k)},HTMLcreateSpan:function(k){if(this.spanID){var l=this.HTMLspanElement();if(l&&(l.parentNode===k||(l.parentNode||{}).parentNode===k)){while(l.firstChild){l.removeChild(l.firstChild)}l.bbox=this.HTMLzeroBBox();l.scale=1;l.isMultChar=l.HH=null;l.style.cssText="";return l}}if(this.href){k=d.addElement(k,"a",{href:this.href,isMathJax:true})}k=d.addElement(k,"span",{className:this.type,isMathJax:true});if(d.imgHeightBug){k.style.display="inline-block"}if(this["class"]){k.className+=" "+this["class"]}if(!this.spanID){this.spanID=d.GetID()}k.id=(this.id||"MathJax-Span-"+this.spanID)+d.idPostfix;k.bbox=this.HTMLzeroBBox();this.styles={};if(this.style){k.style.cssText=this.style;if(k.style.fontSize){this.mathsize=k.style.fontSize;k.style.fontSize=""}this.styles={border:d.getBorders(k),padding:d.getPadding(k)};if(this.styles.border){k.style.border=""}if(this.styles.padding){k.style.padding=""}}if(this.href){k.parentNode.bbox=k.bbox}this.HTMLaddAttributes(k);return k},HTMLaddAttributes:function(n){if(this.attrNames){var s=this.attrNames,o=g.nocopyAttributes,r=b.config.ignoreMMLattributes;var p=(this.type==="mstyle"?g.math.prototype.defaults:this.defaults);for(var l=0,k=s.length;l<k;l++){var q=s[l];if(r[q]==false||(!o[q]&&!r[q]&&p[q]==null&&typeof(n[q])==="undefined")){n.setAttribute(q,this.attr[q])}}}},HTMLspanElement:function(){if(!this.spanID){return null}return document.getElementById((this.id||"MathJax-Span-"+this.spanID)+d.idPostfix)},HTMLhandleVariant:function(l,k,m){d.handleVariant(l,k,m)},HTMLhandleSize:function(k){if(!k.scale){k.scale=this.HTMLgetScale();if(k.scale!==1){k.style.fontSize=d.Percent(k.scale)}}return k},HTMLhandleDir:function(l){var k=this.Get("dir",true);if(k){l.dir=k}return l},HTMLhandleColor:function(w){var y=this.getValues("mathcolor","color");if(this.mathbackground){y.mathbackground=this.mathbackground}if(this.background){y.background=this.background}if(this.style&&w.style.backgroundColor){y.mathbackground=w.style.backgroundColor;w.style.backgroundColor="transparent"}var t=(this.styles||{}).border,v=(this.styles||{}).padding;if(y.color&&!this.mathcolor){y.mathcolor=y.color}if(y.background&&!this.mathbackground){y.mathbackground=y.background}if(y.mathcolor){w.style.color=y.mathcolor}if((y.mathbackground&&y.mathbackground!==g.COLOR.TRANSPARENT)||t||v){var A=w.bbox,z=(A.exact?0:1/d.em),u=0,s=0,m=w.style.paddingLeft,q=w.style.paddingRight;if(this.isToken){u=A.lw;s=A.rw-A.w}if(m!==""){u+=d.unEm(m)*(w.scale||1)}if(q!==""){s-=d.unEm(q)*(w.scale||1)}var l=(d.PaddingWidthBug||A.keepPadding||A.exactW?0:s-u);var o=Math.max(0,d.getW(w)+l);var x=A.h+A.d,k=-A.d,r=0,p=0;if(o>0){o+=2*z;u-=z}if(x>0){x+=2*z;k-=z}s=-o-u;if(t){s-=t.right;k-=t.bottom;r+=t.left;p+=t.right;A.h+=t.top;A.d+=t.bottom;A.w+=t.left+t.right;A.lw-=t.left;A.rw+=t.right}if(v){x+=v.top+v.bottom;o+=v.left+v.right;s-=v.right;k-=v.bottom;r+=v.left;p+=v.right;A.h+=v.top;A.d+=v.bottom;A.w+=v.left+v.right;A.lw-=v.left;A.rw+=v.right}if(p){w.style.paddingRight=d.Em(p)}var n=d.Element("span",{id:"MathJax-Color-"+this.spanID+d.idPostfix,isMathJax:true,style:{display:"inline-block",backgroundColor:y.mathbackground,width:d.Em(o),height:d.Em(x),verticalAlign:d.Em(k),marginLeft:d.Em(u),marginRight:d.Em(s)}});d.setBorders(n,t);if(A.width){n.style.width=A.width;n.style.marginRight="-"+A.width}if(d.msieInlineBlockAlignBug){n.style.position="relative";n.style.width=n.style.height=0;n.style.verticalAlign=n.style.marginLeft=n.style.marginRight="";n.style.border=n.style.padding="";if(t&&d.msieBorderWidthBug){x+=t.top+t.bottom;o+=t.left+t.right}n.style.width=d.Em(r+z);d.placeBox(d.addElement(n,"span",{noAdjust:true,isMathJax:true,style:{display:"inline-block",position:"absolute",overflow:"hidden",background:(y.mathbackground||"transparent"),width:d.Em(o),height:d.Em(x)}}),u,A.h+z);d.setBorders(n.firstChild,t)}w.parentNode.insertBefore(n,w);if(d.msieColorPositionBug){w.style.position="relative"}return n}return null},HTMLremoveColor:function(){var k=document.getElementById("MathJax-Color-"+this.spanID+d.idPostfix);if(k){k.parentNode.removeChild(k)}},HTMLhandleSpace:function(o){if(this.useMMLspacing){if(this.type!=="mo"){return}var m=this.getValues("scriptlevel","lspace","rspace");if(m.scriptlevel<=0||this.hasValue("lspace")||this.hasValue("rspace")){var l=this.HTMLgetMu(o);m.lspace=Math.max(0,d.length2em(m.lspace,l));m.rspace=Math.max(0,d.length2em(m.rspace,l));var k=this,n=this.Parent();while(n&&n.isEmbellished()&&n.Core()===k){k=n;n=n.Parent();o=k.HTMLspanElement()}if(m.lspace){o.style.paddingLeft=d.Em(m.lspace)}if(m.rspace){o.style.paddingRight=d.Em(m.rspace)}}}else{var p=this.texSpacing();if(p!==""){this.HTMLgetScale();p=d.length2em(p,this.scale)/(o.scale||1)*this.mscale;if(o.style.paddingLeft){p+=d.unEm(o.style.paddingLeft)}o.style.paddingLeft=d.Em(p)}}},HTMLgetScale:function(){if(this.scale){return this.scale*this.mscale}var m=1,k=this.getValues("scriptlevel","fontsize");k.mathsize=(this.isToken?this:this.Parent()).Get("mathsize");if(this.style){var l=this.HTMLspanElement();if(l.style.fontSize!=""){k.fontsize=l.style.fontSize}}if(k.fontsize&&!this.mathsize){k.mathsize=k.fontsize}if(k.scriptlevel!==0){if(k.scriptlevel>2){k.scriptlevel=2}m=Math.pow(this.Get("scriptsizemultiplier"),k.scriptlevel);k.scriptminsize=d.length2em(this.Get("scriptminsize"));if(m<k.scriptminsize){m=k.scriptminsize}}this.scale=m;this.mscale=d.length2em(k.mathsize);return m*this.mscale},HTMLgetMu:function(m){var k=1,l=this.getValues("scriptlevel","scriptsizemultiplier");if(m.scale&&m.scale!==1){k=1/m.scale}if(l.scriptlevel!==0){if(l.scriptlevel>2){l.scriptlevel=2}k=Math.sqrt(Math.pow(l.scriptsizemultiplier,l.scriptlevel))}return k},HTMLgetVariant:function(){var k=this.getValues("mathvariant","fontfamily","fontweight","fontstyle");k.hasVariant=this.Get("mathvariant",true);if(!k.hasVariant){k.family=k.fontfamily;k.weight=k.fontweight;k.style=k.fontstyle}if(this.style){var m=this.HTMLspanElement();if(!k.family&&m.style.fontFamily){k.family=m.style.fontFamily}if(!k.weight&&m.style.fontWeight){k.weight=m.style.fontWeight}if(!k.style&&m.style.fontStyle){k.style=m.style.fontStyle}}if(k.weight&&k.weight.match(/^\d+$/)){k.weight=(parseInt(k.weight)>600?"bold":"normal")}var l=k.mathvariant;if(this.variantForm){l="-"+d.fontInUse+"-variant"}if(k.family&&!k.hasVariant){if(!k.weight&&k.mathvariant.match(/bold/)){k.weight="bold"}if(!k.style&&k.mathvariant.match(/italic/)){k.style="italic"}return{FONTS:[],fonts:[],noRemap:true,defaultFont:{family:k.family,style:k.style,weight:k.weight}}}if(k.weight==="bold"){l={normal:g.VARIANT.BOLD,italic:g.VARIANT.BOLDITALIC,fraktur:g.VARIANT.BOLDFRAKTUR,script:g.VARIANT.BOLDSCRIPT,"sans-serif":g.VARIANT.BOLDSANSSERIF,"sans-serif-italic":g.VARIANT.SANSSERIFBOLDITALIC}[l]||l}else{if(k.weight==="normal"){l={bold:g.VARIANT.normal,"bold-italic":g.VARIANT.ITALIC,"bold-fraktur":g.VARIANT.FRAKTUR,"bold-script":g.VARIANT.SCRIPT,"bold-sans-serif":g.VARIANT.SANSSERIF,"sans-serif-bold-italic":g.VARIANT.SANSSERIFITALIC}[l]||l}}if(k.style==="italic"){l={normal:g.VARIANT.ITALIC,bold:g.VARIANT.BOLDITALIC,"sans-serif":g.VARIANT.SANSSERIFITALIC,"bold-sans-serif":g.VARIANT.SANSSERIFBOLDITALIC}[l]||l}else{if(k.style==="normal"){l={italic:g.VARIANT.NORMAL,"bold-italic":g.VARIANT.BOLD,"sans-serif-italic":g.VARIANT.SANSSERIF,"sans-serif-bold-italic":g.VARIANT.BOLDSANSSERIF}[l]||l}}if(!(l in d.FONTDATA.VARIANT)){l="normal"}return d.FONTDATA.VARIANT[l]},HTMLdrawBBox:function(k){var m=k.bbox;var l=d.Element("span",{style:{"font-size":k.style.fontSize,display:"inline-block",opacity:0.25,"margin-left":d.Em(-m.w)}},[["span",{style:{height:d.Em(m.h),width:d.Em(m.w),"background-color":"red",display:"inline-block"}}],["span",{style:{height:d.Em(m.d),width:d.Em(m.w),"margin-left":d.Em(-m.w),"vertical-align":d.Em(-m.d),"background-color":"green",display:"inline-block"}}]]);if(k.nextSibling){k.parentNode.insertBefore(l,k.nextSibling)}else{k.parentNode.appendChild(l)}}},{HTMLautoload:function(){var k=d.autoloadDir+"/"+this.type+".js";b.RestartAfter(h.Require(k))},HTMLautoloadFile:function(k){var l=d.autoloadDir+"/"+k+".js";b.RestartAfter(h.Require(l))},HTMLstretchH:function(l,k){this.HTMLremoveColor();return this.toHTML(l,k)},HTMLstretchV:function(l,k,m){this.HTMLremoveColor();return this.toHTML(l,k,m)}});g.chars.Augment({toHTML:function(n,m,l,o){var r=this.data.join("").replace(/[\u2061-\u2064]/g,"");if(l){r=l(r,o)}if(m.fontInherit){var q=Math.floor(d.config.scale/d.scale+0.5)+"%";d.addElement(n,"span",{style:{"font-size":q}},[r]);if(m.bold){n.lastChild.style.fontWeight="bold"}if(m.italic){n.lastChild.style.fontStyle="italic"}n.bbox=null;var p=d.getHD(n),k=d.getW(n);n.bbox={h:p.h,d:p.d,w:k,lw:0,rw:k,exactW:true}}else{this.HTMLhandleVariant(n,m,r)}}});g.entity.Augment({toHTML:function(n,m,l,o){var r=this.toString().replace(/[\u2061-\u2064]/g,"");if(l){r=l(r,o)}if(m.fontInherit){var q=Math.floor(d.config.scale/d.scale+0.5)+"%";d.addElement(n,"span",{style:{"font-size":q}},[r]);if(m.bold){n.lastChild.style.fontWeight="bold"}if(m.italic){n.lastChild.style.fontStyle="italic"}delete n.bbox;var p=d.getHD(n),k=d.getW(n);n.bbox={h:p.h,d:p.d,w:k,lw:0,rw:k,exactW:true}}else{this.HTMLhandleVariant(n,m,r)}}});g.mi.Augment({toHTML:function(o){o=this.HTMLhandleSize(this.HTMLcreateSpan(o));o.bbox=null;var n=this.HTMLgetVariant();for(var l=0,k=this.data.length;l<k;l++){if(this.data[l]){this.data[l].toHTML(o,n)}}if(!o.bbox){o.bbox=this.HTMLzeroBBox()}var q=this.data.join(""),p=o.bbox;if(p.skew&&q.length!==1){delete p.skew}if(p.rw>p.w&&q.length===1&&!n.noIC){p.ic=p.rw-p.w;d.createBlank(o,p.ic/this.mscale);p.w=p.rw}this.HTMLhandleSpace(o);this.HTMLhandleColor(o);this.HTMLhandleDir(o);return o}});g.mn.Augment({toHTML:function(o){o=this.HTMLhandleSize(this.HTMLcreateSpan(o));o.bbox=null;var n=this.HTMLgetVariant();for(var l=0,k=this.data.length;l<k;l++){if(this.data[l]){this.data[l].toHTML(o,n)}}if(!o.bbox){o.bbox=this.HTMLzeroBBox()}if(this.data.join("").length!==1){delete o.bbox.skew}this.HTMLhandleSpace(o);this.HTMLhandleColor(o);this.HTMLhandleDir(o);return o}});g.mo.Augment({toHTML:function(v){v=this.HTMLhandleSize(this.HTMLcreateSpan(v));if(this.data.length==0){return v}else{v.bbox=null}var y=this.data.join("");var q=this.HTMLgetVariant();var x=this.getValues("largeop","displaystyle");if(x.largeop){q=d.FONTDATA.VARIANT[x.displaystyle?"-largeOp":"-smallOp"]}var w=this.CoreParent(),o=(w&&w.isa(g.msubsup)&&this!==w.data[w.base]),l=(o?this.remapChars:null);if(y.length===1&&w&&w.isa(g.munderover)&&this.CoreText(w.data[w.base]).length===1){var s=w.data[w.over],u=w.data[w.under];if(s&&this===s.CoreMO()&&w.Get("accent")){l=d.FONTDATA.REMAPACCENT}else{if(u&&this===u.CoreMO()&&w.Get("accentunder")){l=d.FONTDATA.REMAPACCENTUNDER}}}if(o&&y.match(/['`"\u00B4\u2032-\u2037\u2057]/)){q=d.FONTDATA.VARIANT["-"+d.fontInUse+"-variant"]}for(var r=0,n=this.data.length;r<n;r++){if(this.data[r]){this.data[r].toHTML(v,q,this.remap,l)}}if(!v.bbox){v.bbox=this.HTMLzeroBBox()}if(y.length!==1){delete v.bbox.skew}if(d.AccentBug&&v.bbox.w===0&&y.length===1&&v.firstChild){v.firstChild.nodeValue+=d.NBSP;d.createSpace(v,0,0,-v.offsetWidth/d.em)}if(x.largeop){var t=d.TeX.axis_height*this.scale*this.mscale;var k=(v.bbox.h-v.bbox.d)/2-t;if(d.safariVerticalAlignBug&&v.lastChild.nodeName==="IMG"){v.lastChild.style.verticalAlign=d.Em(d.unEm(v.lastChild.style.verticalAlign||0)/d.em-k/v.scale)}else{if(d.konquerorVerticalAlignBug&&v.lastChild.nodeName==="IMG"){v.style.position="relative";v.lastChild.style.position="relative";v.lastChild.style.top=d.Em(k/v.scale)}else{v.style.verticalAlign=d.Em(-k/v.scale)}}v.bbox.h-=k;v.bbox.d+=k;if(v.bbox.rw>v.bbox.w){v.bbox.ic=v.bbox.rw-v.bbox.w;d.createBlank(v,v.bbox.ic/this.mscale);v.bbox.w=v.bbox.rw}}this.HTMLhandleSpace(v);this.HTMLhandleColor(v);this.HTMLhandleDir(v);return v},HTMLcanStretch:function(o){if(!this.Get("stretchy")){return false}var p=this.data.join("");if(p.length>1){return false}var m=this.CoreParent();if(m&&m.isa(g.munderover)&&this.CoreText(m.data[m.base]).length===1){var n=m.data[m.over],l=m.data[m.under];if(n&&this===n.CoreMO()&&m.Get("accent")){p=d.FONTDATA.REMAPACCENT[p]||p}else{if(l&&this===l.CoreMO()&&m.Get("accentunder")){p=d.FONTDATA.REMAPACCENTUNDER[p]||p}}}p=d.FONTDATA.DELIMITERS[p.charCodeAt(0)];var k=(p&&p.dir===o.substr(0,1));this.forceStretch=(k&&(this.Get("minsize",true)||this.Get("maxsize",true)));return k},HTMLstretchV:function(m,n,o){this.HTMLremoveColor();var r=this.getValues("symmetric","maxsize","minsize");var p=this.HTMLspanElement(),s=this.HTMLgetMu(p),q;var l=this.HTMLgetScale(),k=d.TeX.axis_height*l;if(r.symmetric){q=2*Math.max(n-k,o+k)}else{q=n+o}r.maxsize=d.length2em(r.maxsize,s,p.bbox.h+p.bbox.d);r.minsize=d.length2em(r.minsize,s,p.bbox.h+p.bbox.d);q=Math.max(r.minsize,Math.min(r.maxsize,q));if(q!=r.minsize){q=[Math.max(q*d.TeX.delimiterfactor/1000,q-d.TeX.delimitershortfall),q]}p=this.HTMLcreateSpan(m);d.createDelimiter(p,this.data.join("").charCodeAt(0),q,l);if(r.symmetric){q=(p.bbox.h+p.bbox.d)/2+k}else{q=(p.bbox.h+p.bbox.d)*n/(n+o)}d.positionDelimiter(p,q);this.HTMLhandleSpace(p);this.HTMLhandleColor(p);return p},HTMLstretchH:function(o,k){this.HTMLremoveColor();var m=this.getValues("maxsize","minsize","mathvariant","fontweight");if((m.fontweight==="bold"||parseInt(m.fontweight)>=600)&&!this.Get("mathvariant",true)){m.mathvariant=g.VARIANT.BOLD}var n=this.HTMLspanElement(),l=this.HTMLgetMu(n),p=n.scale;m.maxsize=d.length2em(m.maxsize,l,n.bbox.w);m.minsize=d.length2em(m.minsize,l,n.bbox.w);k=Math.max(m.minsize,Math.min(m.maxsize,k));n=this.HTMLcreateSpan(o);d.createDelimiter(n,this.data.join("").charCodeAt(0),k,p,m.mathvariant);this.HTMLhandleSpace(n);this.HTMLhandleColor(n);return n}});g.mtext.Augment({toHTML:function(o){o=this.HTMLhandleSize(this.HTMLcreateSpan(o));var n=this.HTMLgetVariant();if(d.config.mtextFontInherit||this.Parent().type==="merror"){var p=this.Get("mathvariant");if(p==="monospace"){o.className+=" MJX-monospace"}else{if(p.match(/sans-serif/)){o.className+=" MJX-sans-serif"}}n={bold:n.bold,italic:n.italic,fontInherit:true}}for(var l=0,k=this.data.length;l<k;l++){if(this.data[l]){this.data[l].toHTML(o,n)}}if(!o.bbox){o.bbox=this.HTMLzeroBBox()}if(this.data.join("").length!==1){delete o.bbox.skew}this.HTMLhandleSpace(o);this.HTMLhandleColor(o);this.HTMLhandleDir(o);return o}});g.merror.Augment({toHTML:function(l){var n=MathJax.HTML.addElement(l,"span",{style:{display:"inline-block"}});l=this.SUPER(arguments).toHTML.call(this,n);var m=d.getHD(n),k=d.getW(n);n.bbox={h:m.h,d:m.d,w:k,lw:0,rw:k,exactW:true};n.id=l.id;l.id=null;return n}});g.ms.Augment({toHTML:g.mbase.HTMLautoload});g.mglyph.Augment({toHTML:g.mbase.HTMLautoload});g.mspace.Augment({toHTML:function(o){o=this.HTMLcreateSpan(o);var m=this.getValues("height","depth","width");var l=this.HTMLgetMu(o);this.HTMLgetScale();m.mathbackground=this.mathbackground;if(this.background&&!this.mathbackground){m.mathbackground=this.background}var n=d.length2em(m.height,l)*this.mscale,p=d.length2em(m.depth,l)*this.mscale,k=d.length2em(m.width,l)*this.mscale;d.createSpace(o,n,p,k,m.mathbackground,true);return o}});g.mphantom.Augment({toHTML:function(o,l,q){o=this.HTMLcreateSpan(o);if(this.data[0]!=null){var p=this.data[0].toHTML(o);if(q!=null){d.Remeasured(this.data[0].HTMLstretchV(o,l,q),o)}else{if(l!=null){d.Remeasured(this.data[0].HTMLstretchH(o,l),o)}else{p=d.Measured(p,o)}}o.bbox={w:p.bbox.w,h:p.bbox.h,d:p.bbox.d,lw:0,rw:0,exactW:true};for(var n=0,k=o.childNodes.length;n<k;n++){o.childNodes[n].style.visibility="hidden"}}this.HTMLhandleSpace(o);this.HTMLhandleColor(o);return o},HTMLstretchH:g.mbase.HTMLstretchH,HTMLstretchV:g.mbase.HTMLstretchV});g.mpadded.Augment({toHTML:function(s,m,k){s=this.HTMLcreateSpan(s);if(this.data[0]!=null){var q=d.createStack(s,true);var n=d.createBox(q);var l=this.data[0].toHTML(n);if(k!=null){d.Remeasured(this.data[0].HTMLstretchV(n,m,k),n)}else{if(m!=null){d.Remeasured(this.data[0].HTMLstretchH(n,m),n)}else{d.Measured(l,n)}}var t=this.getValues("height","depth","width","lspace","voffset"),r=0,p=0,u=this.HTMLgetMu(s);this.HTMLgetScale();if(t.lspace){r=this.HTMLlength2em(n,t.lspace,u)}if(t.voffset){p=this.HTMLlength2em(n,t.voffset,u)}d.placeBox(n,r,p);r/=this.mscale;p/=this.mscale;s.bbox={h:n.bbox.h,d:n.bbox.d,w:n.bbox.w,exactW:true,lw:n.bbox.lw+r,rw:n.bbox.rw+r,H:Math.max((n.bbox.H==null?-d.BIGDIMEN:n.bbox.H+p),n.bbox.h+p),D:Math.max((n.bbox.D==null?-d.BIGDIMEN:n.bbox.D-p),n.bbox.d-p)};if(t.height!==""){s.bbox.h=this.HTMLlength2em(n,t.height,u,"h",0)}if(t.depth!==""){s.bbox.d=this.HTMLlength2em(n,t.depth,u,"d",0)}if(t.width!==""){s.bbox.w=this.HTMLlength2em(n,t.width,u,"w",0)}if(s.bbox.H<=s.bbox.h){delete s.bbox.H}if(s.bbox.D<=s.bbox.d){delete s.bbox.D}var o=/^\s*(\d+(\.\d*)?|\.\d+)\s*(pt|em|ex|mu|px|pc|in|mm|cm)\s*$/;s.bbox.exact=!!((this.data[0]&&this.data[0].data.length==0)||o.exec(t.height)||o.exec(t.width)||o.exec(t.depth));d.setStackWidth(q,s.bbox.w)}this.HTMLhandleSpace(s);this.HTMLhandleColor(s);return s},HTMLlength2em:function(q,r,l,s,k){if(k==null){k=-d.BIGDIMEN}var o=String(r).match(/width|height|depth/);var p=(o?q.bbox[o[0].charAt(0)]:(s?q.bbox[s]:0));var n=d.length2em(r,l,p/this.mscale)*this.mscale;if(s&&String(r).match(/^\s*[-+]/)){return Math.max(k,q.bbox[s]+n)}else{return n}},HTMLstretchH:g.mbase.HTMLstretchH,HTMLstretchV:g.mbase.HTMLstretchV});g.mrow.Augment({HTMLlineBreaks:function(k){if(!this.parent.linebreakContainer){return false}return(d.config.linebreaks.automatic&&k.bbox.w>d.linebreakWidth)||this.hasNewline()},HTMLstretchH:function(m,k){this.HTMLremoveColor();var l=this.HTMLspanElement();this.data[this.core].HTMLstretchH(l,k);this.HTMLcomputeBBox(l,true);this.HTMLhandleColor(l);return l},HTMLstretchV:function(m,l,n){this.HTMLremoveColor();var k=this.HTMLspanElement();this.data[this.core].HTMLstretchV(k,l,n);this.HTMLcomputeBBox(k,true);this.HTMLhandleColor(k);return k}});g.mstyle.Augment({toHTML:function(l,k,m){l=this.HTMLcreateSpan(l);if(this.data[0]!=null){var n=this.data[0].toHTML(l);if(m!=null){this.data[0].HTMLstretchV(l,k,m)}else{if(k!=null){this.data[0].HTMLstretchH(l,k)}}l.bbox=n.bbox}this.HTMLhandleSpace(l);this.HTMLhandleColor(l);return l},HTMLstretchH:g.mbase.HTMLstretchH,HTMLstretchV:g.mbase.HTMLstretchV});g.mfrac.Augment({toHTML:function(D){D=this.HTMLcreateSpan(D);var m=d.createStack(D);var r=d.createBox(m),o=d.createBox(m);d.MeasureSpans([this.HTMLboxChild(0,r),this.HTMLboxChild(1,o)]);var k=this.getValues("displaystyle","linethickness","numalign","denomalign","bevelled");var I=this.HTMLgetScale(),C=k.displaystyle;var G=d.TeX.axis_height*I;if(k.bevelled){var F=(C?0.4:0.15);var s=Math.max(r.bbox.h+r.bbox.d,o.bbox.h+o.bbox.d)+2*F;var E=d.createBox(m);d.createDelimiter(E,47,s);d.placeBox(r,0,(r.bbox.d-r.bbox.h)/2+G+F);d.placeBox(E,r.bbox.w-F/2,(E.bbox.d-E.bbox.h)/2+G);d.placeBox(o,r.bbox.w+E.bbox.w-F,(o.bbox.d-o.bbox.h)/2+G-F)}else{var l=Math.max(r.bbox.w,o.bbox.w);var y=d.thickness2em(k.linethickness,this.scale)*this.mscale,A,z,x,w;var B=d.TeX.min_rule_thickness/this.em;if(C){x=d.TeX.num1;w=d.TeX.denom1}else{x=(y===0?d.TeX.num3:d.TeX.num2);w=d.TeX.denom2}x*=I;w*=I;if(y===0){A=Math.max((C?7:3)*d.TeX.rule_thickness,2*B);z=(x-r.bbox.d)-(o.bbox.h-w);if(z<A){x+=(A-z)/2;w+=(A-z)/2}}else{A=Math.max((C?2:0)*B+y,y/2+1.5*B);z=(x-r.bbox.d)-(G+y/2);if(z<A){x+=A-z}z=(G-y/2)-(o.bbox.h-w);if(z<A){w+=A-z}var n=d.createBox(m);d.createRule(n,y,0,l+2*y);d.placeBox(n,0,G-y/2)}d.alignBox(r,k.numalign,x);d.alignBox(o,k.denomalign,-w)}this.HTMLhandleSpace(D);this.HTMLhandleColor(D);return D},HTMLcanStretch:function(k){return false},HTMLhandleSpace:function(l){if(!this.texWithDelims&&!this.useMMLspacing){var m=d.TeX.nulldelimiterspace*this.mscale;var k=l.childNodes[d.msiePaddingWidthBug?1:0].style;k.marginLeft=k.marginRight=d.Em(m);l.bbox.w+=2*m;l.bbox.rw+=2*m}this.SUPER(arguments).HTMLhandleSpace.call(this,l)}});g.msqrt.Augment({toHTML:function(w){w=this.HTMLcreateSpan(w);var z=d.createStack(w);var n=d.createBox(z),u=d.createBox(z),s=d.createBox(z);var r=this.HTMLgetScale();var A=d.TeX.rule_thickness*r,m,l,y,o;if(this.Get("displaystyle")){m=d.TeX.x_height*r}else{m=A}l=Math.max(A+m/4,1.5*d.TeX.min_rule_thickness/this.em);var k=this.HTMLboxChild(0,n);y=k.bbox.h+k.bbox.d+l+A;d.createDelimiter(s,8730,y,r);d.MeasureSpans([k,s]);o=k.bbox.w;var v=0;if(s.isMultiChar||(d.AdjustSurd&&d.imgFonts)){s.bbox.w*=0.95}if(s.bbox.h+s.bbox.d>y){l=((s.bbox.h+s.bbox.d)-(y-A))/2}var B=d.FONTDATA.DELIMITERS[d.FONTDATA.RULECHAR];if(!B||o<B.HW[0][0]*r||r<0.75){d.createRule(u,0,A,o)}else{d.createDelimiter(u,d.FONTDATA.RULECHAR,o,r)}y=k.bbox.h+l+A;l=y*d.rfuzz;if(s.isMultiChar){l=d.rfuzz}v=this.HTMLaddRoot(z,s,v,s.bbox.h+s.bbox.d-y,r);d.placeBox(s,v,y-s.bbox.h);d.placeBox(u,v+s.bbox.w,y-u.bbox.h+l);d.placeBox(n,v+s.bbox.w,0);this.HTMLhandleSpace(w);this.HTMLhandleColor(w);return w},HTMLaddRoot:function(m,l,k,o,n){return k}});g.mroot.Augment({toHTML:g.msqrt.prototype.toHTML,HTMLaddRoot:function(s,l,q,o,k){var m=d.createBox(s);if(this.data[1]){var p=this.data[1].toHTML(m);p.style.paddingRight=p.style.paddingLeft="";d.Measured(p,m)}else{m.bbox=this.HTMLzeroBBox()}var n=this.HTMLrootHeight(l.bbox.h+l.bbox.d,k,m)-o;var r=Math.min(m.bbox.w,m.bbox.rw);q=Math.max(r,l.offset);d.placeBox(m,q-r,n);return q-l.offset},HTMLrootHeight:function(m,l,k){return 0.45*(m-0.9*l)+0.6*l+Math.max(0,k.bbox.d-0.075)}});g.mfenced.Augment({toHTML:function(o){o=this.HTMLcreateSpan(o);if(this.data.open){this.data.open.toHTML(o)}if(this.data[0]!=null){this.data[0].toHTML(o)}for(var l=1,k=this.data.length;l<k;l++){if(this.data[l]){if(this.data["sep"+l]){this.data["sep"+l].toHTML(o)}this.data[l].toHTML(o)}}if(this.data.close){this.data.close.toHTML(o)}var q=this.HTMLcomputeBBox(o);var n=o.bbox.h,p=o.bbox.d;for(l=0,k=q.length;l<k;l++){q[l].HTMLstretchV(o,n,p)}if(q.length){this.HTMLcomputeBBox(o,true)}this.HTMLhandleSpace(o);this.HTMLhandleColor(o);return o},HTMLcomputeBBox:function(p,o){var l=p.bbox={},q=[];this.HTMLcheckStretchy(this.data.open,l,q,o);this.HTMLcheckStretchy(this.data[0],l,q,o);for(var n=1,k=this.data.length;n<k;n++){if(this.data[n]){this.HTMLcheckStretchy(this.data["sep"+n],l,q,o);this.HTMLcheckStretchy(this.data[n],l,q,o)}}this.HTMLcheckStretchy(this.data.close,l,q,o);this.HTMLcleanBBox(l);return q},HTMLcheckStretchy:function(k,l,n,m){if(k){if(!m&&k.HTMLcanStretch("Vertical")){n.push(k);k=(k.CoreMO()||k)}this.HTMLcombineBBoxes(k,l)}}});g.menclose.Augment({toHTML:g.mbase.HTMLautoload});g.maction.Augment({toHTML:g.mbase.HTMLautoload});g.semantics.Augment({toHTML:function(l,k,m){l=this.HTMLcreateSpan(l);if(this.data[0]!=null){var n=this.data[0].toHTML(l);if(m!=null){this.data[0].HTMLstretchV(l,k,m)}else{if(k!=null){this.data[0].HTMLstretchH(l,k)}}l.bbox=n.bbox}this.HTMLhandleSpace(l);return l},HTMLstretchH:g.mbase.HTMLstretchH,HTMLstretchV:g.mbase.HTMLstretchV});g.munderover.Augment({toHTML:function(L,H,F){var l=this.getValues("displaystyle","accent","accentunder","align");var p=this.data[this.base];if(!l.displaystyle&&p!=null&&(p.movablelimits||p.CoreMO().Get("movablelimits"))){return g.msubsup.prototype.toHTML.call(this,L)}L=this.HTMLcreateSpan(L);var P=this.HTMLgetScale();var q=d.createStack(L);var r=[],o=[],N=[],w,M,I;for(M=0,I=this.data.length;M<I;M++){if(this.data[M]!=null){w=r[M]=d.createBox(q);o[M]=this.data[M].toHTML(w);if(M==this.base){if(F!=null){this.data[this.base].HTMLstretchV(w,H,F)}else{if(H!=null){this.data[this.base].HTMLstretchH(w,H)}}N[M]=(F==null&&H!=null?false:this.data[M].HTMLcanStretch("Horizontal"))}else{N[M]=this.data[M].HTMLcanStretch("Horizontal");o[M].style.paddingLeft=o[M].style.paddingRight=""}}}d.MeasureSpans(o);var n=-d.BIGDIMEN,K=n;for(M=0,I=this.data.length;M<I;M++){if(this.data[M]){if(r[M].bbox.w>K){K=r[M].bbox.w}if(!N[M]&&K>n){n=K}}}if(F==null&&H!=null){n=H}else{if(n==-d.BIGDIMEN){n=K}}for(M=K=0,I=this.data.length;M<I;M++){if(this.data[M]){w=r[M];if(N[M]){w.bbox=this.data[M].HTMLstretchH(w,n).bbox;if(M!==this.base){o[M].style.paddingLeft=o[M].style.paddingRight=""}}if(w.bbox.w>K){K=w.bbox.w}}}var E=d.TeX.rule_thickness*this.mscale,G=d.FONTDATA.TeX_factor;var v,s,A,z,u,C,J,O=0;p=r[this.base]||{bbox:this.HTMLzeroBBox()};if(p.bbox.ic){O=1.3*p.bbox.ic+0.05}for(M=0,I=this.data.length;M<I;M++){if(this.data[M]!=null){w=r[M];u=d.TeX.big_op_spacing5*P;var B=(M!=this.base&&l[this.ACCENTS[M]]);if(B&&w.bbox.w<=1/d.em+0.0001){w.bbox.w=w.bbox.rw-w.bbox.lw;w.bbox.noclip=true;if(w.bbox.lw){w.insertBefore(d.createSpace(w.parentNode,0,0,-w.bbox.lw),w.firstChild)}d.createBlank(w,0,0,w.bbox.rw+0.1)}C={left:0,center:(K-w.bbox.w)/2,right:K-w.bbox.w}[l.align];v=C;s=0;if(M==this.over){if(B){J=Math.max(E*P*G,2.5/this.em);u=0;if(p.bbox.skew){v+=p.bbox.skew;L.bbox.skew=p.bbox.skew;if(v+w.bbox.w>K){L.bbox.skew+=(K-w.bbox.w-v)/2}}}else{A=d.TeX.big_op_spacing1*P*G;z=d.TeX.big_op_spacing3*P*G;J=Math.max(A,z-Math.max(0,w.bbox.d))}J=Math.max(J,1.5/this.em);v+=O/2;s=p.bbox.h+w.bbox.d+J;w.bbox.h+=u}else{if(M==this.under){if(B){J=3*E*P*G;u=0}else{A=d.TeX.big_op_spacing2*P*G;z=d.TeX.big_op_spacing4*P*G;J=Math.max(A,z-w.bbox.h)}J=Math.max(J,1.5/this.em);v-=O/2;s=-(p.bbox.d+w.bbox.h+J);w.bbox.d+=u}}d.placeBox(w,v,s)}}this.HTMLhandleSpace(L);this.HTMLhandleColor(L);return L},HTMLstretchH:g.mbase.HTMLstretchH,HTMLstretchV:g.mbase.HTMLstretchV});g.msubsup.Augment({toHTML:function(K,I,C){K=this.HTMLcreateSpan(K);var N=this.HTMLgetScale(),H=this.HTMLgetMu(K);var w=d.createStack(K),l,n=[];var o=d.createBox(w);if(this.data[this.base]){n.push(this.data[this.base].toHTML(o));if(C!=null){this.data[this.base].HTMLstretchV(o,I,C)}else{if(I!=null){this.data[this.base].HTMLstretchH(o,I)}}}else{o.bbox=this.HTMLzeroBBox()}var L=d.TeX.x_height*N,B=d.TeX.scriptspace*N*0.75;var k,x;if(this.HTMLnotEmpty(this.data[this.sup])){k=d.createBox(w);n.push(this.data[this.sup].toHTML(k))}if(this.HTMLnotEmpty(this.data[this.sub])){x=d.createBox(w);n.push(this.data[this.sub].toHTML(x))}d.MeasureSpans(n);if(k){k.bbox.w+=B;k.bbox.rw=Math.max(k.bbox.w,k.bbox.rw)}if(x){x.bbox.w+=B;x.bbox.rw=Math.max(x.bbox.w,x.bbox.rw)}d.placeBox(o,0,0);var m=N;if(k){m=this.data[this.sup].HTMLgetScale()}else{if(x){m=this.data[this.sub].HTMLgetScale()}}var F=d.TeX.sup_drop*m,E=d.TeX.sub_drop*m;var z=o.bbox.h-F,y=o.bbox.d+E,M=0,G;if(o.bbox.ic){o.bbox.w-=o.bbox.ic;M=1.3*o.bbox.ic+0.05}if(this.data[this.base]&&I==null&&C==null&&(this.data[this.base].type==="mi"||this.data[this.base].type==="mo")){if(this.data[this.base].data.join("").length===1&&n[0].scale===1&&!this.data[this.base].Get("largeop")){z=y=0}}var J=this.getValues("subscriptshift","superscriptshift");J.subscriptshift=(J.subscriptshift===""?0:d.length2em(J.subscriptshift,H));J.superscriptshift=(J.superscriptshift===""?0:d.length2em(J.superscriptshift,H));if(!k){if(x){y=Math.max(y,d.TeX.sub1*N,x.bbox.h-(4/5)*L,J.subscriptshift);d.placeBox(x,o.bbox.w,-y,x.bbox)}}else{if(!x){l=this.getValues("displaystyle","texprimestyle");G=d.TeX[(l.displaystyle?"sup1":(l.texprimestyle?"sup3":"sup2"))];z=Math.max(z,G*N,k.bbox.d+(1/4)*L,J.superscriptshift);d.placeBox(k,o.bbox.w+M,z,k.bbox)}else{y=Math.max(y,d.TeX.sub2*N);var A=d.TeX.rule_thickness*N;if((z-k.bbox.d)-(x.bbox.h-y)<3*A){y=3*A-z+k.bbox.d+x.bbox.h;F=(4/5)*L-(z-k.bbox.d);if(F>0){z+=F;y-=F}}d.placeBox(k,o.bbox.w+M,Math.max(z,J.superscriptshift));d.placeBox(x,o.bbox.w,-Math.max(y,J.subscriptshift))}}this.HTMLhandleSpace(K);this.HTMLhandleColor(K);return K},HTMLstretchH:g.mbase.HTMLstretchH,HTMLstretchV:g.mbase.HTMLstretchV});g.mmultiscripts.Augment({toHTML:g.mbase.HTMLautoload});g.mtable.Augment({toHTML:g.mbase.HTMLautoload});g["annotation-xml"].Augment({toHTML:g.mbase.HTMLautoload});g.annotation.Augment({toHTML:function(k){return this.HTMLcreateSpan(k)}});g.math.Augment({toHTML:function(B,y,q){var r,t,u,n,k=B;if(!q||q===d.PHASE.I){var z=d.addElement(B,"nobr",{isMathJax:true});B=this.HTMLcreateSpan(z);var l=this.Get("alttext");if(l&&!B.getAttribute("aria-label")){B.setAttribute("aria-label",l)}if(!B.getAttribute("role")){B.setAttribute("role","math")}r=d.createStack(B);t=d.createBox(r);r.style.fontSize=z.parentNode.style.fontSize;z.parentNode.style.fontSize="";if(this.data[0]!=null){g.mbase.prototype.displayAlign=b.config.displayAlign;g.mbase.prototype.displayIndent=b.config.displayIndent;if(String(b.config.displayIndent).match(/^0($|[a-z%])/i)){g.mbase.prototype.displayIndent="0"}u=this.data[0].toHTML(t);u.bbox.exactW=false}}else{B=B.firstChild.firstChild;if(this.href){B=B.firstChild}r=B.firstChild;if(r.style.position!=="relative"){r=r.nextSibling}t=r.firstChild;u=t.firstChild}n=((!q||q===d.PHASE.II)?d.Measured(u,t):u);if(!q||q===d.PHASE.III){d.placeBox(t,0,0);B.style.width=d.Em(Math.max(0,Math.round(n.bbox.w*this.em)+0.25)/d.outerEm);B.style.display="inline-block";var x=1/d.em,D=d.em/d.outerEm;d.em/=D;B.bbox.h*=D;B.bbox.d*=D;B.bbox.w*=D;B.bbox.lw*=D;B.bbox.rw*=D;if(B.bbox.H){B.bbox.H*=D}if(B.bbox.D){B.bbox.D*=D}if(n&&n.bbox.width!=null){B.style.minWidth=(n.bbox.minWidth||B.style.width);B.style.width=n.bbox.width;t.style.width=r.style.width=k.style.width="100%"}var A=this.HTMLhandleColor(B);if(n){d.createRule(B,(n.bbox.h+x)*D,(n.bbox.d+x)*D,0)}if(!this.isMultiline&&this.Get("display")==="block"&&B.bbox.width==null){var m=this.getValues("indentalignfirst","indentshiftfirst","indentalign","indentshift");if(m.indentalignfirst!==g.INDENTALIGN.INDENTALIGN){m.indentalign=m.indentalignfirst}if(m.indentalign===g.INDENTALIGN.AUTO){m.indentalign=this.displayAlign}if(m.indentshiftfirst!==g.INDENTSHIFT.INDENTSHIFT){m.indentshift=m.indentshiftfirst}if(m.indentshift==="auto"){m.indentshift="0"}var C=d.length2em(m.indentshift,1,d.scale*d.cwidth);if(this.displayIndent!=="0"){var v=d.length2em(this.displayIndent,1,d.scale*d.cwidth);C+=(m.indentalign===g.INDENTALIGN.RIGHT?-v:v)}y.style.textAlign=m.indentalign;if(C){b.Insert(B.style,({left:{marginLeft:d.Em(C)},right:{marginRight:d.Em(-C)},center:{marginLeft:d.Em(C),marginRight:d.Em(-C)}})[m.indentalign]);if(A){var s=parseFloat(A.style.marginLeft||"0")+C,o=parseFloat(A.style.marginRight||"0")-C;A.style.marginLeft=d.Em(s);A.style.marginRight=d.Em(o+(m.indentalign==="right"?B.bbox.w+C-B.bbox.w:0));if(d.msieColorBug&&m.indentalign==="right"){if(parseFloat(A.style.marginLeft)>0){var w=MathJax.HTML.addElement(A.parentNode,"span");w.style.marginLeft=d.Em(o+Math.min(0,B.bbox.w+C));A.nextSibling.style.marginRight="0em"}A.nextSibling.style.marginLeft="0em";A.style.marginRight=A.style.marginLeft="0em"}}}}}return B},HTMLspanElement:g.mbase.prototype.HTMLspanElement});g.TeXAtom.Augment({toHTML:function(o,m,q){o=this.HTMLcreateSpan(o);if(this.data[0]!=null){if(this.texClass===g.TEXCLASS.VCENTER){var k=d.createStack(o);var p=d.createBox(k);var r=this.data[0].toHTML(p);if(q!=null){d.Remeasured(this.data[0].HTMLstretchV(p,m,q),p)}else{if(m!=null){d.Remeasured(this.data[0].HTMLstretchH(p,m),p)}else{d.Measured(r,p)}}var l=d.TeX.axis_height*this.HTMLgetScale();d.placeBox(p,0,l-(p.bbox.h+p.bbox.d)/2+p.bbox.d)}else{var n=this.data[0].toHTML(o,m,q);if(q!=null){n=this.data[0].HTMLstretchV(p,m,q)}else{if(m!=null){n=this.data[0].HTMLstretchH(p,m)}}o.bbox=n.bbox}}this.HTMLhandleSpace(o);this.HTMLhandleColor(o);return o},HTMLstretchH:g.mbase.HTMLstretchH,HTMLstretchV:g.mbase.HTMLstretchV});b.Register.StartupHook("onLoad",function(){setTimeout(MathJax.Callback(["loadComplete",d,"jax.js"]),0)})});b.Register.StartupHook("End Config",function(){b.Browser.Select({MSIE:function(k){var o=(document.documentMode||0);var n=k.versionAtLeast("7.0");var m=k.versionAtLeast("8.0")&&o>7;var l=(document.compatMode==="BackCompat");if(o<9){d.config.styles[".MathJax .MathJax_HitBox"]["background-color"]="white";d.config.styles[".MathJax .MathJax_HitBox"].opacity=0;d.config.styles[".MathJax .MathJax_HitBox"].filter="alpha(opacity=0)"}d.Augment({PaddingWidthBug:true,msieAccentBug:true,msieColorBug:(o<8),msieColorPositionBug:true,msieRelativeWidthBug:l,msieDisappearingBug:(o>=8),msieMarginScaleBug:(o<8),msiePaddingWidthBug:true,msieBorderWidthBug:l,msieFrameSizeBug:(o<=8),msieInlineBlockAlignBug:(!m||l),msiePlaceBoxBug:(m&&!l),msieClipRectBug:!m,msieNegativeSpaceBug:l,msieRuleBug:(o<7),cloneNodeBug:(m&&k.version==="8.0"),msieItalicWidthBug:true,initialSkipBug:(o<8),msieNegativeBBoxBug:(o>=8),msieIE6:!n,msieItalicWidthBug:true,FontFaceBug:(o<9),msieFontCSSBug:k.isIE9,allowWebFonts:(o>=9?"woff":"eot")})},Firefox:function(l){var m=false;if(l.versionAtLeast("3.5")){var k=String(document.location).replace(/[^\/]*$/,"");if(document.location.protocol!=="file:"||b.config.root.match(/^https?:\/\//)||(b.config.root+"/").substr(0,k.length)===k){m="otf"}}d.Augment({ffVerticalAlignBug:!l.versionAtLeast("20.0"),AccentBug:true,allowWebFonts:m,ffFontOptimizationBug:true})},Safari:function(p){var n=p.versionAtLeast("3.0");var m=p.versionAtLeast("3.1");var k=navigator.appVersion.match(/ Safari\/\d/)&&navigator.appVersion.match(/ Version\/\d/)&&navigator.vendor.match(/Apple/);var l=(navigator.appVersion.match(/ Android (\d+)\.(\d+)/));var q=(m&&p.isMobile&&((navigator.platform.match(/iPad|iPod|iPhone/)&&!p.versionAtLeast("5.0"))||(l!=null&&(l[1]<2||(l[1]==2&&l[2]<2)))));d.Augment({config:{styles:{".MathJax img, .MathJax nobr, .MathJax a":{"max-width":"5000em","max-height":"5000em"}}},Em:((p.webkit||0)>=538?d.EmRounded:d.Em),rfuzz:0.011,AccentBug:true,AdjustSurd:true,negativeBBoxes:true,safariNegativeSpaceBug:true,safariVerticalAlignBug:!m,safariTextNodeBug:!n,forceReflow:true,FontFaceBug:true,allowWebFonts:(m&&!q?"otf":false)});if(k){d.Augment({webFontDefault:(p.isMobile?"sans-serif":"serif")})}if(p.isPC){d.Augment({adjustAvailableFonts:d.removeSTIXfonts,checkWebFontsTwice:true})}if(q){var o=b.config["HTML-CSS"];if(o){o.availableFonts=[];o.preferredFont=null}else{b.config["HTML-CSS"]={availableFonts:[],preferredFont:null}}}},Chrome:function(k){d.Augment({Em:d.EmRounded,cloneNodeBug:true,rfuzz:-0.02,AccentBug:true,AdjustSurd:true,FontFaceBug:k.versionAtLeast("32.0"),negativeBBoxes:true,safariNegativeSpaceBug:true,safariWebFontSerif:[""],forceReflow:true,allowWebFonts:(k.versionAtLeast("4.0")?"otf":"svg")})},Opera:function(k){k.isMini=(navigator.appVersion.match("Opera Mini")!=null);d.config.styles[".MathJax .merror"]["vertical-align"]=null;d.config.styles[".MathJax span"]["z-index"]=0;d.Augment({operaHeightBug:true,operaVerticalAlignBug:true,operaFontSizeBug:k.versionAtLeast("10.61"),initialSkipBug:true,FontFaceBug:true,PaddingWidthBug:true,allowWebFonts:(k.versionAtLeast("10.0")&&!k.isMini?"otf":false),adjustAvailableFonts:d.removeSTIXfonts})},Konqueror:function(k){d.Augment({konquerorVerticalAlignBug:true})}})});MathJax.Hub.Register.StartupHook("End Cookie",function(){if(b.config.menuSettings.zoom!=="None"){h.Require("[MathJax]/extensions/MathZoom.js")}})})(MathJax.Ajax,MathJax.Hub,MathJax.OutputJax["HTML-CSS"]);


/***/ },
/* 74 */
/***/ function(module, exports) {

	/*
	 *  /MathJax/jax/output/HTML-CSS/fonts/STIX/fontdata.js
	 *
	 *  Copyright (c) 2009-2015 The MathJax Consortium
	 *
	 *  Licensed under the Apache License, Version 2.0 (the "License");
	 *  you may not use this file except in compliance with the License.
	 *  You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 *  Unless required by applicable law or agreed to in writing, software
	 *  distributed under the License is distributed on an "AS IS" BASIS,
	 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *  See the License for the specific language governing permissions and
	 *  limitations under the License.
	 */

	(function(j,b,r){var s="2.6.0";j.allowWebFonts=false;var l="STIXGeneral",t="STIXGeneral-bold",p="STIXGeneral-italic",u="STIXGeneral-bold-italic",q="STIXNonUnicode",o="STIXNonUnicode-italic",i="STIXSizeOneSym",h="STIXSizeTwoSym",g="STIXSizeThreeSym",d="STIXSizeFourSym",c="STIXSizeFiveSym";var k="H",a="V",m={load:"extra",dir:k},f={load:"extra",dir:a};j.Augment({FONTDATA:{version:s,STIXversion:"1.1",TeX_factor:1.125,baselineskip:1.2,lineH:0.8,lineD:0.2,FONTS:{STIXGeneral:"General/Regular/Main.js","STIXGeneral-italic":"General/Italic/Main.js","STIXGeneral-bold":"General/Bold/Main.js","STIXGeneral-bold-italic":"General/BoldItalic/Main.js",STIXNonUnicode:"NonUnicode/Regular/Main.js","STIXNonUnicode-italic":"NonUnicode/Italic/Main.js","STIXNonUnicode-bold":"NonUnicode/Bold/Main.js","STIXNonUnicode-bold-italic":"NonUnicode/BoldItalic/Main.js",STIXVariants:"Variants/Regular/All.js",STIXSizeOneSym:"SizeOneSym/Regular/All.js",STIXSizeTwoSym:"SizeTwoSym/Regular/All.js",STIXSizeThreeSym:"SizeThreeSym/Regular/All.js",STIXSizeFourSym:"SizeFourSym/Regular/All.js",STIXSizeFiveSym:"SizeFiveSym/Regular/All.js",STIXIntegralsD:"IntegralsD/Regular/All.js"},VARIANT:{normal:{fonts:[l,q,i],remap:{8709:[8709,"-STIX-variant"]}},bold:{fonts:[t,"STIXNonUnicode-bold","STIXSizeOneSym-bold"],bold:true},italic:{fonts:[p,o,l,q,i],italic:true},"bold-italic":{fonts:[u,"STIXNonUnicode-bold-italic"],bold:true,italic:true},"double-struck":{offsetA:120120,offsetN:120792,remap:{120122:8450,120127:8461,120133:8469,120135:8473,120136:8474,120137:8477,120145:8484}},fraktur:{offsetA:120068,remap:{120070:8493,120075:8460,120076:8465,120085:8476,120093:8488}},"bold-fraktur":{fonts:[t],offsetA:120172,bold:true},script:{fonts:[p],offsetA:119964,italic:true,remap:{119965:8492,119968:8496,119969:8497,119971:8459,119972:8464,119975:8466,119976:8499,119981:8475,119994:8495,119996:8458,120004:8500}},"bold-script":{fonts:[u],offsetA:120016,bold:true,italic:true},"sans-serif":{offsetA:120224,offsetN:120802,offsetG:57725,offsetE:57725},"bold-sans-serif":{offsetA:120276,offsetG:120662,offsetN:120812,bold:true},"sans-serif-italic":{fonts:[p,o],offsetA:120328,offsetN:57780,offsetG:57791,offsetE:57791,italic:true},"sans-serif-bold-italic":{fonts:[u,"STIXNonUnicode-bold-italic"],offsetA:120380,offsetN:57846,offsetG:120720,bold:true,italic:true},monospace:{offsetA:120432,offsetN:120822,remap:{32:[32,"-STIX-variant"]}},"-STIX-variant":{fonts:["STIXVariants",q,l],remap:{10887:57360,10888:57359,8816:57361,8817:57358,8928:57419,8929:57423,8840:57366,8841:57368,9651:9653,9661:9663,8709:[8709,b.VARIANT.NORMAL]}},"-tex-caligraphic":{fonts:[p,o,q,i],offsetA:57901,noLowerCase:1},"-tex-oldstyle":{offsetN:57953,remap:{57954:57957,57955:57961,57956:57965,57957:57969,57958:57973,57959:57977,57960:57981,57961:57985,57962:57989}},"-tex-mathit":{fonts:[p,o,l,q,i],italic:true,noIC:true},"-largeOp":{fonts:[i,"STIXIntegralsD",q,l]},"-smallOp":{},"-tex-caligraphic-bold":{fonts:["STIXGeneral-bold-italic","STIXNonUnicode-bold-italic","STIXNonUnicode","STIXGeneral","STIXSizeOneSym"],bold:true,offsetA:57927,noLowerCase:1},"-tex-oldstyle-bold":{fonts:["STIXGeneral-bold","STIXNonUnicode-bold","STIXGeneral","STIXSizeOneSym"],bold:true,offsetN:57955,remap:{57956:57959,57957:57963,57958:57967,57959:57971,57960:57975,57961:57979,57962:57983,57963:57987,57964:57991}}},RANGES:[{name:"alpha",low:97,high:122,offset:"A",add:26},{name:"Alpha",low:65,high:90,offset:"A"},{name:"number",low:48,high:57,offset:"N"},{name:"greek-non-unicode",low:945,high:969,offset:"E",add:25},{name:"greek",low:945,high:969,offset:"G",add:26},{name:"Greek",low:913,high:1014,offset:"G",remap:{1013:53,977:54,1008:55,981:56,1009:57,982:58,1012:17}}],RULECHAR:8254,REMAP:{755:730,756:714,65079:9182,65080:9183,12296:10216,12297:10217,10072:8739},REMAPACCENT:{"\u007E":"\u0303","\u2192":"\u20D7","\u0060":"\u0300","\u005E":"\u0302","\u00B4":"\u0301","\u2032":"\u0301","\u2035":"\u0300"},REMAPACCENTUNDER:{},DELIMITERS:{40:{dir:a,HW:[[0.844,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],stretch:{top:[9115,i],ext:[9116,i],bot:[9117,i]}},41:{dir:a,HW:[[0.844,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],stretch:{top:[9118,i],ext:[9119,i],bot:[9120,i]}},47:{dir:a,HW:[[0.69,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]]},91:{dir:a,HW:[[0.818,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],stretch:{top:[9121,i],ext:[9122,i],bot:[9123,i]}},92:{dir:a,HW:[[0.69,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]]},93:{dir:a,HW:[[0.818,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],stretch:{top:[9124,i],ext:[9125,i],bot:[9126,i]}},123:{dir:a,HW:[[0.861,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],stretch:{top:[9127,i],mid:[9128,i],bot:[9129,i],ext:[9130,i]}},124:{dir:a,HW:[[0.69,l]],stretch:{ext:[8739,l]}},125:{dir:a,HW:[[0.861,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],stretch:{top:[9131,i],mid:[9132,i],bot:[9133,i],ext:[9130,i]}},710:{dir:k,HW:[[0.333,l],[0.56,i],[0.979,h],[1.46,g],[1.886,d],[2.328,c]]},711:{dir:k,HW:[[0.333,l],[0.56,i],[0.979,h],[1.46,g],[1.886,d],[2.328,c]]},732:{dir:k,HW:[[0.333,l],[0.558,i],[0.978,h],[1.458,g],[1.886,d],[2.328,c]]},8214:{dir:a,HW:[[0.879,l]],stretch:{ext:[8214,l]}},8254:{dir:k,HW:[[0.5,l]],stretch:{rep:[8254,l]}},8592:{dir:k,HW:[[0.926,l]],stretch:{left:[8592,l],rep:[8722,l]}},8593:{dir:a,HW:[[0.818,l]],stretch:{top:[8593,l],ext:[9168,l]}},8594:{dir:k,HW:[[0.926,l]],stretch:{rep:[8722,l],right:[8594,l]}},8595:{dir:a,HW:[[0.818,l]],stretch:{ext:[9168,l],bot:[8595,l]}},8596:{dir:k,HW:[[0.926,l]],stretch:{left:[8592,l],rep:[8722,l],right:[8594,l]}},8597:{dir:a,HW:[[0.818,l]],stretch:{top:[8593,l],ext:[9168,l],bot:[8595,l]}},8656:{dir:k,HW:[[0.926,l]],stretch:{left:[8656,l],rep:[61,l]}},8657:{dir:a,HW:[[0.818,l]],stretch:{top:[8657,l],ext:[8741,l,0.082]}},8658:{dir:k,HW:[[0.926,l]],stretch:{rep:[61,l],right:[8658,l]}},8659:{dir:a,HW:[[0.818,l]],stretch:{ext:[8741,l,0.082],bot:[8659,l]}},8660:{dir:k,HW:[[0.926,l]],stretch:{left:[8656,l],rep:[61,l],right:[8658,l]}},8661:{dir:a,HW:[[0.818,l]],stretch:{top:[8657,l],ext:[8741,l,0.082],bot:[8659,l]}},8730:{dir:a,HW:[[0.954,"STIXVariants"],[1.232,l],[1.847,i],[2.46,h],[3.075,g]],stretch:{top:[57345,q],ext:[57344,q],bot:[9143,i],fullExtenders:true}},8739:{dir:a,HW:[[0.879,l]],stretch:{ext:[8739,l]}},8741:{dir:a,HW:[[0.879,l]],stretch:{ext:[8741,l]}},8968:{dir:a,HW:[[0.926,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],stretch:{top:[9121,i],ext:[9122,i]}},8969:{dir:a,HW:[[0.926,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],streth:{top:[9124,i],ext:[9125,i]}},8970:{dir:a,HW:[[0.926,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],stretch:{ext:[9122,i],bot:[9123,i]}},8971:{dir:a,HW:[[0.926,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]],stretch:{ext:[9125,i],bot:[9126,i]}},9130:{dir:a,HW:[[1.01,i]],stretch:{top:[9130,i],ext:[9130,i],bot:[9130,i]}},9135:{dir:k,HW:[[0.315,l]],stretch:{rep:[9135,l]}},9136:{dir:a,HW:[[1,i]],stretch:{top:[9127,i],ext:[9130,i],bot:[9133,i]}},9137:{dir:a,HW:[[1,i]],stretch:{top:[9131,i],ext:[9130,i],bot:[9129,i]}},9168:{dir:a,HW:[[0.304,l],[0.69,l,null,124],[0.879,l,null,8739]],stretch:{ext:[8739,l]}},9182:{dir:k,HW:[[0.926,i],[1,l],[1.46,h],[1.886,g],[2.328,d],[3.238,c]],stretch:{left:[57659,q],mid:[57664,q],right:[57660,q],rep:[57674,q]}},9183:{dir:k,HW:[[0.926,i],[1,l],[1.46,h],[1.886,g],[2.328,d],[3.238,c]],stretch:{left:[57661,q],mid:[57665,q],right:[57662,q],rep:[57675,q]}},10216:{dir:a,HW:[[0.926,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]]},10217:{dir:a,HW:[[0.926,l],[1.23,i],[1.353,i,1.1],[1.845,h],[2.048,h,1.11],[2.46,g],[2.472,g,1.005],[3.075,d]]},10222:{dir:a,HW:[[0.853,l]],stretch:{top:[9127,i],ext:[9130,i],bot:[9129,i]}},10223:{dir:a,HW:[[0.853,l]],stretch:{top:[9131,i],ext:[9130,i],bot:[9133,i]}},45:{alias:9135,dir:k},94:{alias:710,dir:k},95:{alias:9135,dir:k},126:{alias:732,dir:k},175:{alias:9135,dir:k},713:{alias:9135,dir:k},770:{alias:710,dir:k},771:{alias:732,dir:k},780:{alias:711,dir:k},818:{alias:9135,dir:k},8213:{alias:9135,dir:k},8215:{alias:9135,dir:k},8722:{alias:9135,dir:k},8725:{alias:47,dir:a},9001:{alias:10216,dir:a},9002:{alias:10217,dir:a},9472:{alias:8722,dir:k},10072:{alias:8739,dir:a},12296:{alias:10216,dir:a},12297:{alias:10217,dir:a},65079:{alias:9182,dir:k},65080:{alias:9183,dir:k},61:m,8606:m,8608:m,8612:m,8613:f,8614:m,8615:f,8624:f,8625:f,8636:m,8637:m,8638:f,8639:f,8640:m,8641:m,8642:f,8643:f,8666:m,8667:m,9140:m,9141:m,9180:m,9181:m,9184:m,9185:m,10502:m,10503:m,10574:m,10575:f,10576:m,10577:f,10586:m,10587:m,10588:f,10589:f,10590:m,10591:m,10592:f,10593:f,8978:{alias:9180,dir:k},8994:{alias:9180,dir:k},8995:{alias:9181,dir:k},10229:{alias:8592,dir:k},10230:{alias:8594,dir:k},10231:{alias:8596,dir:k},10232:{alias:8656,dir:k},10233:{alias:8658,dir:k},10234:{alias:8660,dir:k},10235:{alias:8612,dir:k},10236:{alias:8614,dir:k},10237:{alias:10502,dir:k},10238:{alias:10503,dir:k},711:m,717:m,759:m,8607:f,8609:f,8616:f,8617:m,8618:m,8626:f,8627:f,8628:m,8629:f,8651:m,8652:m,8672:m,8673:f,8674:m,8675:f,8676:m,8677:m,8701:m,8702:m,8703:m,10214:f,10215:f,10218:f,10219:f,10506:f,10507:f,10514:f,10515:f,10578:m,10579:m,10580:f,10581:f,10582:m,10583:m,10584:f,10585:f,10624:f,10647:f,10648:f}}});j.FONTDATA.FONTS.STIXGeneral={directory:"General/Regular",family:"STIXGeneral",Ranges:[[160,255,"Latin1Supplement"],[256,383,"LatinExtendedA"],[384,591,"LatinExtendedB"],[592,687,"IPAExtensions"],[688,767,"SpacingModLetters"],[768,879,"CombDiacritMarks"],[880,1023,"GreekAndCoptic"],[1024,1279,"Cyrillic"],[7424,7615,"PhoneticExtensions"],[7680,7935,"LatinExtendedAdditional"],[8192,8303,"GeneralPunctuation"],[8304,8351,"SuperAndSubscripts"],[8352,8399,"CurrencySymbols"],[8400,8447,"CombDiactForSymbols"],[8448,8527,"LetterlikeSymbols"],[8528,8591,"NumberForms"],[8592,8703,"Arrows"],[8704,8959,"MathOperators"],[8960,9215,"MiscTechnical"],[9216,9279,"ControlPictures"],[9312,9471,"EnclosedAlphanum"],[9472,9599,"BoxDrawing"],[9600,9631,"BlockElements"],[9632,9727,"GeometricShapes"],[9728,9983,"MiscSymbols"],[9984,10175,"Dingbats"],[10176,10223,"MiscMathSymbolsA"],[10224,10239,"SupplementalArrowsA"],[10496,10623,"SupplementalArrowsB"],[10624,10751,"MiscMathSymbolsB"],[10752,11007,"SuppMathOperators"],[11008,11263,"MiscSymbolsAndArrows"],[12288,12351,"CJK"],[12352,12447,"Hiragana"],[42784,43007,"LatinExtendedD"],[64256,64335,"AlphaPresentForms"],[65520,65535,"Specials"],[119808,119859,"MathBold"],[119860,119911,"MathItalic"],[119912,119963,"MathBoldItalic"],[119964,120015,"MathScript"],[120016,120067,"MathBoldScript"],[120068,120119,"Fraktur"],[120120,120171,"BBBold"],[120172,120223,"BoldFraktur"],[120224,120275,"MathSS"],[120276,120327,"MathSSBold"],[120328,120379,"MathSSItalic"],[120380,120431,"MathSSItalicBold"],[120432,120483,"MathTT"],[120484,120485,"ij"],[120488,120545,"GreekBold"],[120546,120603,"GreekItalic"],[120604,120661,"GreekBoldItalic"],[120662,120719,"GreekSSBold"],[120720,120777,"GreekSSBoldItalic"],[120782,120791,"MathBold"],[120792,120801,"BBBold"],[120802,120811,"MathSS"],[120812,120822,"MathSSBold"],[120822,120831,"MathTT"]],32:[0,0,250,0,0],33:[676,9,333,130,236],34:[676,-431,408,77,331],35:[662,0,500,6,495],36:[727,87,500,44,458],37:[706,19,747,61,686],38:[676,13,778,42,750],39:[676,-431,180,48,133],40:[676,177,333,48,304],41:[676,177,333,29,285],42:[676,-265,500,68,433],43:[547,41,685,48,636],44:[102,141,250,55,195],45:[257,-194,333,39,285],46:[100,11,250,70,181],47:[676,14,278,-9,287],48:[676,14,500,24,476],49:[676,0,500,111,394],50:[676,0,500,29,474],51:[676,14,500,41,431],52:[676,0,500,12,473],53:[688,14,500,31,438],54:[684,14,500,34,468],55:[662,8,500,20,449],56:[676,14,500,56,445],57:[676,22,500,30,459],58:[459,11,278,81,192],59:[459,141,278,80,219],60:[534,24,685,56,621],61:[386,-120,685,48,637],62:[534,24,685,56,621],63:[676,8,444,68,414],64:[676,14,921,116,809],65:[674,0,722,15,707],66:[662,0,667,17,593],67:[676,14,667,28,633],68:[662,0,722,16,685],69:[662,0,611,12,597],70:[662,0,556,11,546],71:[676,14,722,32,709],72:[662,0,722,18,703],73:[662,0,333,18,315],74:[662,14,373,-6,354],75:[662,0,722,33,723],76:[662,0,611,12,598],77:[662,0,889,12,864],78:[662,11,722,12,707],79:[676,14,722,34,688],80:[662,0,557,16,542],81:[676,177,722,34,701],82:[662,0,667,17,660],83:[676,14,556,43,491],84:[662,0,611,17,593],85:[662,14,722,14,705],86:[662,11,722,16,697],87:[662,11,944,5,932],88:[662,0,722,10,704],89:[662,0,722,22,703],90:[662,0,612,10,598],91:[662,156,333,88,299],92:[676,14,278,-9,287],93:[662,156,333,34,245],94:[662,-297,469,24,446],95:[-75,125,500,0,500],96:[678,-507,333,18,242],97:[460,10,444,37,442],98:[683,10,500,3,468],99:[460,10,444,25,412],100:[683,10,500,27,491],101:[460,10,444,25,424],102:[683,0,333,20,383],103:[460,218,500,28,470],104:[683,0,500,9,487],105:[683,0,278,16,253],106:[683,218,278,-70,194],107:[683,0,500,7,505],108:[683,0,278,19,257],109:[460,0,778,16,775],110:[460,0,500,16,485],111:[460,10,500,29,470],112:[460,217,500,5,470],113:[460,217,500,24,488],114:[460,0,333,5,335],115:[459,10,389,51,348],116:[579,10,278,13,279],117:[450,10,500,9,480],118:[450,14,500,19,477],119:[450,14,722,21,694],120:[450,0,500,17,479],121:[450,218,500,14,475],122:[450,0,444,27,418],123:[680,181,480,100,350],124:[676,14,200,67,133],125:[680,181,480,130,380],126:[325,-183,541,40,502],160:[0,0,250,0,0],168:[622,-523,333,18,316],172:[393,-115,600,48,552],175:[601,-547,333,11,322],177:[502,87,685,48,637],183:[310,-199,250,70,181],215:[529,25,640,43,597],247:[516,10,564,30,534],305:[460,0,278,16,253],567:[460,218,278,-70,193],710:[674,-507,333,11,322],711:[674,-507,333,11,322],713:[601,-547,334,11,322],714:[679,-509,333,93,320],715:[679,-509,333,22,249],728:[664,-507,335,27,308],729:[622,-523,333,118,217],732:[638,-532,333,1,331],768:[678,-507,0,-371,-147],769:[678,-507,0,-371,-147],770:[674,-507,0,-386,-75],771:[638,-532,0,-395,-65],772:[601,-547,0,-385,-74],774:[664,-507,0,-373,-92],775:[622,-523,0,-280,-181],776:[622,-523,0,-379,-81],778:[711,-512,0,-329,-130],779:[678,-507,0,-401,-22],780:[674,-507,0,-385,-74],824:[662,156,0,-380,31],915:[662,0,587,11,577],916:[674,0,722,48,675],920:[676,14,722,34,688],923:[674,0,702,15,687],926:[662,0,643,29,614],928:[662,0,722,18,703],931:[662,0,624,30,600],933:[674,0,722,29,703],934:[662,0,763,35,728],936:[690,0,746,22,724],937:[676,0,744,29,715],8224:[676,149,500,59,442],8225:[676,153,500,58,442],8230:[100,11,1000,111,888],8242:[678,-402,289,75,214],8254:[820,-770,500,0,500],8407:[760,-548,0,-453,-17],8465:[695,34,762,45,711],8472:[547,217,826,52,799],8476:[704,22,874,50,829],8501:[677,13,682,43,634],8592:[449,-58,926,71,857],8593:[662,156,511,60,451],8594:[448,-57,926,70,856],8595:[662,156,511,60,451],8596:[449,-57,926,38,888],8597:[730,224,511,60,451],8598:[662,156,926,70,856],8599:[662,156,926,70,856],8600:[662,156,926,70,856],8601:[662,156,926,70,856],8614:[450,-57,926,70,857],8617:[553,-57,926,70,856],8618:[553,-57,926,70,856],8636:[494,-220,955,54,901],8637:[286,-12,955,54,901],8640:[494,-220,955,54,901],8641:[286,-12,955,54,901],8652:[539,33,926,70,856],8656:[551,45,926,60,866],8657:[662,156,685,45,641],8658:[551,45,926,60,866],8659:[662,156,685,45,641],8660:[517,10,926,20,906],8661:[730,224,685,45,641],8704:[662,0,560,2,558],8706:[668,11,471,40,471],8707:[662,0,560,73,487],8709:[583,79,762,50,712],8711:[662,12,731,63,667],8712:[531,27,685,60,625],8713:[662,157,685,60,625],8715:[531,27,685,60,625],8719:[763,259,1000,52,948],8720:[763,259,1000,52,948],8721:[763,259,914,58,856],8722:[286,-220,685,64,621],8723:[502,87,685,48,637],8725:[710,222,523,46,478],8726:[411,-93,428,25,403],8727:[471,-33,523,67,457],8728:[387,-117,350,40,310],8729:[387,-117,350,40,310],8730:[973,259,928,112,963],8733:[430,0,685,41,643],8734:[430,0,926,70,854],8736:[547,0,685,23,643],8739:[690,189,266,100,166],8741:[690,189,523,129,394],8743:[536,29,620,31,589],8744:[536,29,620,31,589],8745:[536,31,620,48,572],8746:[536,31,620,48,572],8747:[824,320,459,32,639],8764:[362,-148,685,48,637],8768:[547,42,286,35,249],8771:[445,-55,685,48,637],8773:[532,27,685,48,637],8776:[475,-25,685,48,637],8781:[498,-8,685,48,637],8784:[611,-120,685,48,637],8800:[662,156,685,48,637],8801:[478,-28,685,48,637],8804:[609,103,685,64,629],8805:[609,103,685,64,629],8810:[532,26,933,25,908],8811:[532,26,933,25,908],8826:[532,26,685,64,621],8827:[532,26,685,64,621],8828:[628,120,685,64,621],8829:[629,119,685,64,621],8834:[531,25,685,64,621],8835:[531,25,685,64,621],8838:[607,103,685,64,621],8839:[607,103,685,64,621],8846:[536,31,620,48,572],8849:[607,103,685,64,621],8850:[607,103,685,64,621],8851:[536,31,620,48,572],8852:[536,31,620,48,572],8853:[623,119,842,50,792],8854:[623,119,842,50,792],8855:[623,119,842,50,792],8856:[623,119,842,50,792],8857:[583,79,762,50,712],8866:[662,0,685,64,621],8867:[662,0,685,64,621],8868:[662,0,685,48,637],8869:[662,0,685,48,637],8872:[662,0,685,64,621],8896:[763,259,924,54,870],8897:[763,259,924,54,870],8898:[778,254,924,94,830],8899:[768,264,924,94,830],8900:[488,-16,523,26,497],8901:[313,-193,286,83,203],8902:[597,13,700,35,665],8904:[582,80,810,54,756],8942:[606,104,511,192,319],8943:[316,-189,926,108,818],8945:[520,18,926,194,732],8968:[713,213,469,188,447],8969:[713,213,469,27,286],8970:[713,213,469,188,447],8971:[713,213,469,27,286],8994:[360,-147,1019,54,965],8995:[360,-147,1019,54,965],9135:[286,-220,315,0,315],9168:[405,-101,511,222,288],9651:[811,127,1145,35,1110],9657:[555,50,660,80,605],9661:[811,127,1145,35,1110],9667:[554,51,660,55,580],9711:[785,282,1207,70,1137],9824:[609,99,685,34,651],9825:[603,105,685,34,651],9826:[609,105,685,41,643],9827:[603,99,685,34,651],9837:[768,10,426,57,346],9838:[768,181,426,75,350],9839:[768,181,426,41,386],10216:[713,213,400,77,335],10217:[713,213,400,65,323],10222:[676,177,233,56,211],10223:[676,177,233,22,177],10229:[449,-58,1574,55,1519],10230:[449,-57,1574,55,1519],10231:[449,-57,1574,55,1519],10232:[551,45,1574,55,1519],10233:[551,45,1574,55,1519],10234:[517,10,1574,55,1519],10235:[450,-57,1574,55,1519],10236:[450,-57,1574,55,1519],10741:[710,222,523,46,478],10752:[763,259,1126,53,1073],10753:[763,259,1126,53,1073],10754:[763,259,1126,53,1073],10755:[768,264,924,94,830],10756:[768,264,924,94,830],10757:[763,259,924,94,830],10758:[763,259,924,94,830],10815:[662,0,694,30,664],10927:[609,103,685,64,621],10928:[609,103,685,64,621]};j.FONTDATA.FONTS["STIXGeneral-bold"]={directory:"General/Bold",family:"STIXGeneral",weight:"bold",Ranges:[[160,255,"Latin1Supplement"],[256,383,"LatinExtendedA"],[384,591,"LatinExtendedB"],[592,687,"IPAExtensions"],[688,767,"SpacingModLetters"],[768,879,"CombDiacritMarks"],[880,1023,"GreekAndCoptic"],[1024,1279,"Cyrillic"],[7424,7615,"PhoneticExtensions"],[7680,7935,"LatinExtendedAdditional"],[8192,8303,"GeneralPunctuation"],[8304,8351,"SuperAndSubscripts"],[8352,8399,"CurrencySymbols"],[8400,8447,"CombDiactForSymbols"],[8448,8527,"LetterlikeSymbols"],[8528,8591,"NumberForms"],[8592,8703,"Arrows"],[8704,8959,"MathOperators"],[8960,9215,"MiscTechnical"],[9216,9279,"ControlPictures"],[9312,9471,"EnclosedAlphanum"],[9472,9599,"BoxDrawing"],[9632,9727,"GeometricShapes"],[9728,9983,"MiscSymbols"],[10176,10223,"MiscMathSymbolsA"],[10624,10751,"MiscMathSymbolsB"],[10752,11007,"SuppMathOperators"],[42784,43007,"LatinExtendedD"],[64256,64335,"AlphaPresentForms"],[119808,119859,"MathBold"],[120120,120171,"BBBold"],[120172,120223,"BoldFraktur"],[120276,120327,"MathSSBold"],[120488,120545,"GreekBold"],[120662,120719,"GreekSSBold"],[120782,120791,"MathBold"],[120812,120822,"MathSSBold"]],32:[0,0,250,0,0],33:[691,13,333,81,251],34:[691,-404,555,83,472],35:[700,0,500,5,495],36:[750,99,500,29,472],37:[706,29,749,61,688],38:[691,16,833,62,789],39:[691,-404,278,75,204],40:[694,168,333,46,306],41:[694,168,333,27,287],42:[691,-255,500,56,448],43:[563,57,750,65,685],44:[155,180,250,39,223],45:[287,-171,333,44,287],46:[156,13,250,41,210],47:[691,19,278,-24,302],48:[688,13,500,24,476],49:[688,0,500,65,441],50:[688,0,500,17,478],51:[688,14,500,16,468],52:[688,0,500,19,476],53:[676,8,500,22,470],54:[688,13,500,28,475],55:[676,0,500,17,477],56:[688,13,500,28,472],57:[688,13,500,26,473],58:[472,13,333,82,251],59:[472,180,333,82,266],60:[534,24,750,80,670],61:[399,-107,750,68,682],62:[534,24,750,80,670],63:[689,13,500,57,445],64:[691,19,930,108,822],65:[690,0,722,9,689],66:[676,0,667,16,619],67:[691,19,722,49,687],68:[676,0,722,14,690],69:[676,0,667,16,641],70:[676,0,611,16,583],71:[691,19,778,37,755],72:[676,0,778,21,759],73:[676,0,389,20,370],74:[676,96,500,3,478],75:[676,0,778,30,769],76:[677,0,667,19,638],77:[676,0,944,14,921],78:[676,18,722,16,701],79:[691,19,778,35,743],80:[676,0,611,16,600],81:[691,176,778,35,743],82:[676,0,722,26,716],83:[692,19,556,35,513],84:[676,0,667,31,636],85:[676,19,722,16,701],86:[676,18,722,16,701],87:[676,15,1000,19,981],88:[676,0,722,16,699],89:[676,0,722,15,699],90:[676,0,667,28,634],91:[678,149,333,67,301],92:[691,19,278,-25,303],93:[678,149,333,32,266],94:[676,-311,581,73,509],95:[-75,125,500,0,500],96:[713,-528,333,8,246],97:[473,14,500,25,488],98:[676,14,556,17,521],99:[473,14,444,25,430],100:[676,14,556,25,534],101:[473,14,444,25,427],102:[691,0,333,14,389],103:[473,206,500,28,483],104:[676,0,556,15,534],105:[691,0,278,15,256],106:[691,203,333,-57,263],107:[676,0,556,22,543],108:[676,0,278,15,256],109:[473,0,833,15,814],110:[473,0,556,21,539],111:[473,14,500,25,476],112:[473,205,556,19,524],113:[473,205,556,34,536],114:[473,0,444,28,434],115:[473,14,389,25,361],116:[630,12,333,19,332],117:[461,14,556,16,538],118:[461,14,500,21,485],119:[461,14,722,23,707],120:[461,0,500,12,484],121:[461,205,500,16,482],122:[461,0,444,21,420],123:[698,175,394,22,340],124:[691,19,220,66,154],125:[698,175,394,54,372],126:[333,-173,520,29,491],915:[676,0,620,16,593],916:[690,0,722,33,673],920:[692,18,778,35,743],923:[690,0,707,9,674],926:[676,0,647,40,607],928:[676,0,778,21,759],931:[676,0,671,28,641],933:[692,0,703,7,693],934:[676,0,836,18,818],936:[692,0,808,15,797],937:[692,0,768,28,740]};j.FONTDATA.FONTS["STIXGeneral-italic"]={directory:"General/Italic",family:"STIXGeneral",style:"italic",Ranges:[[160,255,"Latin1Supplement"],[256,383,"LatinExtendedA"],[384,591,"LatinExtendedB"],[592,687,"IPAExtensions"],[688,767,"SpacingModLetters"],[880,1023,"GreekAndCoptic"],[1024,1279,"Cyrillic"],[7680,7935,"LatinExtendedAdditional"],[8192,8303,"GeneralPunctuation"],[8352,8399,"CurrencySymbols"],[8400,8447,"CombDiactForSymbols"],[8448,8527,"LetterlikeSymbols"],[8704,8959,"MathOperators"],[9216,9279,"ControlPictures"],[9312,9471,"EnclosedAlphanum"],[9472,9599,"BoxDrawing"],[64256,64335,"AlphaPresentForms"],[119860,119911,"MathItalic"],[119964,120015,"MathScript"],[120328,120379,"MathSSItalic"],[120484,120485,"ij"],[120546,120603,"GreekItalic"]],32:[0,0,250,0,0],33:[667,11,333,39,304],34:[666,-421,420,144,432],35:[676,0,501,2,540],36:[731,89,500,32,497],37:[706,19,755,80,705],38:[666,18,778,76,723],39:[666,-421,214,132,241],40:[669,181,333,42,315],41:[669,180,333,16,289],42:[666,-255,500,128,492],43:[506,0,675,86,590],44:[101,129,250,-5,135],45:[255,-192,333,49,282],46:[100,11,250,27,138],47:[666,18,278,-65,386],48:[676,7,500,32,497],49:[676,0,500,50,409],50:[676,0,500,12,452],51:[676,7,500,16,465],52:[676,0,500,1,479],53:[666,7,500,15,491],54:[686,7,500,30,521],55:[666,8,500,75,537],56:[676,7,500,30,493],57:[676,17,500,23,492],58:[441,11,333,50,261],59:[441,129,333,26,261],60:[516,10,675,84,592],61:[386,-120,675,86,590],62:[516,10,675,84,592],63:[664,12,500,132,472],64:[666,18,920,118,806],65:[668,0,611,-51,564],66:[653,0,611,-8,588],67:[666,18,667,66,689],68:[653,0,722,-8,700],69:[653,0,611,-1,634],70:[653,0,611,8,645],71:[666,18,722,52,722],72:[653,0,722,-8,769],73:[653,0,333,-8,384],74:[653,18,444,-6,491],75:[653,0,667,7,722],76:[653,0,556,-8,559],77:[653,0,833,-18,872],78:[653,15,667,-20,727],79:[667,18,722,60,699],80:[653,0,611,0,605],81:[666,182,722,59,699],82:[653,0,611,-13,588],83:[667,18,500,17,508],84:[653,0,556,59,633],85:[653,18,722,102,765],86:[653,18,611,76,688],87:[653,18,833,71,906],88:[653,0,611,-29,655],89:[653,0,556,78,633],90:[653,0,556,-6,606],91:[663,153,389,21,391],92:[666,18,278,-41,319],93:[663,153,389,12,382],94:[666,-301,422,0,422],95:[-75,125,500,0,500],96:[664,-492,333,120,311],97:[441,11,501,17,476],98:[683,11,500,23,473],99:[441,11,444,30,425],100:[683,13,500,15,527],101:[441,11,444,31,412],102:[678,207,278,-147,424],103:[441,206,500,8,471],104:[683,9,500,19,478],105:[654,11,278,49,264],106:[652,207,278,-124,279],107:[683,11,444,14,461],108:[683,11,278,41,279],109:[441,9,722,12,704],110:[441,9,500,14,474],111:[441,11,500,27,468],112:[441,205,504,-75,472],113:[441,209,500,25,484],114:[441,0,389,45,412],115:[442,13,389,16,366],116:[546,11,278,38,296],117:[441,11,500,42,475],118:[441,18,444,20,426],119:[441,18,667,15,648],120:[441,11,444,-27,447],121:[441,206,444,-24,426],122:[428,81,389,-2,380],123:[687,177,400,51,407],124:[666,18,275,105,171],125:[687,177,400,-7,349],126:[323,-183,541,40,502],305:[441,11,278,47,235],567:[441,207,278,-124,246],915:[653,0,611,8,645],916:[668,0,611,-32,526],920:[667,18,722,60,699],923:[668,0,611,-51,564],926:[653,0,651,-6,680],928:[653,0,722,-8,769],931:[653,0,620,-6,659],933:[668,0,556,78,648],934:[653,0,741,50,731],936:[667,0,675,77,778],937:[666,0,762,-6,739],945:[441,11,552,27,549],946:[678,205,506,-40,514],947:[435,206,410,19,438],948:[668,11,460,24,460],949:[441,11,444,30,425],950:[683,185,454,30,475],951:[441,205,474,14,442],952:[678,11,480,27,494],953:[441,11,278,49,235],954:[441,13,444,14,465],955:[678,16,458,-12,431],956:[428,205,526,-33,483],957:[441,18,470,20,459],958:[683,185,454,30,446],959:[441,11,500,27,468],960:[428,18,504,19,536],961:[441,205,504,-40,471],962:[441,185,454,30,453],963:[428,11,498,27,531],964:[428,11,410,12,426],965:[441,10,478,19,446],966:[441,205,622,27,590],967:[441,207,457,-108,498],968:[441,205,584,15,668],969:[439,11,686,27,654],977:[678,10,556,19,526],981:[683,205,627,27,595],982:[428,11,792,17,832],1009:[441,205,516,27,484],1013:[441,11,444,30,420],8467:[687,11,579,48,571]};j.FONTDATA.FONTS.STIXIntegralsD={directory:"IntegralsD/Regular",family:"STIXIntegralsD",Ranges:[[32,32,"All"],[160,160,"All"],[8747,8755,"All"],[10763,10780,"All"]],8747:[2000,269,585,56,1035],8750:[2000,269,635,56,1035]};j.FONTDATA.FONTS.STIXNonUnicode={directory:"NonUnicode/Regular",family:"STIXNonUnicode",Ranges:[[32,32,"All"],[160,160,"All"],[57344,63743,"PrivateUse"]],57344:[610,25,1184,829,895],57345:[667,-41,1184,829,1211],57656:[634,-584,480,-10,490],57657:[-127,177,480,-10,490],57659:[955,-512,897,-25,908],57660:[955,-512,897,-11,922],57661:[182,261,897,-25,908],57662:[182,261,897,-11,922],57664:[1218,-820,1844,-10,1854],57665:[-126,524,1844,-10,1854],57674:[955,-820,633,-1,634],57675:[-126,261,633,-1,634],57953:[422,10,523,41,481],57957:[421,0,523,127,405],57961:[421,0,523,68,455],57965:[424,198,523,47,463],57969:[420,198,523,58,480],57973:[421,198,523,66,457],57977:[612,8,523,37,486],57981:[421,198,523,25,490],57985:[606,12,523,47,477],57989:[421,200,523,41,483],57999:[135,0,325,-1,326],58000:[135,0,633,-1,634]};j.FONTDATA.FONTS["STIXNonUnicode-bold"]={directory:"NonUnicode/Bold",family:"STIXNonUnicode",weight:"bold",Ranges:[[32,32,"All"],[160,160,"All"],[57344,63743,"PrivateUse"]]};j.FONTDATA.FONTS["STIXNonUnicode-italic"]={directory:"NonUnicode/Italic",family:"STIXNonUnicode",style:"italic",Ranges:[[32,32,"All"],[160,160,"All"],[57344,63743,"PrivateUse"]],57901:[677,45,852,43,812],57902:[670,3,724,35,709],57903:[671,11,569,43,586],57904:[662,0,801,34,788],57905:[670,4,553,40,599],57906:[662,0,652,43,710],57907:[671,131,580,40,580],57908:[664,21,831,41,845],57909:[662,0,575,38,591],57910:[662,120,632,31,785],57911:[670,13,809,30,783],57912:[670,7,693,30,653],57913:[671,45,1166,40,1128],57914:[795,37,957,40,1064],57915:[669,10,737,38,729],57916:[662,0,667,38,709],57917:[671,131,744,43,704],57918:[662,3,854,38,816],57919:[671,0,634,38,671],57920:[721,0,509,41,730],57921:[672,13,817,37,950],57922:[677,33,638,33,680],57923:[685,32,956,33,998],57924:[672,13,692,38,739],57925:[675,131,719,34,763],57926:[664,94,752,38,714]};j.FONTDATA.FONTS.STIXSizeOneSym={directory:"SizeOneSym/Regular",family:"STIXSizeOneSym",Ranges:[[688,767,"All"],[768,824,"All"],[8254,8254,"All"],[8400,8431,"All"],[8512,8512,"All"],[8730,8732,"All"],[8992,8993,"All"],[9115,9145,"All"],[9180,9185,"All"],[10098,10099,"All"],[10214,10219,"All"],[10627,10630,"All"],[10744,10745,"All"],[10752,10762,"All"],[11004,11007,"All"]],32:[0,0,250,0,0],40:[1066,164,468,139,382],41:[1066,164,468,86,329],47:[1066,164,579,25,552],91:[1066,164,383,180,363],92:[1066,164,579,27,552],93:[1066,164,383,20,203],95:[-127,177,1000,0,1000],123:[1066,164,575,114,466],125:[1066,164,575,109,461],160:[0,0,250,0,0],770:[767,-554,0,-720,-160],771:[750,-598,0,-722,-162],8719:[1500,-49,1355,50,1305],8720:[1500,-49,1355,50,1305],8721:[1499,-49,1292,90,1202],8730:[1552,295,1057,112,1089],8896:[1500,-49,1265,60,1205],8897:[1500,-49,1265,60,1205],8898:[1510,-49,1265,118,1147],8899:[1500,-39,1265,118,1147],8968:[1066,164,453,180,426],8969:[1066,164,453,25,273],8970:[1066,164,453,180,428],8971:[1066,164,453,27,273],9115:[700,305,450,50,400],9116:[705,305,450,50,174],9117:[705,300,450,50,400],9118:[700,305,450,50,400],9119:[705,305,450,276,400],9120:[705,300,450,50,400],9121:[682,323,450,50,415],9122:[687,323,450,50,150],9123:[687,318,450,50,415],9124:[682,323,450,35,400],9125:[687,323,450,300,400],9126:[687,318,450,35,400],9127:[700,305,640,260,600],9128:[705,305,640,40,380],9129:[705,300,640,260,600],9130:[705,305,640,260,380],9131:[700,305,640,40,380],9132:[705,305,640,260,600],9133:[705,300,640,40,380],9134:[610,25,688,294,394],9136:[700,301,600,35,566],9137:[700,301,600,35,566],9143:[1510,345,1184,112,895],9144:[1566,289,721,0,66],9145:[1566,289,721,655,721],9182:[136,89,926,0,925],9183:[789,-564,926,0,925],10216:[1066,164,578,116,462],10217:[1066,164,578,116,462],10752:[1500,-49,1555,52,1503],10753:[1500,-49,1555,52,1503],10754:[1500,-49,1555,52,1503],10756:[1500,-39,1265,118,1147],10757:[1500,-49,1153,82,1071],10758:[1500,-49,1153,82,1071]};j.FONTDATA.FONTS.STIXSizeTwoSym={directory:"SizeTwoSym/Regular",family:"STIXSizeTwoSym",Ranges:[[688,767,"All"],[768,824,"All"],[8254,8254,"All"],[8400,8431,"All"],[8730,8732,"All"],[9115,9145,"All"],[9180,9185,"All"],[10098,10099,"All"],[10214,10219,"All"],[10627,10630,"All"],[11004,11007,"All"]],32:[0,0,250,0,0],40:[1566,279,589,139,503],41:[1566,279,608,114,478],47:[1566,279,806,25,781],91:[1566,279,459,190,422],92:[1566,279,806,25,781],93:[1566,279,459,37,269],95:[-127,177,1500,0,1500],123:[1566,279,717,124,531],125:[1566,279,717,186,593],160:[0,0,250,0,0],770:[777,-564,0,-1150,-171],771:[760,-608,0,-1152,-173],8730:[2056,404,1124,110,1157],8968:[1566,279,524,190,479],8969:[1566,279,526,47,336],8970:[1566,279,524,190,479],8971:[1566,279,526,47,336],9182:[143,81,1460,0,1460],9183:[797,-573,1460,0,1460],10216:[1566,279,622,95,531],10217:[1566,279,622,91,527]};j.FONTDATA.FONTS.STIXSizeThreeSym={directory:"SizeThreeSym/Regular",family:"STIXSizeThreeSym",Ranges:[[688,767,"All"],[768,824,"All"],[8254,8254,"All"],[8400,8431,"All"],[8730,8732,"All"],[9115,9145,"All"],[9180,9185,"All"],[10098,10099,"All"],[10214,10219,"All"],[10627,10630,"All"]],32:[0,0,250,0,0],40:[2066,394,750,182,667],41:[2066,394,750,83,568],47:[2066,394,1101,30,1071],91:[2066,394,508,225,491],92:[2066,394,1101,30,1071],93:[2066,394,508,17,283],95:[-127,177,2000,0,2000],123:[2066,394,906,143,717],125:[2066,394,906,189,763],160:[0,0,250,0,0],770:[777,-564,0,-1610,-150],771:[774,-608,0,-1612,-152],8730:[2565,510,1076,112,1110],8968:[2066,394,565,225,550],8969:[2066,394,565,15,340],8970:[2066,394,565,225,550],8971:[2066,394,565,15,340],9182:[157,86,1886,0,1886],9183:[815,-572,1886,0,1886],10216:[2066,394,765,96,670],10217:[2066,394,765,95,669]};j.FONTDATA.FONTS.STIXSizeFourSym={directory:"SizeFourSym/Regular",family:"STIXSizeFourSym",Ranges:[[688,767,"All"],[768,824,"All"],[8254,8254,"All"],[8400,8431,"All"],[8730,8732,"All"],[9115,9145,"All"],[9180,9185,"All"],[10098,10099,"All"],[10214,10219,"All"],[10627,10630,"All"]],32:[0,0,250,0,0],40:[2566,509,808,124,732],41:[2566,509,808,76,684],47:[2566,509,1309,16,1293],91:[2566,509,661,295,634],92:[2566,509,1309,16,1293],93:[2566,509,661,27,366],95:[-127,177,2500,0,2500],123:[2566,509,1076,173,882],125:[2566,509,1076,194,903],160:[0,0,250,0,0],770:[796,-573,0,-2040,-154],771:[771,-608,0,-2040,-154],8730:[1510,345,1184,112,895],8968:[2566,509,682,295,655],8969:[2566,509,682,27,387],8970:[2566,509,682,295,655],8971:[2566,509,682,27,387],9182:[175,90,2328,0,2328],9183:[837,-572,2328,0,2328],10216:[2566,509,908,113,796],10217:[2566,509,908,112,795]};j.FONTDATA.FONTS.STIXSizeFiveSym={directory:"SizeFiveSym/Regular",family:"STIXSizeFiveSym",Ranges:[[688,767,"All"],[768,824,"All"],[8254,8254,"All"],[8400,8431,"All"],[9115,9145,"All"],[9180,9185,"All"]],32:[0,0,250,0,0],95:[-127,177,3000,0,3000],160:[0,0,250,0,0],770:[816,-572,0,-2485,-157],771:[780,-617,0,-2485,-157],9182:[181,90,3238,0,3238],9183:[844,-573,3238,0,3238]};j.FONTDATA.FONTS.STIXVariants={directory:"Variants/Regular",family:"STIXVariants",Ranges:[[32,32,"All"],[119,124,"All"],[160,160,"All"],[411,411,"All"],[612,612,"All"],[8242,8279,"All"],[8512,8512,"All"],[8592,8595,"All"],[8657,8674,"All"],[8709,8941,"All"],[8994,8995,"All"],[9251,9251,"All"],[9641,9641,"All"],[10812,10990,"All"]],8242:[565,-28,340,44,295],8463:[683,10,579,47,547],8709:[729,74,523,28,502],8726:[710,222,523,46,478],8730:[943,11,737,67,767]};j.FONTDATA.FONTS.STIXGeneral[8942][0]+=400;j.FONTDATA.FONTS.STIXGeneral[8945][0]+=500;j.FONTDATA.FONTS.STIXGeneral[8722][1]+=100;j.FONTDATA.FONTS.STIXGeneral[61][1]+=100;j.FONTDATA.FONTS.STIXNonUnicode[57674][0]+=200;j.FONTDATA.FONTS.STIXNonUnicode[57674][1]+=200;j.FONTDATA.FONTS.STIXNonUnicode[57675][0]+=200;j.FONTDATA.FONTS.STIXNonUnicode[57675][1]+=200;MathJax.Hub.Register.LoadHook(j.fontDir+"/Variants/Regular/All.js",function(){j.FONTDATA.FONTS.STIXVariants[32][2]+=275;j.FONTDATA.FONTS.STIXVariants[32][5]={rfix:275}});MathJax.Hub.Insert(j.FONTDATA.FONTS.STIXGeneral,{8192:[0,0,500,0,0,{space:1}],8193:[0,0,1000,0,0,{space:1}],8194:[0,0,500,0,0,{space:1}],8195:[0,0,1000,0,0,{space:1}],8196:[0,0,333,0,0,{space:1}],8197:[0,0,250,0,0,{space:1}],8198:[0,0,167,0,0,{space:1}],8201:[0,0,167,0,0,{space:1}],8202:[0,0,83,0,0,{space:1}],8203:[0,0,0,0,0,{space:1}]});MathJax.Hub.Browser.Select({MSIE:function(v){if(!v.versionAtLeast("8.0")||document.documentMode<8){var w=j.FONTDATA;w.REMAP[713]=175;w.REMAP[714]=180;w.REMAP[715]=96;w.REMAP[730]=176;w.RANGES[5]=w.RANGES[4];w.RANGES[4]=w.RANGES[3];w.RANGES[3]={name:"greek",low:945,high:1014,offset:"GG",remap:{1013:26,977:27,1008:28,981:29,1009:30,982:31}};w.VARIANT.bold.offsetGG=120514;w.VARIANT.bold.offsetG=120488;w.VARIANT.italic.offsetGG=120572;w.VARIANT.italic.offsetG=120546;w.VARIANT["bold-italic"].offsetGG=120630;w.VARIANT["bold-italic"].offsetG=120604}},Safari:function(v){v.STIXfontBug=v.versionAtLeast("5.1")&&v.isMac},Chrome:function(w){if(w.isMac){var v=navigator.appVersion.match(/AppleWebKit\/(\d+)/);if(v&&parseInt(v[1])>534){w.STIXfontBug=true}}}});if(MathJax.Hub.Browser.STIXfontBug){j.FONTDATA.FONTS.STIXGeneral.family="STIXGeneral-Regular";j.FONTDATA.FONTS["STIXGeneral-italic"].family="STIXGeneral-Italic";delete j.FONTDATA.FONTS["STIXGeneral-italic"].style;j.FONTDATA.FONTS.STIXNonUnicode.family="STIXNonUnicode-Regular";j.FONTDATA.FONTS["STIXNonUnicode-italic"].family="STIXNonUnicode-Italic";delete j.FONTDATA.FONTS["STIXNonUnicode-italic"].style}var e=[];var n=j.Font.div;r.addElement(n,"span",{style:{display:"inline-block","font-family":"STIXNonUnicode","font-weight":"bold"}},["\uE38C\uE38C\uE38C\uE38C\uE38C"]);r.addElement(n,"span",{style:{display:"inline-block","font-family":"STIXNonUnicode","font-weight":"bold"}},["\uE39A\uE39A\uE39A\uE39A\uE39A"]);if(n.lastChild.previousSibling.offsetWidth<n.lastChild.offsetWidth){e.push(["Require",MathJax.Ajax,j.fontDir+"/fontdata-1.0.js"])}n.removeChild(n.lastChild);n.removeChild(n.lastChild);if(!j.Font.testFont({family:"STIXSizeOneSym",testString:"\u02C6"})){e.push(["Require",MathJax.Ajax,j.fontDir+"/fontdata-beta.js"])}e.push(["loadComplete",MathJax.Ajax,j.fontDir+"/fontdata.js"]);MathJax.Callback.Queue.apply(MathJax.Callback,e)})(MathJax.OutputJax["HTML-CSS"],MathJax.ElementJax.mml,MathJax.HTML);


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.Website = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Website = exports.Website = function (_Block) {
		_inherits(Website, _Block);

		function Website() {
			_classCallCheck(this, Website);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		_createClass(Website, [{
			key: "attrs",
			get: function get() {
				return {
					src: new _model.Attribute(),
					width: new _model.Attribute({ default: 200 }),
					height: new _model.Attribute({ default: 200 })
				};
			}
		}, {
			key: "contains",
			get: function get() {
				return null;
			}
		}]);

		return Website;
	}(_model.Block);

	(0, _utils.defParser)(Website, "website", "widgets-website");

	Website.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "iframe", {
			src: node.attrs.src,
			width: node.attrs.width,
			height: node.attrs.height,
			content: "text/html;charset=UTF-8",
			class: "widgets-website widgets-edit",
			frameborder: "1",
			allowfullscreen: "1"
		});
	};

	Website.register("command", "insert", {
		derive: {
			params: [{ name: "URL", attr: "src", label: "Link to website, youTube, Google Maps ...", type: "url",
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "src");
				} }, { name: "Width", attr: "width", label: "Width in pixels", type: "number", default: 200,
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "width");
				},
				options: { min: 50, height: 800 } }, { name: "Height", attr: "height", label: "Height in pixels", type: "number", default: 200,
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "height");
				},
				options: { min: 50, height: 800 } }]
		},
		label: "Website",
		menu: { group: "content", rank: 74, display: { type: "label", label: "Website" } }
	});

	(0, _utils.defParamsClick)(Website, "website:insert");

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-website:hover {\n\tpadding-left: 16px;\n    padding-top: 16px;\n}\n\n");

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.InlineMath = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	__webpack_require__(69);
	__webpack_require__(70);
	__webpack_require__(71);
	__webpack_require__(72);
	__webpack_require__(73);
	__webpack_require__(74);

	var InlineMath = exports.InlineMath = function (_Inline) {
		_inherits(InlineMath, _Inline);

		function InlineMath() {
			_classCallCheck(this, InlineMath);

			return _possibleConstructorReturn(this, _Inline.apply(this, arguments));
		}

		_createClass(InlineMath, [{
			key: "attrs",
			get: function get() {
				return {
					tex: new _model.Attribute()
				};
			}
		}, {
			key: "contains",
			get: function get() {
				return null;
			}
		}]);

		return InlineMath;
	}(_model.Inline);

	(0, _utils.defParser)(InlineMath, "span", "widgets-inlinemath");

	InlineMath.prototype.serializeDOM = function (node) {
		if (node.rendered) {
			node.rendered = node.rendered.cloneNode(true);
		} else {
			node.rendered = (0, _dom.elt)("span", { class: "widgets-inlinemath widgets-edit" }, " \\(" + node.attrs.tex + "\\) ");
			// wait until node is attached to document to render
			MathJax.Hub.Queue(["Delay", MathJax.Callback, 100], ["Typeset", MathJax.Hub, node.rendered]);
		}
		return node.rendered;
	};

	InlineMath.register("command", "insert", {
		derive: {
			params: [{ name: "Latex", attr: "tex", label: "Latex Expression", type: "text",
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "tex");
				} }]
		},
		label: "InlineMath",
		menu: { group: "content", rank: 71, display: { type: "label", label: "Inline Math" } }
	});

	(0, _utils.defParamsClick)(InlineMath, "inlinemath:insert");

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-inlinemath {}\n\n");

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.Image = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Image = exports.Image = function (_Inline) {
		_inherits(Image, _Inline);

		function Image() {
			_classCallCheck(this, Image);

			return _possibleConstructorReturn(this, _Inline.apply(this, arguments));
		}

		_createClass(Image, [{
			key: "attrs",
			get: function get() {
				return {
					src: new _model.Attribute(),
					alt: new _model.Attribute(),
					title: new _model.Attribute(),
					class: new _model.Attribute({ default: "widgets-img widgets-edit" })
				};
			}
		}]);

		return Image;
	}(_model.Inline);

	(0, _utils.defParser)(Image, "img", "widgets-img");

	Image.prototype.serializeDOM = function (node, s) {
		return s.renderAs(node, "img", node.attrs);
	};

	Image.register("command", "insert", {
		derive: {
			params: [{ name: "File", attr: "src", label: "Image File", type: "file", default: "img.png",
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "src");
				} }, { name: "Description", attr: "alt", label: "Description / alternative text", type: "text",
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "alt");
				} }, { name: "Title", attr: "title", label: "Title", type: "text",
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "title");
				} }]
		},
		label: "Image",
		menu: { group: "content", rank: 70, display: { type: "label", label: "Image" } }
	});

	(0, _utils.defParamsClick)(Image, "image:insert", ["all"]);

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-img {}\n\n");

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.SpreadSheet = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SpreadSheet = exports.SpreadSheet = function (_Block) {
		_inherits(SpreadSheet, _Block);

		function SpreadSheet() {
			_classCallCheck(this, SpreadSheet);

			return _possibleConstructorReturn(this, _Block.apply(this, arguments));
		}

		_createClass(SpreadSheet, [{
			key: "attrs",
			get: function get() {
				return {
					data: new _model.Attribute()
				};
			}
		}, {
			key: "contains",
			get: function get() {
				return null;
			}
		}]);

		return SpreadSheet;
	}(_model.Block);

	(0, _utils.defParser)(SpreadSheet, "div", "widgets-spreadsheet");

	SpreadSheet.prototype.serializeDOM = function (node) {
		if (node.rendered) {
			node.rendered = node.rendered.cloneNode(true);
		} else {
			node.rendered = (0, _dom.elt)("div", { class: "widgets-spreadsheet widgets-edit" });
			// wait until node is attached to document to render
			window.setTimeout(function () {
				var data = [["", "Ford", "Volvo", "Toyota", "Honda"], ["2014", 10, 11, 12, 13], ["2015", 20, 11, 14, 13], ["2016", 30, 15, 12, 13]];

				new Handsontable(node.rendered, {
					data: data,
					minSpareRows: 1,
					rowHeaders: true,
					colHeaders: true,
					contextMenu: true
				});
			}, 100);
		}
		return node.rendered;
	};

	SpreadSheet.register("command", "insert", {
		derive: {
			params: [{ name: "Data Link", attr: "data", label: "Link to CSV (fixed for demo)", type: "file", default: "cars.csv",
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "data");
				} }]
		},
		label: "SpreadSheet",
		menu: { group: "content", rank: 75, display: { type: "label", label: "Spreadsheet" } }
	});

	(0, _utils.defParamsClick)(SpreadSheet, "spreadsheet:insert", ["all"]);

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-spreadsheet {\n}\n\n");

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports.CarryForward = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _model = __webpack_require__(3);

	var _dom = __webpack_require__(14);

	var _utils = __webpack_require__(15);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function getCarryOptions(names) {
		return names.map(function (w) {
			return { value: w, label: w };
		});
	}

	var CarryForward = exports.CarryForward = function (_Inline) {
		_inherits(CarryForward, _Inline);

		function CarryForward() {
			_classCallCheck(this, CarryForward);

			return _possibleConstructorReturn(this, _Inline.apply(this, arguments));
		}

		_createClass(CarryForward, [{
			key: "attrs",
			get: function get() {
				return {
					name: new _model.Attribute(),
					model: new _model.Attribute({ default: "user_response" }),
					type: new _model.Attribute({ default: "carry_forward" }),
					class: new _model.Attribute({ default: "widgets-carryforward widgets-edit" })
				};
			}
		}]);

		return CarryForward;
	}(_model.Inline);

	(0, _utils.defParser)(CarryForward, "thinkspace", "widgets-carryforward");

	CarryForward.prototype.serializeDOM = function (node) {
		return (0, _dom.elt)("thinkspace", node.attrs, (0, _dom.elt)("img", { src: "forward.png", width: 16, height: 16, title: "Carry forward " + node.attrs.name }));
	};

	CarryForward.register("command", "insert", {
		derive: {
			params: [{ name: "Name", attr: "name", label: "Element name", type: "select",
				prefill: function prefill(pm) {
					return (0, _utils.selectedNodeAttr)(pm, this, "name");
				},
				options: function options() {
					return getCarryOptions(["test1", "test2"]);
				} }]
		},
		label: "CarryForward",
		menu: { group: "content", rank: 72, display: { type: "label", label: "Carry Forward" } }
	});

	(0, _utils.defParamsClick)(CarryForward, "carryforward:insert", ["all"]);

	(0, _dom.insertCSS)("\n\n.ProseMirror .widgets-carryforward img:hover {\n\tcursor: pointer;\n}\n\n");

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.historyGroup = exports.blockGroup = exports.textblockMenu = exports.insertMenu = exports.inlineGroup = exports.DropdownSubmenu = exports.Dropdown = exports.MenuCommandGroup = exports.MenuCommand = undefined;
	exports.resolveGroup = resolveGroup;
	exports.renderGrouped = renderGrouped;

	var _dom = __webpack_require__(14);

	var _sortedinsert = __webpack_require__(32);

	var _sortedinsert2 = _interopRequireDefault(_sortedinsert);

	var _obj = __webpack_require__(11);

	var _error = __webpack_require__(7);

	var _icons = __webpack_require__(81);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// !! This module defines a number of building blocks for ProseMirror
	// menus, as consumed by the [`menubar`](#menu/menubar) and
	// [`tooltipmenu`](#menu/tooltipmenu) modules.

	// ;; #path=MenuElement #kind=interface
	// The types defined in this module aren't the only thing you can
	// display in your menu. Anything that conforms to this interface can
	// be put into a menu structure.

	// :: (pm: ProseMirror) → ?DOMNode #path=MenuElement.render
	// Render the element for display in the menu. Returning `null` can be
	// used to signal that this element shouldn't be displayed for the
	// given editor state.

	// ;; #path=MenuGroup #kind=interface
	// A menu group represents a group of things that may appear in a
	// menu. It may be either a `MenuElement`, a `MenuCommandGroup`, or an
	// array of such values. Can be reduced to an array of `MenuElement`s
	// using `resolveGroup`.

	var prefix = "ProseMirror-menu";

	function title(pm, command) {
	  if (!command.label) return null;
	  var key = command.name && pm.keyForCommand(command.name);
	  return key ? command.label + " (" + key + ")" : command.label;
	}

	// ;; Wraps a [command](#Command) so that it can be rendered in a
	// menu.

	var MenuCommand = exports.MenuCommand = function () {
	  // :: (union<Command, string>, MenuCommandSpec)

	  function MenuCommand(command, options) {
	    _classCallCheck(this, MenuCommand);

	    this.command_ = command;
	    this.options = options;
	  }

	  // :: Command
	  // Retrieve the command associated with this object.

	  _createClass(MenuCommand, [{
	    key: "command",
	    value: function command(pm) {
	      return typeof this.command_ == "string" ? pm.commands[this.command_] : this.command_;
	    }

	    // :: (ProseMirror) → DOMNode
	    // Renders the command according to its [display
	    // spec](#MenuCommandSpec.display), and adds an event handler which
	    // executes the command when the representation is clicked.

	  }, {
	    key: "render",
	    value: function render(pm) {
	      var cmd = this.command(pm),
	          disabled = false;
	      if (!cmd) return;
	      if (this.options.select != "ignore" && !cmd.select(pm)) {
	        if (this.options.select == null || this.options.select == "hide") return null;else if (this.options.select == "disable") disabled = true;
	      }

	      var disp = this.options.display;
	      if (!disp) _error.AssertionError.raise("No display style defined for menu command " + cmd.name);

	      var dom = undefined;
	      if (disp.render) {
	        dom = disp.render(cmd);
	      } else if (disp.type == "icon") {
	        dom = (0, _icons.getIcon)(cmd.name, disp);
	        if (!disabled && cmd.active(pm)) dom.classList.add(prefix + "-active");
	      } else if (disp.type == "label") {
	        dom = (0, _dom.elt)("div", null, disp.label || cmd.spec.label);
	      } else {
	        _error.AssertionError.raise("Unsupported command display style: " + disp.type);
	      }
	      dom.setAttribute("title", title(pm, cmd));
	      if (this.options.class) dom.classList.add(this.options.class);
	      if (disabled) dom.classList.add(prefix + "-disabled");
	      if (this.options.css) dom.style.cssText += this.options.css;
	      dom.addEventListener("mousedown", function (e) {
	        e.preventDefault();e.stopPropagation();
	        pm.signal("interaction");
	        cmd.exec(pm, null, dom);
	      });
	      return dom;
	    }
	  }]);

	  return MenuCommand;
	}();

	// ;; Represents a [group](#MenuCommandSpec.group) of commands, as
	// they appear in the editor's schema.

	var MenuCommandGroup = exports.MenuCommandGroup = function () {
	  // :: (string, ?MenuCommandSpec)
	  // Create a group for the given group name, optionally adding or
	  // overriding fields in the commands' [specs](#MenuCommandSpec).

	  function MenuCommandGroup(name, options) {
	    _classCallCheck(this, MenuCommandGroup);

	    this.name = name;
	    this.options = options;
	  }

	  _createClass(MenuCommandGroup, [{
	    key: "collect",
	    value: function collect(pm) {
	      var _this = this;

	      var result = [];
	      for (var name in pm.commands) {
	        var cmd = pm.commands[name],
	            spec = cmd.spec.menu;
	        if (spec && spec.group == this.name) (0, _sortedinsert2.default)(result, { cmd: cmd, rank: spec.rank == null ? 50 : spec.rank }, function (a, b) {
	          return a.rank - b.rank;
	        });
	      }
	      return result.map(function (o) {
	        var spec = o.cmd.spec.menu;
	        if (_this.options) spec = (0, _obj.copyObj)(_this.options, (0, _obj.copyObj)(spec));
	        return new MenuCommand(o.cmd, spec);
	      });
	    }

	    // :: (ProseMirror) → [MenuCommand]
	    // Get the group of matching commands in the given editor.

	  }, {
	    key: "get",
	    value: function get(pm) {
	      var groups = pm.mod.menuGroups || this.startGroups(pm);
	      return groups[this.name] || (groups[this.name] = this.collect(pm));
	    }
	  }, {
	    key: "startGroups",
	    value: function startGroups(pm) {
	      var clear = function clear() {
	        pm.mod.menuGroups = null;
	        pm.off("commandsChanging", clear);
	      };
	      pm.on("commandsChanging", clear);
	      return pm.mod.menuGroups = Object.create(null);
	    }
	  }]);

	  return MenuCommandGroup;
	}();

	// ;; A drop-down menu, displayed as a label with a downwards-pointing
	// triangle to the right of it.

	var Dropdown = exports.Dropdown = function () {
	  // :: (Object, MenuGroup)
	  // Create a dropdown wrapping the given group. Options may include
	  // the following properties:
	  //
	  // **`label`**`: string`
	  //   : The label to show on the drop-down control. When
	  //     `activeLabel` is also given, this one is used as a
	  //     fallback.
	  //
	  // **`activeLabel`**`: bool`
	  //   : Instead of showing a fixed label, enabling this causes the
	  //     element to search through its content, looking for an
	  //     [active](#CommandSpec.active) command. If one is found, its
	  //     [`activeLabel`](#MenuCommandSpec.activeLabel) property is
	  //     shown as the drop-down's label.
	  //
	  // **`title`**`: string`
	  //   : Sets the
	  //     [`title`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/title)
	  //     attribute given to the menu control.
	  //
	  // **`class`**`: string`
	  //   : When given, adds an extra CSS class to the menu control.

	  function Dropdown(options, content) {
	    _classCallCheck(this, Dropdown);

	    this.options = options || {};
	    this.content = content;
	  }

	  // :: (ProseMirror) → DOMNode
	  // Returns a node showing the collapsed menu, which expands when clicked.

	  _createClass(Dropdown, [{
	    key: "render",
	    value: function render(pm) {
	      var _this2 = this;

	      if (resolveGroup(pm, this.content).length == 0) return;

	      var label = this.options.activeLabel && this.findActiveIn(this, pm) || this.options.label;
	      var dom = (0, _dom.elt)("div", { class: prefix + "-dropdown " + (this.options.class || ""),
	        style: this.options.css,
	        title: this.options.title }, label);
	      var open = null;
	      dom.addEventListener("mousedown", function (e) {
	        e.preventDefault();e.stopPropagation();
	        if (open && open()) open = null;else open = _this2.expand(pm, dom);
	      });
	      return dom;
	    }
	  }, {
	    key: "expand",
	    value: function expand(pm, dom) {
	      var rendered = renderDropdownItems(resolveGroup(pm, this.content), pm);
	      var box = dom.getBoundingClientRect(),
	          outer = pm.wrapper.getBoundingClientRect();
	      var menuDOM = (0, _dom.elt)("div", { class: prefix + "-dropdown-menu " + (this.options.class || ""),
	        style: "left: " + (box.left - outer.left) + "px; top: " + (box.bottom - outer.top) + "px" }, rendered);

	      var done = false;
	      function finish() {
	        if (done) return;
	        done = true;
	        pm.off("interaction", finish);
	        pm.wrapper.removeChild(menuDOM);
	        return true;
	      }
	      pm.signal("interaction");
	      pm.wrapper.appendChild(menuDOM);
	      pm.on("interaction", finish);
	      return finish;
	    }
	  }, {
	    key: "findActiveIn",
	    value: function findActiveIn(element, pm) {
	      var items = resolveGroup(pm, element.content);
	      for (var i = 0; i < items.length; i++) {
	        var cur = items[i];
	        if (cur instanceof MenuCommand) {
	          var active = cur.command(pm).active(pm);
	          if (active) return cur.options.activeLabel;
	        } else if (cur instanceof DropdownSubmenu) {
	          var found = this.findActiveIn(cur, pm);
	          if (found) return found;
	        }
	      }
	    }
	  }]);

	  return Dropdown;
	}();

	function renderDropdownItems(items, pm) {
	  var rendered = [];
	  for (var i = 0; i < items.length; i++) {
	    var inner = items[i].render(pm);
	    if (inner) rendered.push((0, _dom.elt)("div", { class: prefix + "-dropdown-item" }, inner));
	  }
	  if (!rendered.length) rendered.push((0, _dom.elt)("div", { class: prefix + "-dropdown-empty" }, "(empty)"));
	  return rendered;
	}

	// ;; Represents a submenu wrapping a group of items that start hidden
	// and expand to the right when hovered over or tapped.

	var DropdownSubmenu = exports.DropdownSubmenu = function () {
	  // :: (Object, MenuGroup)
	  // Creates a submenu for the given group of menu elements. The
	  // following options are recognized:
	  //
	  // **`label`**`: string`
	  //   : The label to show on the submenu.

	  function DropdownSubmenu(options, content) {
	    _classCallCheck(this, DropdownSubmenu);

	    this.options = options || {};
	    this.content = content;
	  }

	  // :: (ProseMirror) → DOMNode
	  // Renders the submenu.

	  _createClass(DropdownSubmenu, [{
	    key: "render",
	    value: function render(pm) {
	      var items = resolveGroup(pm, this.content);
	      if (!items.length) return;

	      var label = (0, _dom.elt)("div", { class: prefix + "-submenu-label" }, this.options.label);
	      var wrap = (0, _dom.elt)("div", { class: prefix + "-submenu-wrap" }, label, (0, _dom.elt)("div", { class: prefix + "-submenu" }, renderDropdownItems(items, pm)));
	      label.addEventListener("mousedown", function (e) {
	        e.preventDefault();e.stopPropagation();
	        wrap.classList.toggle(prefix + "-submenu-wrap-active");
	      });
	      return wrap;
	    }
	  }]);

	  return DropdownSubmenu;
	}();

	// :: (ProseMirror, MenuGroup) → [MenuElement]
	// Resolve the given `MenuGroup` into a flat array of renderable
	// elements.

	function resolveGroup(pm, content) {
	  var result = undefined,
	      isArray = Array.isArray(content);
	  for (var i = 0; i < (isArray ? content.length : 1); i++) {
	    var cur = isArray ? content[i] : content;
	    if (cur instanceof MenuCommandGroup) {
	      var elts = cur.get(pm);
	      if (!isArray || content.length == 1) return elts;else result = (result || content.slice(0, i)).concat(elts);
	    } else if (result) {
	      result.push(cur);
	    }
	  }
	  return result || (isArray ? content : [content]);
	}

	// :: (ProseMirror, [MenuGroup]) → ?DOMFragment
	// Render the given menu groups into a document fragment, placing
	// separators between them (and ensuring no superfluous separators
	// appear when some of the groups turn out to be empty).
	function renderGrouped(pm, content) {
	  var result = document.createDocumentFragment(),
	      needSep = false;
	  for (var i = 0; i < content.length; i++) {
	    var items = resolveGroup(pm, content[i]),
	        added = false;
	    for (var j = 0; j < items.length; j++) {
	      var rendered = items[j].render(pm);
	      if (rendered) {
	        if (!added && needSep) result.appendChild(separator());
	        result.appendChild((0, _dom.elt)("span", { class: prefix + "item" }, rendered));
	        added = true;
	      }
	    }
	    if (added) needSep = true;
	  }
	  return result;
	}

	function separator() {
	  return (0, _dom.elt)("span", { class: prefix + "separator" });
	}

	// ;; #path=CommandSpec #kind=interface #noAnchor
	// The `menu` module gives meaning to an additional property in
	// [command specs](#CommandSpec).

	// :: MenuCommandSpec #path=CommandSpec.menu
	// Adds the command to a menu group, so that it is picked up by
	// `MenuCommandGroup` objects with the matching
	// [name](#MenuCommandSpec.name).

	// ;; #path=MenuCommandSpec #kind=interface
	// Configures the way a command shows up in a menu, when wrapped in a
	// `MenuCommand`.

	// :: string #path=MenuCommandSpec.group
	// Identifies the group this command should be added to (for example
	// `"inline"` or `"block"`). Only meaningful when associated with a
	// `CommandSpec` (as opposed to passed directly to `MenuCommand`).

	// :: number #path=MenuCommandSpec.rank
	// Determines the command's position in its group (lower ranks come
	// first). Only meaningful in a `CommandSpec`.

	// :: Object #path=MenuCommandSpec.display
	// Determines how the command is shown in the menu. It may have either
	// a `type` property containing one of the strings shown below, or a
	// `render` property that, when called with the command as argument,
	// returns a DOM node representing the command's menu representation.
	//
	// **`"icon"`**
	//   : Show the command as an icon. The object may have `{path, width,
	//     height}` properties, where `path` is an [SVG path
	//     spec](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d),
	//     and `width` and `height` provide the viewbox in which that path
	//     exists. Alternatively, it may have a `text` property specifying
	//     a string of text that makes up the icon, with an optional
	//     `style` property giving additional CSS styling for the text.
	//
	// **`"label"`**
	//   : Render the command as a label. Mostly useful for commands
	//     wrapped in a [drop-down](#Dropdown) or similar menu. The object
	//     should have a `label` property providing the text to display.

	// :: string #path=MenuCommandSpec.activeLabel
	// When used in a `Dropdown` with `activeLabel` enabled, this should
	// provide the text shown when the command is active.

	// :: string #path=MenuCommandSpec.select
	// Controls whether the command's [`select`](#CommandSpec.select)
	// method has influence on its appearance. When set to `"hide"`, or
	// not given, the command is hidden when it is not selectable. When
	// set to `"ignore"`, the `select` method is not called. When set to
	// `"disable"`, the command is shown in disabled form when `select`
	// returns false.

	// :: string #path=MenuCommandSpec.class
	// Optionally adds a CSS class to the command's DOM representation.

	// :: string #path=MenuCommandSpec.css
	// Optionally adds a string of inline CSS to the command's DOM
	// representation.

	// :: MenuCommandGroup
	// The inline command group.
	var inlineGroup = exports.inlineGroup = new MenuCommandGroup("inline");

	// :: Dropdown
	// The default insert dropdown menu.
	var insertMenu = exports.insertMenu = new Dropdown({ label: "Insert" }, new MenuCommandGroup("insert"));

	// :: Dropdown
	// The default textblock type menu.
	var textblockMenu = exports.textblockMenu = new Dropdown({ label: "Type..", displayActive: true, class: "ProseMirror-textblock-dropdown" }, [new MenuCommandGroup("textblock"), new DropdownSubmenu({ label: "Heading" }, new MenuCommandGroup("textblockHeading"))]);

	// :: MenuCommandGroup
	// The block command group.
	var blockGroup = exports.blockGroup = new MenuCommandGroup("block");

	// :: MenuCommandGroup
	// The history command group.
	var historyGroup = exports.historyGroup = new MenuCommandGroup("history");

	(0, _dom.insertCSS)("\n\n.ProseMirror-textblock-dropdown {\n  min-width: 3em;\n}\n\n." + prefix + " {\n  margin: 0 -4px;\n  line-height: 1;\n}\n\n.ProseMirror-tooltip ." + prefix + " {\n  width: -webkit-fit-content;\n  width: fit-content;\n  white-space: pre;\n}\n\n." + prefix + "item {\n  margin-right: 3px;\n  display: inline-block;\n}\n\n." + prefix + "separator {\n  border-right: 1px solid #ddd;\n  margin-right: 3px;\n}\n\n." + prefix + "-dropdown, ." + prefix + "-dropdown-menu {\n  font-size: 90%;\n}\n\n." + prefix + "-dropdown {\n  padding: 1px 14px 1px 4px;\n  display: inline-block;\n  vertical-align: 1px;\n  position: relative;\n  cursor: pointer;\n}\n\n." + prefix + "-dropdown:after {\n  content: \"\";\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid currentColor;\n  opacity: .6;\n  position: absolute;\n  right: 2px;\n  top: calc(50% - 2px);\n}\n\n." + prefix + "-dropdown-menu, ." + prefix + "-submenu {\n  position: absolute;\n  background: white;\n  color: #666;\n  border: 1px solid #aaa;\n  padding: 2px;\n}\n\n." + prefix + "-dropdown-menu {\n  z-index: 15;\n  min-width: 6em;\n}\n\n." + prefix + "-dropdown-item {\n  cursor: pointer;\n  padding: 2px 8px 2px 4px;\n}\n\n." + prefix + "-dropdown-item:hover {\n  background: #f2f2f2;\n}\n\n." + prefix + "-dropdown-empty {\n  opacity: 0.4;\n}\n\n." + prefix + "-submenu-wrap {\n  position: relative;\n  margin-right: -4px;\n}\n\n." + prefix + "-submenu-label:after {\n  content: \"\";\n  border-top: 4px solid transparent;\n  border-bottom: 4px solid transparent;\n  border-left: 4px solid currentColor;\n  opacity: .6;\n  position: absolute;\n  right: 4px;\n  top: calc(50% - 4px);\n}\n\n." + prefix + "-submenu {\n  display: none;\n  min-width: 4em;\n  left: 100%;\n  top: -3px;\n}\n\n." + prefix + "-active {\n  background: #eee;\n  border-radius: 4px;\n}\n\n." + prefix + "-active {\n  background: #eee;\n  border-radius: 4px;\n}\n\n." + prefix + "-disabled {\n  opacity: .3;\n}\n\n." + prefix + "-submenu-wrap:hover ." + prefix + "-submenu, ." + prefix + "-submenu-wrap-active ." + prefix + "-submenu {\n  display: block;\n}\n");

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getIcon = getIcon;

	var _dom = __webpack_require__(14);

	var svgCollection = null;
	var svgBuilt = Object.create(null);

	var SVG = "http://www.w3.org/2000/svg";
	var XLINK = "http://www.w3.org/1999/xlink";

	var prefix = "ProseMirror-icon";

	function getIcon(name, data) {
	  var node = document.createElement("div");
	  node.className = prefix;
	  if (data.path) {
	    if (!svgBuilt[name]) buildSVG(name, data);
	    var svg = node.appendChild(document.createElementNS(SVG, "svg"));
	    svg.style.width = data.width / data.height + "em";
	    var use = svg.appendChild(document.createElementNS(SVG, "use"));
	    use.setAttributeNS(XLINK, "href", "#pm-icon-" + name);
	  } else {
	    node.appendChild(document.createElement("span")).textContent = data.text;
	    if (data.css) node.firstChild.style.cssText = data.css;
	  }
	  return node;
	}

	function buildSVG(name, data) {
	  if (!svgCollection) {
	    svgCollection = document.createElementNS(SVG, "svg");
	    svgCollection.style.display = "none";
	    document.body.insertBefore(svgCollection, document.body.firstChild);
	  }
	  var sym = document.createElementNS(SVG, "symbol");
	  sym.id = "pm-icon-" + name;
	  sym.setAttribute("viewBox", "0 0 " + data.width + " " + data.height);
	  var path = sym.appendChild(document.createElementNS(SVG, "path"));
	  path.setAttribute("d", data.path);
	  svgCollection.appendChild(sym);
	  svgBuilt[name] = true;
	}

	(0, _dom.insertCSS)("\n." + prefix + " {\n  display: inline-block;\n  line-height: .8;\n  vertical-align: -2px; /* Compensate for padding */\n  padding: 2px 8px;\n  cursor: pointer;\n}\n\n." + prefix + " svg {\n  fill: currentColor;\n  height: 1em;\n}\n\n." + prefix + " span {\n  vertical-align: text-top;\n}");

/***/ }
/******/ ])
});
;